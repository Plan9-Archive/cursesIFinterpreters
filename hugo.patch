diff -Naur hugov3.1.03/Makefile /usr/glenda/cursesif/hugo/Makefile
--- hugov3.1.03/Makefile	Fri Oct  9 18:12:02 2015
+++ /usr/glenda/cursesif/hugo/Makefile	Fri Sep 25 10:23:23 2015
@@ -42,7 +42,7 @@
 #
 # The following defines set configuration options:
 #	DO_COLOR	turns on color handling (requires ncurses)
-CFG_OPTIONS=-DDO_COLOR
+#CFG_OPTIONS=-DDO_COLOR
 
 # Define your optimization flags.  Most compilers understand -O and -O2,
 # Debugging
@@ -50,19 +50,15 @@
 # Standard optimizations
 # Pentium with gcc 2.7.0 or better
 #CFLAGS=-O2 -Wall -fomit-frame-pointer -malign-functions=2 -malign-loops=2 -malign-jumps=2
-CFLAGS=-O2 -Wall
+#CFLAGS=-O2 -Wall
+CFLAGS=
 # If you are using the ncurses package, define NCURSES for the compiler
-CFLAGS:=$(CFLAGS) -DNCURSES -DGCC_UNIX -DUSE_TEMPFILES
-ifeq ($(MAKECMDGOALS), he)
-CFLAGS:=$(CFLAGS) -DNO_LATIN1_CHARSET
-endif
-ifeq ($(MAKECMDGOALS), hd)
-CFLAGS:=$(CFLAGS) -DDEBUGGER -DFRONT_END -DNO_LATIN1_CHARSET
-endif
+CFLAGS:=$(CFLAGS) -DCURSES
 
 # If you need a special include path to get the right curses header, specify
 # it.
-CC=gcc -I/usr/local/include -Isource $(CFG_OPTIONS) $(CFLAGS)
+#CC=gcc -I/usr/local/include -Isource $(CFG_OPTIONS) $(CFLAGS)
+CC=pcc -Isource 
 
 # If using ncurses you need -lncurses, otherwise use -lcurses.  You may also
 # need -ltermcap or -ltermlib.  If you need to specify a particular path to
@@ -71,7 +67,7 @@
 #HE_LIBS=-lcurses -ltermcap
 #HE_LIBS=-lcurses -ltermlib
 #HE_LIBS=-lcurses 
-HE_LIBS=-lncurses 
+HE_LIBS=-lcurses 
 
 # Shouldn't need to change anything below here.
 HC_H=$(SOURCE)/hcheader.h $(SOURCE)/htokens.h
diff -Naur hugov3.1.03/source/hc.c /usr/glenda/cursesif/hugo/source/hc.c
--- hugov3.1.03/source/hc.c	Fri Oct  9 18:12:02 2015
+++ /usr/glenda/cursesif/hugo/source/hc.c	Thu Oct  1 02:31:39 2015
@@ -47,7 +47,7 @@
 
 	if (argc==1) Banner(stdout, "");
 
-	ParseCommand(argc, argv);       /* Parse command line, then open */
+	ParseCommand(argc, argv);       /* Parse command hugoline, then open */
 	OpenFiles();			/*   files upon returning.	 */
 
 	if (listing && !spellcheck) Banner(listfile, listfilename);
diff -Naur hugov3.1.03/source/hcbuild.c /usr/glenda/cursesif/hugo/source/hcbuild.c
--- hugov3.1.03/source/hcbuild.c	Fri Oct  9 18:12:02 2015
+++ /usr/glenda/cursesif/hugo/source/hcbuild.c	Thu Oct  1 02:31:39 2015
@@ -45,7 +45,7 @@
 	This is the main coding loop, called when a block of code is
 	to be compiled.  Here are made any decisions as to special
 	handling of loops and other constructions; the default is
-	simply to code the line as is by calling CodeLine().  The
+	simply to code the hugoline as is by calling CodeLine().  The
 	'from' argument is for when BuildCode() is called for a
 	particular reason, such as from CodeLine().
 */
@@ -61,7 +61,7 @@
 	int block_finished = 0;
 
 	long returnpos, skipaddr;	/* to relocate after coding an in- */
-					/*   line property routine assign. */
+					/*   hugoline property routine assign. */
 
 	enternest = nest;
 	do
@@ -158,8 +158,8 @@
 		{
 			if (sinceif > 1)
 			{
-				sprintf(line, "'%s' statement does not follow 'if'/'elseif'", word[1]);
-				Error(line);
+				sprintf(hugoline, "'%s' statement does not follow 'if'/'elseif'", word[1]);
+				Error(hugoline);
 			}
 			sinceif = 0;
 			CodeIf();
@@ -198,8 +198,8 @@
 		{
 			if (from==WINDOW_T || from==WRITEFILE_T)
 			{
-				sprintf(line, "'jump' or label illegal in '%s' block", token[from]);
-				Error(line);
+				sprintf(hugoline, "'jump' or label illegal in '%s' block", token[from]);
+				Error(hugoline);
 			}
 
 			if (word[1][0]=='~') goto ChecktheLine;
@@ -208,7 +208,7 @@
 
 		else
                 {
-			/* First of all, check to see if we're coding a line
+			/* First of all, check to see if we're coding a hugoline
 			   that will never be reached.  A previous 'return',
 			   'jump', or 'break' at this nesting level is the signal,
 			   which is erased if a label is encountered.
@@ -221,7 +221,7 @@
 			  	block_finished = nest;
 			}
 
-			/* Here, the default is simply to code the line.
+			/* Here, the default is simply to code the hugoline.
 			   The checkcompprop flag is set to true because
 			   none of the above constructions is legal in a
 			   complex property outside the code block itself.
@@ -252,8 +252,8 @@
 			if (unused[i])
 			{
 				words = 0;
-				sprintf(line, "?Unused local variable \"%s\"",  local[i]);
-				Error(line);
+				sprintf(hugoline, "?Unused local variable \"%s\"",  local[i]);
+				Error(hugoline);
 			}
 		}
 	}
@@ -334,8 +334,8 @@
 
 void PropertyAlreadyDefined(int i)
 {
-	sprintf(line, "?Property \"%s\" already defined", property[i]);
-	Error(line);
+	sprintf(hugoline, "?Property \"%s\" already defined", property[i]);
+	Error(hugoline);
 }
 
 void BuildObject(int from)
@@ -346,7 +346,7 @@
 	int objstack[16],
 		objstackcount = 0;	/* for multiple-object inheritance */
 
-	int inobj = 0, linesdone = 0,
+	int inobj = 0, hugolinesdone = 0,
 		isnot = 0,		/* isnot is true if attributes are */
 					/*   being enumerated as beginning */
 					/*   with "is not..."		   */
@@ -392,7 +392,7 @@
 	if ((words) && word[1][0]=='\"')
 	{
 		StripQuotes(word[1]);
-		strcpy(line, word[1]);
+		strcpy(hugoline, word[1]);
 		KillWord(1);
 
 		/* property 0 (name) */
@@ -402,14 +402,14 @@
 		SavePropData(1);
 
 		/* Write the dictionary position */
-		SavePropData(AddDictionary(line));
+		SavePropData(AddDictionary(hugoline));
 
 		if (!(propadd[0] & ADDITIVE_FLAG)) propset[0] = 1;
 		proptable = proptable + 4;
 	}
 
 	/* Since it's possible to put an "in" or "nearby" directive on
-	   the same line as the declaration, only get a new line if there
+	   the same hugoline as the declaration, only get a new hugoline if there
 	   are no more words remaining on this one.
 	*/
 	if (!words)
@@ -423,9 +423,9 @@
 
 	do
 	{
-		/* linesdone is gives the number of lines already
+		/* hugolinesdone is gives the number of hugolines already
 		   processed */
-		if (linesdone++)
+		if (hugolinesdone++)
 		{
 			GetWords();
 		}
@@ -446,8 +446,8 @@
 		{
 			if (parent[objectctr])
 			{
-				sprintf(line, "\"%s\" already placed in object tree", object[objectctr]);
-				Error(line);
+				sprintf(hugoline, "\"%s\" already placed in object tree", object[objectctr]);
+				Error(hugoline);
 			}
 
 			if (!strcmp(word[1], "nearby") && !strcmp(word[2], "") && objectctr)
@@ -469,17 +469,17 @@
 					Error("No such object");
 			}
 
-			if (words>2) Expect(3, "NULL", "end-of-line after object");
+			if (words>2) Expect(3, "NULL", "end-of-hugoline after object");
 
-			/* Just in case "in" or "nearby" comes on the first line of
+			/* Just in case "in" or "nearby" comes on the first hugoline of
 			   the object declaration
 			*/
-			if (linesdone==1 && !inobj)
+			if (hugolinesdone==1 && !inobj)
 			{
 				GetWords();
 				DoBrace();
 				inobj = true;
-				linesdone = 0;
+				hugolinesdone = 0;
 				continue;
 			}
 
@@ -575,8 +575,8 @@
 				/* If not a valid attribute or alias */
 				if (flag == 0)
 				{
-					sprintf(line, "Undefined attribute \"%s\"", word[i]);
-					Error(line);
+					sprintf(hugoline, "Undefined attribute \"%s\"", word[i]);
+					Error(hugoline);
 				}
 			}
 
@@ -641,8 +641,8 @@
 		/* Neither a property or an alias */
 		if (flag == 0)
 		{
-			sprintf(line, "Undefined property \"%s\"", word[1]);
-			Error(line);
+			sprintf(hugoline, "Undefined property \"%s\"", word[1]);
+			Error(hugoline);
 		}
 
 NextCase:;
@@ -662,11 +662,11 @@
 	/* Finally, if no textual name was given, create one: */
 	if (!propset[0])
 	{
-		sprintf(line, "(%s)", object[objectctr]);
+		sprintf(hugoline, "(%s)", object[objectctr]);
 
 		SavePropData(0);
 		SavePropData(1);
-		SavePropData(AddDictionary(line));
+		SavePropData(AddDictionary(hugoline));
 
 		if (!(propadd[0] & ADDITIVE_FLAG)) propset[0] = 1;
 		proptable = proptable + 4;
@@ -721,8 +721,8 @@
 			*/
 			if (t >= PROP_LINK_ROUTINE)
 			{
-				sprintf(line, "Properties limited to %d elements", PROP_LINK_ROUTINE-1);
-				Error(line);
+				sprintf(hugoline, "Properties limited to %d elements", PROP_LINK_ROUTINE-1);
+				Error(hugoline);
 				return;
 			}
 
@@ -750,8 +750,8 @@
 		*/
 		if (words-1-neg >= PROP_LINK_ROUTINE)
 		{
-			sprintf(line, "Properties limited to %d elements", PROP_LINK_ROUTINE-1);
-			Error(line);
+			sprintf(hugoline, "Properties limited to %d elements", PROP_LINK_ROUTINE-1);
+			Error(hugoline);
 			return;
 		}
 		neg_count = neg;
@@ -794,10 +794,10 @@
 				{
 					if (word[i][j]>='A' && word[i][j]<='Z')
 					{
-						sprintf(line,
+						sprintf(hugoline,
 							"?Uppercase character(s) in %s",
 							property[p]);
-						Error(line);
+						Error(hugoline);
 						break;
 					}
 				}
@@ -921,8 +921,8 @@
 
 /* BUILDVERB
 
-	To be honest, BuildVerb() really only codes the first line of a
-	verb definition.  All the following lines are handled by CodeLine(),
+	To be honest, BuildVerb() really only codes the first hugoline of a
+	verb definition.  All the following hugolines are handled by CodeLine(),
 	as called by BuildCode().
 */
 
@@ -1005,8 +1005,8 @@
 
 	if (obj >= objectctr)
 	{
-		sprintf(line, "?Cannot inherit from unbuilt \"%s\"", object[obj]);
-		Error(line);
+		sprintf(hugoline, "?Cannot inherit from unbuilt \"%s\"", object[obj]);
+		Error(hugoline);
 		return;
 	}
 
diff -Naur hugov3.1.03/source/hccode.c /usr/glenda/cursesif/hugo/source/hccode.c
--- hugov3.1.03/source/hccode.c	Fri Oct  9 18:12:02 2015
+++ /usr/glenda/cursesif/hugo/source/hccode.c	Thu Oct  1 02:31:39 2015
@@ -23,7 +23,7 @@
 /* BEGINCODEBLOCK
 
 	Begins a new block of code, whether or not it is actually
-	enclosed in "{...}", since a single line following an 'if'
+	enclosed in "{...}", since a single hugoline following an 'if'
 	or 'window', etc. may not be.
 */
 
@@ -52,7 +52,7 @@
 {
 	long loopptr, returnpos, tempptr, skipaddr;
 
-	Expect(2, "NULL", "new line following:  do");
+	Expect(2, "NULL", "new hugoline following:  do");
 
 	WriteCode(DO_T, 1);
 	returnpos = codeptr;
@@ -358,36 +358,36 @@
 
 /* CODELINE
 
-	Compiles the line currently loaded in word[].  A brief overview is:
+	Compiles the hugoline currently loaded in word[].  A brief overview is:
 
-		1.  Do any start-of-line analysis
-		2.  Loop through the line word-by-word
+		1.  Do any start-of-hugoline analysis
+		2.  Loop through the hugoline word-by-word
 			- Check current state/adjustments
 			- Main section:  Code tokens appropriately,
 			  setting up syntax flags
 			- Throw up any current-word errors
-		3.  Throw up any end-of-line errors
-		4.  Do any end-of-line adjustments
+		3.  Throw up any end-of-hugoline errors
+		4.  Do any end-of-hugoline adjustments
 */
 
 #define SOME_VALUE	(-1)
 
-char halfline;			/* for ending with "and" or "or"  */
+char halfhugoline;			/* for ending with "and" or "or"  */
 
 void CodeLine(void)
 {
 	int enternest;			/* initial nest level		  */
-	char eol = 0, scolon = 0;       /* flags for end-of-line coding   */
+	char eol = 0, scolon = 0;       /* flags for end-of-hugoline coding   */
 	char assign = 0;                /* when '=' is required (or 'is') */
 	char assignment = 0;		/* when an assignment is coded 	  */
 	int evalue = 0;                 /* expecting a value              */
 	char isneedsval = 0;		/* if 'is' needs a value	  */
 	int invalid_is_val = 0;		/* if "is..." deserves a warning  */
-	char iline = 0;                 /* illegal at start of line 	  */
-	char eline = 0;                 /* illegal at end of line         */
-	char tline = 0;                 /* text-only line 		  */
-	char gline = 0;			/* a grammar-definition line 	  */
-	int nline = 0;                  /* expecting newline before 	  */
+	char ihugoline = 0;                 /* illegal at start of hugoline 	  */
+	char ehugoline = 0;                 /* illegal at end of hugoline         */
+	char thugoline = 0;                 /* text-only hugoline 		  */
+	char ghugoline = 0;			/* a grammar-definition hugoline 	  */
+	int nhugoline = 0;                  /* expecting newhugoline before 	  */
 	char glegal;			/* legal grammar token 		  */
 	char pexpr = 0;			/* possible expression 		  */
 	char expr = 0;     		/* if expression is allowed 	  */
@@ -412,7 +412,7 @@
 	int lastt = 0;			/* last token, or SOME_VALUE 	  */
 	int nextt = 0;			/* counting non-values		  */
 	int firstvalue = 0;             /* set to token # of value if
-					     first token in line 	  */
+					     first token in hugoline 	  */
 
 	long verbskipaddr = 0, tempptr, skipptr;
 	int i;
@@ -420,9 +420,9 @@
 
 
 	enternest = nest;
-	halfline = false;
+	halfhugoline = false;
 
-	/* If line starts with a label */
+	/* If hugoline starts with a label */
 	if (word[1][0]=='~')
 	{
 		Boundary();
@@ -439,11 +439,11 @@
 	{
 		t = IDWord(i);
 
-		/* If this is a continuation of a previous line, the
+		/* If this is a continuation of a previous hugoline, the
 		   first word might get mistaken for printed text (i.e.,
 		   from the text bank) instead of a dictionary entry.
 		*/
-		if (halfline)
+		if (halfhugoline)
 			if (t==TEXTDATA_T) t = DICTENTRY_T;
 
 
@@ -461,14 +461,14 @@
 			}
 		}
 
-		eline = 0;
+		ehugoline = 0;
 		glegal = 0;
 
 		if (eol==1 && i==words && token[t][0]=='}')
 			{WriteCode(EOL_T, 1);
 			eol = 0;}
 
-		/* For verb grammar definition lines: */
+		/* For verb grammar definition hugolines: */
 		if (i==1 && token[t][0]=='*')
 			verbskipaddr = codeptr + 1;
 
@@ -479,8 +479,8 @@
 			case OPEN_BRACKET_T:
 			{
 				brackets++;
-				iline = 1;
-				eline = 1;
+				ihugoline = 1;
+				ehugoline = 1;
 				nextt = 0;
 				glegal = 1;
 				lastt = 0;
@@ -495,7 +495,7 @@
 			case CLOSE_BRACKET_T:
 			{
 				brackets--;
-				iline = 1;
+				ihugoline = 1;
 				glegal = 1;
 				lastt = SOME_VALUE;
 
@@ -520,8 +520,8 @@
 					if ((assign) && !assignment)
 						firstvalue = t;
 
-				iline = 1;
-				eline = 1;
+				ihugoline = 1;
+				ehugoline = 1;
 
 				/* If array[]--used to get the size of an
 				   array...
@@ -533,7 +533,7 @@
 
 					WriteCode(CLOSE_SQUARE_T, 1);
 					i++;
-					eline = 0;
+					ehugoline = 0;
 					lastt = SOME_VALUE;
 				}
 
@@ -550,7 +550,7 @@
 			case CLOSE_SQUARE_T:
 			{
 				sbrackets--;
-				iline = 1;
+				ihugoline = 1;
 				lastt = SOME_VALUE;
 				if (subscript) subscript--;
                                 goto NextWord;
@@ -558,16 +558,16 @@
 
 			case DICTENTRY_T:
 			{
-				if (lastt==SOME_VALUE && !gline) oporsep = i;
+				if (lastt==SOME_VALUE && !ghugoline) oporsep = i;
 
 				WriteCode((unsigned int)token_val, 2);
-				iline = 1;
+				ihugoline = 1;
 				lastt = SOME_VALUE;
 				nextt = 0;
 				glegal = 1;
 				evalue = 0;
 
-				if (!gline) goto NextWord;
+				if (!ghugoline) goto NextWord;
 
 				break;
 			}
@@ -577,7 +577,7 @@
 				if (lastt==SOME_VALUE) oporsep = i;
 
 				WriteCode((unsigned int)token_val, 2);
-				if (i==1 && !halfline)
+				if (i==1 && !halfhugoline)
 					{eol = 1;
 					assign = 1;}
 
@@ -594,12 +594,12 @@
 				
 				else if (lastt==IS_T || lastt==NOT_T)
 				{
-					sprintf(line, "?Property \"%s\" used as attribute", word[i]);
-					Error(line);
+					sprintf(hugoline, "?Property \"%s\" used as attribute", word[i]);
+					Error(hugoline);
 				}
 
 				WriteCode((unsigned int)token_val, 1);
-				iline = 1;
+				ihugoline = 1;
 				nextt = 0;
                                 evalue = 0;
 				lastt = SOME_VALUE;
@@ -612,12 +612,12 @@
 
 				else if (lastt==DECIMAL_T)
 				{
-					sprintf(line, "?Attribute \"%s\" used as property", word[i]);
-					Error(line);
+					sprintf(hugoline, "?Attribute \"%s\" used as property", word[i]);
+					Error(hugoline);
 				}
 
 				WriteCode((unsigned int)token_val, 1);
-				iline = 1;
+				ihugoline = 1;
 				nextt = 0;
                                 glegal = 1;
 				evalue = 0;
@@ -639,8 +639,8 @@
 #endif
 			{
 				eol = 1;
-				if (t != RETURN_T) eline = 1;
-				nline = i;
+				if (t != RETURN_T) ehugoline = 1;
+				nhugoline = i;
 				if (t!=PRINT_T && t!=RETURN_T) evalue = i;
 				break;
 			}
@@ -649,11 +649,11 @@
 			{
 				if (lastt==SOME_VALUE) oporsep = i;
 
-				if (i==1 && !halfline)
+				if (i==1 && !halfhugoline)
 					{eol = 1;
 					assign = 1;}
 				nextt = 1;
-				eline = 1;
+				ehugoline = 1;
 				evalue = i;
 				subscript++;
 				break;
@@ -675,8 +675,8 @@
 			}
 			case RUN_T:
 			{
-				eline = 1;
-				nline = i;
+				ehugoline = 1;
+				nhugoline = i;
 				evalue = i;
 				eol = true;
 				if (t==RUN_T) singleval = true;
@@ -697,20 +697,20 @@
 			{
 				WriteCode((unsigned int)(token_val/65536), 1);
 				WriteCode((unsigned int)(token_val%65536), 2);
-				tline = true;
+				thugoline = true;
 				scolon = true;	 /* trailing semicolon OK */
 				break;
 			}
 
 			case VAR_T:
 			{
-				if (lastt==SOME_VALUE && !gline) oporsep = i;
+				if (lastt==SOME_VALUE && !ghugoline) oporsep = i;
 				
 				else if (token_val<ENGINE_GLOBALS &&
 					(lastt==DECIMAL_T || lastt==IS_T))
 				{
-					sprintf(line, "?Improper use of predefined global \"%s\"", word[i]);
-					Error(line);
+					sprintf(hugoline, "?Improper use of predefined global \"%s\"", word[i]);
+					Error(hugoline);
 				}
 
 				WriteCode((unsigned int)token_val, 1);
@@ -719,7 +719,7 @@
 
 				lastt = SOME_VALUE;
 
-				if (i==1 && !halfline)
+				if (i==1 && !halfhugoline)
 				{
 					assign = 1;
                                         eol = 1;
@@ -732,7 +732,7 @@
 			}
 
 			case CHILDREN_T:
-				iline = 1;
+				ihugoline = 1;
 			case PARENT_T:
 				if (t==PARENT_T && word[i+1][0]!='(' && word[1][0]=='*') glegal = 1;
 			case SIBLING_T:
@@ -751,10 +751,10 @@
 					  Expect(i+1, "( )", "system function number in parentheses");
 					parambrackets = (char)(brackets+1), paramlist++;
 				}
-				if (!glegal && i==1 && !halfline && t!=SYSTEM_T)
+				if (!glegal && i==1 && !halfhugoline && t!=SYSTEM_T)
 					{eol = 1;
 					assign = 1;}
-				eline = 1;
+				ehugoline = 1;
 				nextt = 0;
 				evalue = 0;
 				break;
@@ -762,10 +762,10 @@
 
 			case WORD_T:
 			{
-				if (!gline)
+				if (!ghugoline)
                                         Expect(i+1, "[ ]", "word number in brackets");
 				else glegal = true;
-				if (i==1 && !halfline)
+				if (i==1 && !halfhugoline)
 					{eol = 1;
 					assign = 1;}
 				nextt = 0;
@@ -778,7 +778,7 @@
 			{
 				if (lastt==SOME_VALUE)
 				{
-					if (!gline && !incompprop) oporsep = i;
+					if (!ghugoline && !incompprop) oporsep = i;
 				}
 
 				if (incompprop)
@@ -814,8 +814,8 @@
 				if ((words>2 && word[words][0]!='}') ||
 					(i>1 && strcmp(word[1], "jump")))
 				{
-					sprintf(line, "Improper use of label:  %s", word[i]);
-					Error(line);
+					sprintf(hugoline, "Improper use of label:  %s", word[i]);
+					Error(hugoline);
 				}
 				evalue = 0;
 				break;
@@ -834,7 +834,7 @@
 
 				lastt = SOME_VALUE;
 				nextt = 0;
-                                iline = 1;
+                                ihugoline = 1;
 				evalue = 0;
 				goto NextWord;
 			}
@@ -844,7 +844,7 @@
 				if (lastt==SOME_VALUE) oporsep = i;
 
 				WriteCode((unsigned int)token_val, 2);
-				if (i==1 && !halfline)
+				if (i==1 && !halfhugoline)
 					{eol = 1;
 					assign = 1;}
 				nextt = 0;
@@ -860,7 +860,7 @@
 				Expect(i+1, "( )", "limit in parentheses");
 					parambrackets = (char)(brackets+1), paramlist++;
 
-				iline = 1;
+				ihugoline = 1;
 				nextt = 0;
 				evalue = 0;
 				break;
@@ -874,11 +874,11 @@
 			case RUNEVENTS_T:
 			case CLS_T:
 			{
-				nline = i;
+				nhugoline = i;
 				if ((words > 1) && (word[2][0]!='}' || t==ELSE_T))
 				{
-					sprintf(line, "Expecting end of line after token:  %s", word[i]);
-					Error(line);
+					sprintf(hugoline, "Expecting end of hugoline after token:  %s", word[i]);
+					Error(hugoline);
 				}
 				break;
 			}
@@ -931,11 +931,11 @@
 			case TILDE_T:
 			case NOT_T:
 			{
-				iline = 1;
+				ihugoline = 1;
 				nextt = 1;
 				if (t!=EQUALS_T)
 				{
-					eline = 1;
+					ehugoline = 1;
 					evalue = i;
 
 					if ((t==IS_T) && lastt!=SOME_VALUE)
@@ -947,8 +947,8 @@
 
 			case COMMA_T:
 			{
-				iline = 1;
-				eline = 1;
+				ihugoline = 1;
+				ehugoline = 1;
 				evalue = i;
 
 				if ((singleval) && !brackets) singleval = 2;
@@ -1021,7 +1021,7 @@
 				{
 					GetWords();
 					i = 0;
-					halfline = true;
+					halfhugoline = true;
 					evalue = FAILED;
 				}
 
@@ -1030,8 +1030,8 @@
 
 			case IN_T:
 			{
-				iline = 1;
-				eline = 1;
+				ihugoline = 1;
+				ehugoline = 1;
 				a = 0;
 				if (!strcmp(word[i-1], "not") && 
 					((i>=2) && strcmp(word[i-2], "is")))
@@ -1068,15 +1068,15 @@
 				evalue = i;
 				compstart = codeptr;
 
-				/* A conditional expression line may end with
+				/* A conditional expression hugoline may end with
 				   "and" or "or", signalling the compiler
-				   to get another line.
+				   to get another hugoline.
 				*/
 				if (i==words)
 				{
 					GetWords();
 					i = 0;
-					halfline = true;
+					halfhugoline = true;
 					evalue = FAILED;
 				}
 				break;
@@ -1085,7 +1085,7 @@
 			case ASTERISK_T:
 				if (verbskipaddr)
 					WriteCode(0, 1);
-				if (i==1) expr = true, gline = 1;
+				if (i==1) expr = true, ghugoline = 1;
 			case FORWARD_SLASH_T:
 				glegal = 1;
 				if (word[i-1][0]=='=')
@@ -1109,7 +1109,7 @@
                                                 if (assign && i==2)
 						{
 							if (word[i+2][0]!='}')
-								Expect(i+2, "NULL", "end of line after:  ++ or --");
+								Expect(i+2, "NULL", "end of hugoline after:  ++ or --");
 						}
 						i++;
 
@@ -1128,7 +1128,7 @@
 								lastt = SOME_VALUE;
 						}
 
-						/* end of line */
+						/* end of hugoline */
 						else if (((int)i<words-1) || ((int)i==words-1 && word[words][0]!='}'))
 						{
 							evalue = i;
@@ -1166,15 +1166,15 @@
 			{
 				nextt = 0;
 
-				eline = 1;
+				ehugoline = 1;
 				if (lastt==t)
-					{sprintf(line, "Illegal duplicate operator:  %s%s", token[t], token[t]);
-					Error(line);}
+					{sprintf(hugoline, "Illegal duplicate operator:  %s%s", token[t], token[t]);
+					Error(hugoline);}
 
 				if (!expr && !brackets && !sbrackets)
 					Error("Expecting parentheses around expression");
 				if (t != ASTERISK_T)
-					iline = 1;
+					ihugoline = 1;
 				if (i!=1) evalue = i;
 
 				break;
@@ -1182,7 +1182,7 @@
 
 			case TRUE_T:
 			case FALSE_T:
-				iline = 1;
+				ihugoline = 1;
 			case CALL_T:
 			{
 				nextt = 0;
@@ -1210,15 +1210,15 @@
 			case NUMBER_T:
 				glegal = 1;
 
-				/* Allow double "number" in grammar line */
-				if ((gline) && lastt==t) lastt = 0;
+				/* Allow double "number" in grammar hugoline */
+				if ((ghugoline) && lastt==t) lastt = 0;
 
-				if ((!gline) && strcmp(word[1], "print"))
+				if ((!ghugoline) && strcmp(word[1], "print"))
 					Error("Illegal use of 'number'");
 
 			case CAPITAL_T:
 			case HEX_T:
-				if (!gline)
+				if (!ghugoline)
 				{
 					if (i<words-1 && word[i+1][0]==';')
 					{
@@ -1238,7 +1238,7 @@
 				glegal = 1;
 			case DICT_T:
 				multipleval = 1;
-				if (!gline)
+				if (!ghugoline)
 				{
                                         Expect(i+1, "( )", "formal parameter(s) in parentheses");
 						parambrackets = (char)(brackets+1), paramlist++;
@@ -1260,11 +1260,11 @@
 			case READVAL_T:
 			case PLAYBACK_T:
 			{
-				if (lastt==SOME_VALUE && !gline) oporsep = i;
+				if (lastt==SOME_VALUE && !ghugoline) oporsep = i;
 
-				if (!gline) lastt = SOME_VALUE;
+				if (!ghugoline) lastt = SOME_VALUE;
 				nextt = 0;
-                                if (t!=STRING_T) iline = 1;
+                                if (t!=STRING_T) ihugoline = 1;
 				evalue = 0;
 				goto NextWord;
 			}
@@ -1273,7 +1273,7 @@
 			case READFILE_T:
 			{
 				evalue = true;
-				nline = i;
+				nhugoline = i;
 				eol = true;
 				WriteCode(0, 2);
 				singleval = true;
@@ -1286,7 +1286,7 @@
 				eol = true;
 			case JUMP_T:
 				singleval = true;
-				nline = i;
+				nhugoline = i;
 			case TO_T:
 			{
 				evalue = i;
@@ -1345,9 +1345,9 @@
 					}
 					if (!a)
 					{
-						sprintf(line, "?\"%s\" has no property \"%s\"",
+						sprintf(hugoline, "?\"%s\" has no property \"%s\"",
 							object[obj], property[prop]);
-						Error(line);
+						Error(hugoline);
 					}
 				  }
 SkipObjPropCheck:;
@@ -1366,13 +1366,13 @@
 
 			case TEXT_T:
 			{
-				nline = i;
+				nhugoline = i;
 				if ((words > 1) && word[2][0]!='}')
 				{
 					if (strcmp(word[i+1], "to"))
 					{
-						sprintf(line, "Expecting 'to' after '%s'", word[i]);
-						Error(line);
+						sprintf(hugoline, "Expecting 'to' after '%s'", word[i]);
+						Error(hugoline);
 					}
 					eol = 1;
 					singleval = true;
@@ -1382,7 +1382,7 @@
 
 			case WINDOW_T:
 			{
-				nline = i;
+				nhugoline = i;
 				if ((words > 1) && word[2][0]!='}')
 					evalue = i;
 				eol = 1;
@@ -1392,7 +1392,7 @@
 			case NEWLINE_T:
 			{
 				if ((words > i) && word[i+1][0]!='}')
-					Expect(i+1, ";", "semicolon following 'newline'");
+					Expect(i+1, ";", "semicolon following 'newhugoline'");
 				break;
 			}
 
@@ -1403,7 +1403,7 @@
 			case SOUND_T:
 			case MUSIC_T:
 				evalue = true;
-				nline = i;
+				nhugoline = i;
 				eol = true;
 				break;
 
@@ -1432,8 +1432,8 @@
 			case ADDCONTEXT_T:
 			case VIDEO_T:
 			{
-				sprintf(line, "'%s' not supported in v2.5", word[i]);
-				Error(line);
+				sprintf(hugoline, "'%s' not supported in v2.5", word[i]);
+				Error(hugoline);
 				break;
 			}
 #endif
@@ -1441,57 +1441,57 @@
 
 		if ((t) && t==lastt)
 		{
-			sprintf(line, "Unexpected second \"%s\"", word[i]);
-			Error(line);
+			sprintf(hugoline, "Unexpected second \"%s\"", word[i]);
+			Error(hugoline);
 		}
 
 		if ((incompprop) && !brackets && evalue)
 		{
-			sprintf(line, "Illegal in complex property block heading:  %s", token[t]);
-			Error(line);
+			sprintf(hugoline, "Illegal in complex property block heading:  %s", token[t]);
+			Error(hugoline);
 		}
 
 		lastt = t;
 
 NextWord:
-		/* If the line started with a value, remember what type
+		/* If the hugoline started with a value, remember what type
 		   of value it was.
 		*/
 		if ((i==1) && (assign || pexpr))
 			firstvalue = t;
 
-		if (nline > 1)
+		if (nhugoline > 1)
 		{
-			sprintf(line, "Expecting new line before:  %s", word[nline]);
-			Error(line);
-			nline = 0;
+			sprintf(hugoline, "Expecting new hugoline before:  %s", word[nhugoline]);
+			Error(hugoline);
+			nhugoline = 0;
 		}
-		else if (i==1 && iline && !halfline)
+		else if (i==1 && ihugoline && !halfhugoline)
 		{
-			Error("Illegal at start of line");
-                        iline = 0;
+			Error("Illegal at start of hugoline");
+                        ihugoline = 0;
 		}
 
-		if (gline)
+		if (ghugoline)
 		{
 			if (!glegal)
-				{sprintf(line, "Illegal grammar token:  %s", word[i]);
-				Error(line);}
+				{sprintf(hugoline, "Illegal grammar token:  %s", word[i]);
+				Error(hugoline);}
 		}
 		else if (glegal==2)
-			{sprintf(line, "Illegal use of grammar token:  %s", word[i]);
-			Error(line);}
+			{sprintf(hugoline, "Illegal use of grammar token:  %s", word[i]);
+			Error(hugoline);}
 
 		if (oporsep)
 		{
-			sprintf(line, "Expecting operator or separator before:  %s", word[oporsep]);
-			Error(line);
+			sprintf(hugoline, "Expecting operator or separator before:  %s", word[oporsep]);
+			Error(hugoline);
 			oporsep = 0;
 		}
-		else if (nextt > 1 && !halfline)
+		else if (nextt > 1 && !halfhugoline)
 		{
-			sprintf(line, "Expecting value before:  %s", word[i]);
-			Error(line);
+			sprintf(hugoline, "Expecting value before:  %s", word[i]);
+			Error(hugoline);
 			nextt = 0;
 		}
 
@@ -1509,7 +1509,7 @@
 		if (nextt) nextt++;
 	}
 
-	if (!halfline)
+	if (!halfhugoline)
 	{
 		if (assign)
 		{
@@ -1536,23 +1536,23 @@
 
 	if (sbrackets) Error("Unmatched brackets");
 
-	if (eline) Error("Illegal at end of line");
+	if (ehugoline) Error("Illegal at end of hugoline");
 
 	if (evalue > 0)
 	{
-		sprintf(line, "Expecting %s following:  %s", (!strcmp(word[1], "jump"))?"label":"value", word[evalue]);
-		Error(line);
+		sprintf(hugoline, "Expecting %s following:  %s", (!strcmp(word[1], "jump"))?"label":"value", word[evalue]);
+		Error(hugoline);
 	}
 
 	if (singleval==2)
 	{
-		sprintf(line, "Multiple values illegal after:  %s", word[1]);
-		Error(line);
+		sprintf(hugoline, "Multiple values illegal after:  %s", word[1]);
+		Error(hugoline);
 	}
-	else if (multipleval==1 && !gline)
+	else if (multipleval==1 && !ghugoline)
 	{
-		sprintf(line, "'%s' needs more than one parameter", word[1]);
-		Error(line);
+		sprintf(hugoline, "'%s' needs more than one parameter", word[1]);
+		Error(hugoline);
 	}
 
 	if (moveneedsto) Error("'move' requires 'to'");
@@ -1573,16 +1573,16 @@
 	*/
 	if (invalid_is_val)
 	{
-		sprintf(line, "?\"%s\" used as attribute test", word[invalid_is_val]);
-		Error(line);
+		sprintf(hugoline, "?\"%s\" used as attribute test", word[invalid_is_val]);
+		Error(hugoline);
 	}
 
-	/* Text-only line */
-	if (tline)
+	/* Text-only hugoline */
+	if (thugoline)
 	{
 		if (word[words][0]=='}') words--;
 
-		/* Nothing else is allowed on the line besides "<text>" and
+		/* Nothing else is allowed on the hugoline besides "<text>" and
 		   possibly a trailing semicolon.
 		*/
 		if ((words==2 && word[2][0]!=';') || words > 2)
@@ -1680,7 +1680,7 @@
 	*/	   
 	else
 	{
-		strcpy(line, "");
+		strcpy(hugoline, "");
 		for (i=2; i<=words; i++)
 		{
 			strcat(selectvar, word[i]);
@@ -1871,7 +1871,7 @@
 	if (word[a][0]=='\"')
 	{
 		/* Text string */
-		if (a==1 && !halfline)		/* first word in line */
+		if (a==1 && !halfhugoline)		/* first word in hugoline */
 			{StripQuotes(word[a]);
 			token_val = WriteText(word[a]);
 			return TEXTDATA_T;}
@@ -2000,9 +2000,9 @@
 	{
 		if ((word[a][2]!='\'' && word[a][1]!='\\') || (word[a][1]=='\\' && word[a][3]!='\''))
 		{
-			strcpy(line, "Unknown ASCII value:  ");
-			strncpy(line+strlen(line), word[a], MAXBUFFER-64);
-			Error(line);
+			strcpy(hugoline, "Unknown ASCII value:  ");
+			strncpy(hugoline+strlen(hugoline), word[a], MAXBUFFER-64);
+			Error(hugoline);
 		}
 		if (word[a][1]=='\\') token_val = toascii(word[a][2]);
 		else token_val = toascii(word[a][1]);
@@ -2011,9 +2011,9 @@
 
 	if (!silent_IDWord)
 	{
-		strcpy(line, "Syntax error:  ");
-		strncpy(line+strlen(line), word[a], MAXBUFFER-64);
-		Error(line);
+		strcpy(hugoline, "Syntax error:  ");
+		strncpy(hugoline+strlen(hugoline), word[a], MAXBUFFER-64);
+		Error(hugoline);
 	}
 
 	return 0;
diff -Naur hugov3.1.03/source/hccomp.c /usr/glenda/cursesif/hugo/source/hccomp.c
--- hugov3.1.03/source/hccomp.c	Fri Oct  9 18:12:02 2015
+++ /usr/glenda/cursesif/hugo/source/hccomp.c	Thu Oct  1 02:31:39 2015
@@ -23,7 +23,7 @@
 
 void CompilerDirective(void)
 {
-	char source[MAXPATH];
+	char source[4096];
 	int temptotal;
 	double testver, comparever;
 	long sourcepos;
@@ -57,13 +57,13 @@
 
 			if (testver > comparever)
 			{
-				sprintf(line, "?File requires compiler version %s", word[2]);
-				Error(line);
+				sprintf(hugoline, "?File requires compiler version %s", word[2]);
+				Error(hugoline);
 			}
 			else if (testver < comparever)
 			{
-				sprintf(line, "?Compiler is v%d.%d; file is only v%s", HCVERSION, HCREVISION, word[2]);
-				Error(line);
+				sprintf(hugoline, "?Compiler is v%d.%d; file is only v%s", HCVERSION, HCREVISION, word[2]);
+				Error(hugoline);
 			}
 		}
 	}
@@ -73,8 +73,8 @@
 		if (!strcmp(word[2], "warning"))
 		{
 			StripQuotes(word[3]);
-			sprintf(line, "?%s", word[3]);
-			Error(line);
+			sprintf(hugoline, "?%s", word[3]);
+			Error(hugoline);
 		}
 		else if (!strcmp(word[2], "error"))
 		{
@@ -108,13 +108,13 @@
 		if (ferror(sourcefile)) FatalError(READ_E, sourcefilename);
 		fclose(sourcefile);
 
-		temptotal = totallines;
-		totallines = 0;
+		temptotal = totalhugolines;
+		totalhugolines = 0;
 
 		if (percent)
-			{sprintf(line, "\rCompiling       lines of %s", sourcefilename);
-			strnset(line+26, ' ', strlen(sourcefilename));
-			printf(line);}
+			{sprintf(hugoline, "\rCompiling       hugolines of %s", sourcefilename);
+			strnset(hugoline+26, ' ', strlen(sourcefilename));
+			printf(hugoline);}
 
 		strcpy(sourcefilename, word[2]);
 		if (!(sourcefile = TrytoOpen(sourcefilename, "rb", "source")))
@@ -129,19 +129,19 @@
 			printf("\n");
 			if (listing)
 			{
-				if (fprintf(listfile, "Compiling %5d lines of %s\n", totallines, sourcefilename) < 0)
+				if (fprintf(listfile, "Compiling %5d hugolines of %s\n", totalhugolines, sourcefilename) < 0)
 					FatalError(WRITE_E, listfilename);
 			}
 #if defined (STDPRN_SUPPORTED)
 			if (printer)
 			{
-				if (fprintf(stdprn, "Compiling %5d lines of %s\n", totallines, sourcefilename) < 0)
+				if (fprintf(stdprn, "Compiling %5d hugolines of %s\n", totalhugolines, sourcefilename) < 0)
 					FatalError(WRITE_E, "printer");
 			}
 #endif
 		}
 
-		totallines = temptotal;
+		totalhugolines = temptotal;
 		if (fclose(sourcefile)==EOF) FatalError(READ_E, sourcefilename);
 		strcpy(sourcefilename, source);
 		if (!(sourcefile = HUGO_FOPEN(sourcefilename, "rb"))) FatalError(OPEN_E, sourcefilename);
@@ -196,8 +196,8 @@
 		{
 IfSetError:
 			ifsetnest = MAXIFSETNEST-1;
-			sprintf(line, "#if nested more than %d deep", MAXIFSETNEST-1);
-			Error(line);
+			sprintf(hugoline, "#if nested more than %d deep", MAXIFSETNEST-1);
+			Error(hugoline);
 			return;
 		}
 
@@ -336,7 +336,7 @@
 		}
 		else
 		{
-			Error("Illegal inline limit setting");
+			Error("Illegal inhugoline limit setting");
 			return;
 		}
 	}
@@ -475,8 +475,8 @@
 
 	if (strcmp(e, ""))              /* if there was an error */
 	{
-		sprintf(line, "%s already defined", e);
-		Error(line);
+		sprintf(hugoline, "%s already defined", e);
+		Error(hugoline);
 	}
 	else
 	{
@@ -493,8 +493,8 @@
 	int i;
 
 	if (strlen(word[2]) > 32)
-		{sprintf(line, "Flag name \"%s\" too long", word[2]);
-		Error(line);
+		{sprintf(hugoline, "Flag name \"%s\" too long", word[2]);
+		Error(hugoline);
 		return;}
 
 	if (!strcmp(word[1], "#set"))
@@ -506,15 +506,15 @@
 				free(sets[i]);
 				sets[i] = MakeString(word[2]);
 				/* In case this came from the non-
-				   lowercased command line:
+				   lowercased command hugoline:
 				*/
 				strlwr(sets[i]);
 				return;
 			}
 		}
 
-		sprintf(line, "Maximum of %d compiler flags exceeded", MAXFLAGS);
-		Error(line);
+		sprintf(hugoline, "Maximum of %d compiler flags exceeded", MAXFLAGS);
+		Error(hugoline);
 	}
 	if (!strcmp(word[1], "#clear"))
 	{
@@ -528,7 +528,7 @@
 			}
 		}
 
-		sprintf(line, "Flag not set:  %s", word[2]);
-		Error(line);
+		sprintf(hugoline, "Flag not set:  %s", word[2]);
+		Error(hugoline);
 	}
 }
diff -Naur hugov3.1.03/source/hcdef.c /usr/glenda/cursesif/hugo/source/hcdef.c
--- hugov3.1.03/source/hcdef.c	Fri Oct  9 18:12:02 2015
+++ /usr/glenda/cursesif/hugo/source/hcdef.c	Thu Oct  1 02:31:39 2015
@@ -150,8 +150,8 @@
 
 		default:
 		{
-			sprintf(line, "Illegal initializer:  %s", word[wordnum]);
-			Error(line);
+			sprintf(hugoline, "Illegal initializer:  %s", word[wordnum]);
+			Error(hugoline);
 			return 0;
 		}
 	}
@@ -168,8 +168,8 @@
 	char *b = "";
 
 	if (strlen(a) > MAX_SYMBOL_LENGTH)
-		{sprintf(line, "Symbol name \"%s\" too long", a);
-		Error(line);
+		{sprintf(hugoline, "Symbol name \"%s\" too long", a);
+		Error(hugoline);
 		return;}
 
 	hash = FindHash(a);
@@ -244,8 +244,8 @@
 Checkb:
 	if (b[0]!='\0')
 	{
-		sprintf(line, "\"%s\" previously defined as %s", a, b);
-		Error(line);
+		sprintf(hugoline, "\"%s\" previously defined as %s", a, b);
+		Error(hugoline);
 	}
 }
 
@@ -281,8 +281,8 @@
 
 	if (arrayctr==MAXARRAYS)
 		{arrayctr = MAXARRAYS-1;
-		sprintf(line, "Maximum of %d arrays exceeded", MAXARRAYS);
-		Error(line);}
+		sprintf(hugoline, "Maximum of %d arrays exceeded", MAXARRAYS);
+		Error(hugoline);}
 
 	/* Process any default array values, remembering them for writing
 	   in Pass3()
@@ -291,7 +291,7 @@
 	{
 		unsigned int val;
 
-		if (!Expect(6, "=", "end of line or array assignment(s)"))
+		if (!Expect(6, "=", "end of hugoline or array assignment(s)"))
 			goto SkipAssign;
 		KillWord(6);	/* '=' */
 		RemoveCommas();
@@ -331,8 +331,8 @@
 	{
 		if (IDWord(4)!=ATTR_T)
 		{
-			sprintf(line, "Not an attribute:  %s", word[4]);
-			Error(line);
+			sprintf(hugoline, "Not an attribute:  %s", word[4]);
+			Error(hugoline);
 		}
 		else
 		{
@@ -343,8 +343,8 @@
 
 			if (aliasctr==MAXALIASES)
 				{attrctr = MAXALIASES-1;
-				sprintf(line, "Maximum of %d aliases exceeded", MAXALIASES);
-				Error(line);}
+				sprintf(hugoline, "Maximum of %d aliases exceeded", MAXALIASES);
+				Error(hugoline);}
 		}
 		KillWord(4);
 		KillWord(3);
@@ -357,8 +357,8 @@
 
 		if (attrctr==MAXATTRIBUTES)
 			{attrctr = MAXATTRIBUTES-1;
-			sprintf(line, "Maximum of %d attributes exceeded", MAXATTRIBUTES);
-			Error(line);}
+			sprintf(hugoline, "Maximum of %d attributes exceeded", MAXATTRIBUTES);
+			Error(hugoline);}
 	}
 	if (words > 2) Error("Illegal attribute definition");
 }
@@ -393,8 +393,8 @@
 	if (++syncount==MAXSPECIALWORDS)
 	{
 		syncount--;
-		sprintf(line, "Maximum of %d special words exceeded", MAXSPECIALWORDS);
-		Error(line);
+		sprintf(hugoline, "Maximum of %d special words exceeded", MAXSPECIALWORDS);
+		Error(hugoline);
 	}
 }
 
@@ -422,8 +422,8 @@
 
 	if (constctr == MAXCONSTANTS)
 		{constctr = MAXCONSTANTS-1;
-		sprintf(line, "Maximum of %d constants exceeded", MAXCONSTANTS);
-		Error(line);}
+		sprintf(hugoline, "Maximum of %d constants exceeded", MAXCONSTANTS);
+		Error(hugoline);}
 }
 
 
@@ -502,8 +502,8 @@
 
 		else
 		{
-			sprintf(line, "Syntax error in declaration:  %s", word[thisword]);
-			Error(line);
+			sprintf(hugoline, "Syntax error in declaration:  %s", word[thisword]);
+			Error(hugoline);
 			thisword++;
 		}
 	}
@@ -515,7 +515,7 @@
 
 	while (word[1][0]!='}')
 	{
-		/* Get a line and copy it, because it's going to
+		/* Get a hugoline and copy it, because it's going to
 		   be changed.
 		*/
 		for (i=1; i<=words; i++)
@@ -530,7 +530,7 @@
 			word[words++] = "=";
 
 		/* Count the number of words to be deleted from
-		   the original line.
+		   the original hugoline.
 		*/
 		j = 2;
 
@@ -567,7 +567,7 @@
 			}
 		}
 
-		/* Discrete values in a line of code must be positive
+		/* Discrete values in a hugoline of code must be positive
 		   integers
 		*/
 		if (val < 0)
@@ -633,8 +633,8 @@
 	globalctr++;
 	if (globalctr == MAXGLOBALS)
 		{globalctr = MAXGLOBALS-1;
-		sprintf(line, "Maximum of %d globals exceeded", MAXGLOBALS);
-		Error(line);}
+		sprintf(hugoline, "Maximum of %d globals exceeded", MAXGLOBALS);
+		Error(hugoline);}
 }
 
 
@@ -659,8 +659,8 @@
 		if (localctr==MAXLOCALS)
 		{
 			localctr = MAXLOCALS-1;
-			sprintf(line, "Maximum of %d locals exceeded", MAXLOCALS);
-			Error(line);
+			sprintf(hugoline, "Maximum of %d locals exceeded", MAXLOCALS);
+			Error(hugoline);
 			return;
 		}
 
@@ -730,7 +730,7 @@
 	char other[33], oname[33];
 	int i;
 	int blank = 0;
-	int starting_line = totallines;
+	int starting_hugoline = totalhugolines;
 
 	/* Linking is illegal after definitions */
 	if (!linked) linked = FAILED;
@@ -801,11 +801,11 @@
 
 				if (labelctr == MAXLABELS)
 					{labelctr = MAXLABELS-1;
-					sprintf(line, "Maximum of %d labels exceeded", MAXLABELS);
-					Error(line);}
+					sprintf(hugoline, "Maximum of %d labels exceeded", MAXLABELS);
+					Error(hugoline);}
 
 				if (strcmp(word[3], ""))
-					Error("New line expected after label");
+					Error("New hugoline expected after label");
 			}
 
 			for (i=1; i<=words; i++)
@@ -815,7 +815,7 @@
 			}
 		}
 
-		/* Check for suspicious number of blank lines.  32 lines of
+		/* Check for suspicious number of blank hugolines.  32 hugolines of
 		   white space is a bit much to intentionally leave in a
 		   program, don't you think?
 		*/
@@ -825,13 +825,13 @@
 			if (blank > 32)
 			{
 NoClosingBrace:
-				sprintf(line, "Closing brace missing in %s:  %s", other, oname);
+				sprintf(hugoline, "Closing brace missing in %s:  %s", other, oname);
 
 				/* Force termination */
 				aborterror = true;
-				totallines = starting_line;
+				totalhugolines = starting_hugoline;
 
-				Error(line);
+				Error(hugoline);
 			}
 		}
 	} while (nest > 0);
@@ -868,8 +868,8 @@
 	{
 		if (IDWord(4)!=PROP_T)
 		{
-			sprintf(line, "Not a property:  %s", word[4]);
-			Error(line);
+			sprintf(hugoline, "Not a property:  %s", word[4]);
+			Error(hugoline);
 		}
 		else
 		{
@@ -880,8 +880,8 @@
 
 			if (aliasctr==MAXALIASES)
 				{attrctr = MAXALIASES-1;
-				sprintf(line, "Maximum of %d aliases exceeded", MAXALIASES);
-				Error(line);}
+				sprintf(hugoline, "Maximum of %d aliases exceeded", MAXALIASES);
+				Error(hugoline);}
 		}
 		KillWord(4);
 		KillWord(3);
@@ -907,8 +907,8 @@
 
 		if (propctr==MAXPROPERTIES)
 			{attrctr = MAXPROPERTIES-1;
-			sprintf(line, "Maximum of %d properties exceeded", MAXPROPERTIES);
-			Error(line);}
+			sprintf(hugoline, "Maximum of %d properties exceeded", MAXPROPERTIES);
+			Error(hugoline);}
 	}
 
 	if (words > 2) Error("Illegal property definition");
@@ -942,8 +942,8 @@
 		if (++syncount==MAXSPECIALWORDS)
 		{
 			syncount--;
-			sprintf(line, "Maximum of %d special words exceeded", MAXSPECIALWORDS);
-			Error(line);
+			sprintf(hugoline, "Maximum of %d special words exceeded", MAXSPECIALWORDS);
+			Error(hugoline);
 		}
 
 		KillWord(2);
@@ -977,8 +977,8 @@
 	if (++syncount==MAXSPECIALWORDS)
 	{
 		syncount--;
-		sprintf(line, "Maximum of %d special words exceeded", MAXSPECIALWORDS);
-		Error(line);
+		sprintf(hugoline, "Maximum of %d special words exceeded", MAXSPECIALWORDS);
+		Error(hugoline);
 	}
 }
 
diff -Naur hugov3.1.03/source/hcfile.c /usr/glenda/cursesif/hugo/source/hcfile.c
--- hugov3.1.03/source/hcfile.c	Fri Oct  9 18:12:02 2015
+++ /usr/glenda/cursesif/hugo/source/hcfile.c	Thu Oct  1 02:31:39 2015
@@ -23,7 +23,7 @@
 
 long codeptr = 0;               /* position in object code */
 long textptr = 0;               /* position in text file */
-char buffer[MAXBUFFER];         /* the input line */
+char buffer[MAXBUFFER];         /* the input hugoline */
 int totalfiles = 0;
 
 FILE *sourcefile; char sourcefilename[MAXPATH]; /* original source         */
@@ -56,13 +56,13 @@
 
 /* GETLINE
 
-	Gets an unprocessed line from sourcefile and separates the words.
-	<offset> is set during subsequent calls by SeparateWords if a line
+	Gets an unprocessed hugoline from sourcefile and separates the words.
+	<offset> is set during subsequent calls by SeparateWords if a hugoline
 	ends inside a string constant.
 */
 
 /* hugo_fgets() is for reading (in binary mode) text files with
-   Unix, DOS, and Mac line-endings
+   Unix, DOS, and Mac hugoline-endings
 */
 char *hugo_fgets(char *string, int count, FILE *file)
 {
@@ -120,8 +120,8 @@
 		do
 		{
 GetaNewLine:
-			tlines++;	/* total lines compiled */
-			totallines++;
+			thugolines++;	/* total hugolines compiled */
+			totalhugolines++;
 
 			a = b;
 			if (!hugo_fgets(a, MAXBUFFER*2, sourcefile))
@@ -165,8 +165,8 @@
 						len--;
 					}
 
-					tlines++;
-					totallines++;
+					thugolines++;
+					totalhugolines++;
 
 					if (*a=='!' && *(a+1)=='\\')
 						cnest++;
@@ -203,7 +203,7 @@
 
 /* GETWORDS
 
-	Gets the next line of already-separated words from allfile.
+	Gets the next hugoline of already-separated words from allfile.
 */
 
 void GetWords(void)
@@ -248,23 +248,23 @@
 
 	} while (words==0 && !feof(allfile));
 
-	/* Get line number for error reporting--this is so we can locate
-	   the error even when the lines are being read back from the big,
+	/* Get hugoline number for error reporting--this is so we can locate
+	   the error even when the hugolines are being read back from the big,
 	   contiguous allfile.
 	*/
-	if (word[words+1][1]=='!') errline = ReadWord(allfile);
+	if (word[words+1][1]=='!') errhugoline = ReadWord(allfile);
 
 	word[words+1] = "";
 
 /* Uncomment the following for debugging: */
 /*
-	strcpy(line, "");
+	strcpy(hugoline, "");
 	for (bloc=1; bloc<=words; bloc++)
 	{
-		strcat(line, word[bloc]);
-		strcat(line, " ");
+		strcat(hugoline, word[bloc]);
+		strcat(hugoline, " ");
 	}
-	Printout(line);
+	Printout(hugoline);
 */
 }
 
@@ -334,7 +334,7 @@
 /* TRYTOOPEN
 
 	Tries to open a particular filename (based on a given environment
-	variable or command-line directory).
+	variable or command-hugoline directory).
 */
 
 FILE *TrytoOpen(char *f, char *p, char *d)
@@ -349,7 +349,7 @@
 	/* If the given filename doesn't already specify where to find it */
         if (!strcmp(drive, "") && !strcmp(dir, ""))
 	{
-		/* Check first for a directory in the command line 
+		/* Check first for a directory in the command hugoline 
 		   or source
 		*/
 		for (i=0; i<directoryctr; i++)
diff -Naur hugov3.1.03/source/hcgcc.c /usr/glenda/cursesif/hugo/source/hcgcc.c
--- hugov3.1.03/source/hcgcc.c	Thu Jan  1 00:00:00 1970
+++ /usr/glenda/cursesif/hugo/source/hcgcc.c	Thu Oct  1 02:31:39 2015
@@ -0,0 +1,140 @@
+/*
+	HCGCC.C (by Bill Lash lash@tellabs.com)
+
+	Non-portable functions specific to GCC and UNIX
+
+	This file has changed very little since the hugo 2.0 port.
+	All of the changes that were needed to other files for the
+	2.0 and 2.1 ports are no longer necessary.
+	
+*/
+
+#include "hcheader.h"
+
+/*  MEMORY ALLOCATION: */
+
+void *hugo_malloc(size_t a)
+{
+	return malloc(a);		/* i.e. malloc() */
+}
+
+void hugo_free(void *block)
+{
+	free(block);			/* i.e. free() */
+}
+
+
+/*
+    FILENAME MANAGEMENT:
+
+    Different operating systems will have their own ways of naming
+    files.  The following routines are simply required to know and
+    be able to dissect/build the components of a particular filename,
+    storing/restoring the components via the specified char arrays.
+
+    For example, in MS-DOS:
+
+    	hugo_splitpath("C:\HUGO\FILES\HUGOLIB.H", ...)
+        	becomes:  C:, HUGO\FILES, HUGOLIB, H
+
+    and
+
+    	hugo_makepath(..., "C:", "HUGO\FILES", "HUGOLIB", "H")
+		becomes:  C:\HUGO\FILES\HUGOLIB.H
+
+    The appropriate equivalent nomenclature should be used for the
+    operating system in question.
+*/
+
+void hugo_splitpath(char *path, char *drive, char *dir, char *fname, char *ext)
+{
+char *file;
+char *extension;
+
+        strcpy(drive,"");
+        strcpy(dir,"");
+        strcpy(fname,"");
+        strcpy(ext,"");
+
+        if ((file = strrchr(path,'/')) == 0)
+        {
+                if ((file = strrchr(path,':')) == 0) file = path;
+        }
+        strncpy(dir,path,strlen(path)-strlen(file));
+        *(dir+strlen(path)-strlen(file)) = 0;
+        extension = strrchr(path,'.');
+        if ((extension != 0) && strlen(extension) < strlen(file))
+        {
+                strncpy(fname,file,strlen(file)-strlen(extension));
+                *(fname+strlen(file)-strlen(extension)) = 0;
+                strcpy(ext,extension+1);
+        }
+        else strcpy(fname,file);
+
+        if (strcmp(dir, "") && fname[0]=='/') strcpy(fname, fname+1);
+}
+
+void hugo_makepath(char *path, char *drive, char *dir, char *fname, char *ext)
+{
+        if (*ext == '.') ext++;
+        strcpy(path,drive);
+        strcat(path,dir);
+        switch (*(path+strlen(path)))
+        {
+        case '/':
+        case ':':
+/*        case 0: */
+                break;
+        default:
+                if (strcmp(path, "")) strcat(path,"/");
+                break;
+        }
+        strcat(path,fname);
+        if (strcmp(ext, "")) strcat(path,".");
+/* Crashes without -fwritable-strings:
+        strcat(path,strlwr(ext)); */
+	strcat(path, ext);
+}
+
+
+
+/*
+    CLOSEFILES:
+*/
+
+void hugo_closefiles()
+{
+/*
+          fclose(sourcefile);
+          fclose(objectfile);
+          fclose(textfile);
+          fclose(allfile);
+          fclose(listfile);
+*/
+}
+
+
+/*
+    DATE FUNCTION:
+
+    hugo_date() is only required to produce a date-type, 8-character string,
+    stored in the specified string array.
+*/
+
+char *hugo_date(char *a)
+{
+        time_t now;
+	time(&now);
+	strftime(a,9,"%m-%d-%y",localtime(&now));	/* Stored; no strcpy() will be performed */
+	return a;
+}
+
+
+/*
+    SUPPORT FUNCTIONS:
+*/
+
+void rmtmp(void)
+{
+}
+
diff -Naur hugov3.1.03/source/hcheader.h /usr/glenda/cursesif/hugo/source/hcheader.h
--- hugov3.1.03/source/hcheader.h	Fri Oct  9 18:12:02 2015
+++ /usr/glenda/cursesif/hugo/source/hcheader.h	Thu Oct  1 02:31:39 2015
@@ -16,6 +16,7 @@
 #define HCINTERIM ".03 (2.5)"
 #endif
 
+#define	toascii(c)	((c)&0177)
 
 #include <ctype.h>
 #include <stdlib.h>
@@ -55,6 +56,8 @@
    (although this is typically done in the makefile)
 */
 
+#define GCC_UNIX
+
 /*---------------------------------------------------------------------------
 	Definitions for the Acorn Archimedes & RPC
 	using Acorn C Compiler (v4)
@@ -354,7 +357,7 @@
 #define MAXADDRBLOCKS 65536*2/ADDRBLOCKSIZE
 #define MAXPROPBLOCKS 65536*2/PROPBLOCKSIZE
 
-/* Maximums for reading lines from a sourcefile */
+/* Maximums for reading hugolines from a sourcefile */
 #define MAXWORDS         255
 #define MAXBUFFER       1024
 
@@ -611,16 +614,16 @@
 extern int argc;
 extern char **argv, **envp;
 extern char errfile[];
-extern unsigned int errline;
+extern unsigned int errhugoline;
 extern int words;
 extern char *word[];
-extern char line[];
+extern char hugoline[];
 extern char full_buffer;
 extern char listing, objecttree, fullobj, printer, statistics, printdebug,
 	override, aborterror, memmap, hlb, builddebug, expandederr,
 	spellcheck, writeanyway;
 extern char compile_v25;
-extern int percent, totallines, tlines;
+extern int percent, totalhugolines, thugolines;
 extern int er;
 extern int warn;
 extern char **sets;
diff -Naur hugov3.1.03/source/hclink.c /usr/glenda/cursesif/hugo/source/hclink.c
--- hugov3.1.03/source/hclink.c	Fri Oct  9 18:12:02 2015
+++ /usr/glenda/cursesif/hugo/source/hclink.c	Thu Oct  1 02:31:39 2015
@@ -66,8 +66,8 @@
 	if (ReadCode(1)!=HCVERSION*10+HCREVISION || ReadCode(1)!='$' || ReadCode(1)!='$')
 		{fclose(linkfile);
 		aborterror = true;
-		sprintf(line, "Invalid precompiled header version:  %s", linkfilename);
-		Error(line);
+		sprintf(hugoline, "Invalid precompiled header version:  %s", linkfilename);
+		Error(hugoline);
 		return;}
 
 	pcount = (unsigned int)ReadCode(2);           /* # of obj. properties */
@@ -98,8 +98,8 @@
 	{
 		len = (unsigned int)ReadCode(1)+1;
 		if (len>MAX_SYMBOL_LENGTH) FatalError(READ_E, linkfilename);
-		if (!fgets(line, len, linkfile)) FatalError(READ_E, linkfilename);
-		object[i] = MakeString(line);
+		if (!fgets(hugoline, len, linkfile)) FatalError(READ_E, linkfilename);
+		object[i] = MakeString(hugoline);
 		object_hash[i] = FindHash(object[i]);
 		oprop[i] = (unsigned int)ReadCode(2);
 		for (j=0; j<MAXATTRIBUTES/32; j++)
@@ -124,8 +124,8 @@
 		{
 			len = (unsigned int)ReadCode(1)+1;
 			if (len>MAX_SYMBOL_LENGTH) FatalError(READ_E, linkfilename);
-			if (!fgets(line, len, linkfile)) FatalError(READ_E, linkfilename);
-	                property[i] = MakeString(line);
+			if (!fgets(hugoline, len, linkfile)) FatalError(READ_E, linkfilename);
+	                property[i] = MakeString(hugoline);
 		}
 		property_hash[i] = FindHash(property[i]);
 		propdef[i] = (unsigned int)ReadCode(2);
@@ -157,8 +157,8 @@
 	{
 		len = (unsigned int)ReadCode(1)+1;
 		if (len>MAX_SYMBOL_LENGTH) FatalError(READ_E, linkfilename);
-		if (!fgets(line, len, linkfile)) FatalError(READ_E, linkfilename);
-		attribute[i] = MakeString(line);
+		if (!fgets(hugoline, len, linkfile)) FatalError(READ_E, linkfilename);
+		attribute[i] = MakeString(hugoline);
 		attribute_hash[i] = FindHash(attribute[i]);
 	}
 
@@ -168,8 +168,8 @@
 	{
 		len = (unsigned int)ReadCode(1)+1;
 		if (len>MAX_SYMBOL_LENGTH) FatalError(READ_E, linkfilename);
-		if (!fgets(line, len, linkfile)) FatalError(READ_E, linkfilename);
-		alias[i] = MakeString(line);
+		if (!fgets(hugoline, len, linkfile)) FatalError(READ_E, linkfilename);
+		alias[i] = MakeString(hugoline);
 		alias_hash[i] = FindHash(alias[i]);
 		aliasof[i] = (unsigned int)ReadCode(2);
 	}
@@ -180,8 +180,8 @@
 	{
 		len = (unsigned int)ReadCode(1)+1;
 		if (len>MAX_SYMBOL_LENGTH) FatalError(READ_E, linkfilename);
-		if (!fgets(line, len, linkfile)) FatalError(READ_E, linkfilename);
-		if (i>=ENGINE_GLOBALS) global[i] = MakeString(line);
+		if (!fgets(hugoline, len, linkfile)) FatalError(READ_E, linkfilename);
+		if (i>=ENGINE_GLOBALS) global[i] = MakeString(hugoline);
 		global_hash[i] = FindHash(global[i]);
 		globaldef[i] = (unsigned int)ReadCode(2);
 	}
@@ -192,8 +192,8 @@
 	{
 		len = (unsigned int)ReadCode(1)+1;
 		if (len>MAX_SYMBOL_LENGTH) FatalError(READ_E, linkfilename);
-		if (!fgets(line, len, linkfile)) FatalError(READ_E, linkfilename);
-		constant[i] = MakeString(line);
+		if (!fgets(hugoline, len, linkfile)) FatalError(READ_E, linkfilename);
+		constant[i] = MakeString(hugoline);
 		constant_hash[i] = FindHash(constant[i]);
 		constantval[i] = (unsigned int)ReadCode(2);
 	}
@@ -204,8 +204,8 @@
 	{
 		len = (unsigned int)ReadCode(1)+1;
 		if (len>MAX_SYMBOL_LENGTH) FatalError(READ_E, linkfilename);
-		if (!fgets(line, len, linkfile)) FatalError(READ_E, linkfilename);
-		routine[i] = MakeString(line);
+		if (!fgets(hugoline, len, linkfile)) FatalError(READ_E, linkfilename);
+		routine[i] = MakeString(hugoline);
 		routine_hash[i] = FindHash(routine[i]);
 		raddr[i] = (unsigned int)ReadCode(2);
 		rreplace[i] = 0;
@@ -221,8 +221,8 @@
 	{
 		len = (unsigned int)ReadCode(1)+1;
 		if (len>MAX_SYMBOL_LENGTH) FatalError(READ_E, linkfilename);
-		if (!fgets(line, len, linkfile)) FatalError(READ_E, linkfilename);
-		array[i] = MakeString(line);
+		if (!fgets(hugoline, len, linkfile)) FatalError(READ_E, linkfilename);
+		array[i] = MakeString(hugoline);
 		array_hash[i] = FindHash(array[i]);
 		arrayaddr[i] = (unsigned int)ReadCode(2);
 		arraylen[i] = (unsigned int)ReadCode(2);
@@ -255,9 +255,9 @@
 	{
 		len = (unsigned int)ReadCode(1);
 		for (j=1; j<=(unsigned int)len; j++)
-			line[j-1] = (char)(ReadCode(1)-CHAR_TRANSLATION);
-		line[j-1] = '\0';
-		AddDictionary(line);
+			hugoline[j-1] = (char)(ReadCode(1)-CHAR_TRANSLATION);
+		hugoline[j-1] = '\0';
+		AddDictionary(hugoline);
 	}
 
 	data = (unsigned int)ReadCode(2);
@@ -295,7 +295,7 @@
 {
 	if (a > b)
 	{
-		sprintf(line, "Compiler limit of %d %s exceeded in:  %s", b, n, linkfilename);
+		sprintf(hugoline, "Compiler limit of %d %s exceeded in:  %s", b, n, linkfilename);
 		FatalError(COMP_LINK_LIMIT_E, "");
 	}
 }
diff -Naur hugov3.1.03/source/hcmisc.c /usr/glenda/cursesif/hugo/source/hcmisc.c
--- hugov3.1.03/source/hcmisc.c	Fri Oct  9 18:12:02 2015
+++ /usr/glenda/cursesif/hugo/source/hcmisc.c	Thu Oct  1 02:31:39 2015
@@ -30,17 +30,17 @@
 void PrintErrorLocation(void);
 void PrintLimit(char *a, unsigned int n, int nl);
 
-int argc;                       /* parameters passed from command line */
+int argc;                       /* parameters passed from command hugoline */
 char **argv, **envp;
 
 char errfile[MAXPATH];          /* for locating errors in Pass2    */
-unsigned int errline;
-int words;			/* number of words in input line   */
+unsigned int errhugoline;
+int words;			/* number of words in input hugoline   */
 char *word[MAXWORDS+1];         /* the words themselves            */
-char line[MAXBUFFER+1];            /* output line                     */
+char hugoline[MAXBUFFER+1];            /* output hugoline                     */
 char full_buffer;		/* true if word[] isn't empty	   */
 
-/* Command line switch flags: */
+/* Command hugoline switch flags: */
 char    listing = 0,                    /* output to .LST file          */
 	objecttree = 0,                 /* print object tree when done  */
 	fullobj = 0,                    /* output full object summaries */
@@ -61,7 +61,7 @@
 	char compile_v25 = 1;
 #endif
 
-int percent = 0, totallines = 0, tlines = 0;  /* percentage completion */
+int percent = 0, totalhugolines = 0, thugolines = 0;  /* percentage completion */
 
 int er = 0;                     /* error counter */
 int warn = 0;                   /* warning counter */
@@ -144,8 +144,8 @@
 	/* No match, or no entries with letter */
 
 	if (dictcount >= MAXDICT)
-		{sprintf(line, "Maximum number of %d dictionary entries exceeded", MAXDICT);
-		Error(line);
+		{sprintf(hugoline, "Maximum number of %d dictionary entries exceeded", MAXDICT);
+		Error(hugoline);
 		return 0;}
 
 	if ((lexentry[dictcount] = malloc((strlen(a)+1)*sizeof(char)))==NULL)
@@ -169,7 +169,7 @@
 
 	Registers the directory <path> as a searchable location for
 	files of type HUGO_<directory type>.  Directories are passed
-	without the leading '@' in the command line or source.
+	without the leading '@' in the command hugoline or source.
 */
 
 void AddDirectory(char *d)
@@ -193,8 +193,8 @@
 
 	if (directoryctr==MAXDIRECTORIES)
 	{
-		sprintf(line, "Maximum of %d directory settings exceeded", MAXDIRECTORIES);
-		Error(line);
+		sprintf(hugoline, "Maximum of %d directory settings exceeded", MAXDIRECTORIES);
+		Error(hugoline);
 		return;
 	}
 
@@ -262,14 +262,14 @@
 
 	if (nest)
 	{
-		strcpy(line, "");
+		strcpy(hugoline, "");
 		for (i=1; i<nest; i++)
-			strcat(line, ". . ");
-		strcat(line, "\\;");
-		Printout(line);
+			strcat(hugoline, ". . ");
+		strcat(hugoline, "\\;");
+		Printout(hugoline);
 	}
-	sprintf(line, "[%d] %s", obj, object[obj]);
-	Printout(line);
+	sprintf(hugoline, "[%d] %s", obj, object[obj]);
+	Printout(hugoline);
 
 	for (i=0; i<objects; i++)
 	{
@@ -297,7 +297,7 @@
 
 /* ERROR
 
-	For non-fatal errors.  Prints the offending line of (reconstructed)
+	For non-fatal errors.  Prints the offending hugoline of (reconstructed)
 	code followed by the error message.  Warnings begin with a '?'.
 */
 
@@ -308,14 +308,14 @@
 
 	if (percent && passnumber==1)
 	{
-		printf("\rCompiling %5d lines of %s", totallines, PRINTED_FILENAME(sourcefilename));
+		printf("\rCompiling %5d hugolines of %s", totalhugolines, PRINTED_FILENAME(sourcefilename));
 		if (listing)
-			if (fprintf(listfile, "Compiling %5d lines of %s\n", totallines, PRINTED_FILENAME(sourcefilename)) < 0)
+			if (fprintf(listfile, "Compiling %5d hugolines of %s\n", totalhugolines, PRINTED_FILENAME(sourcefilename)) < 0)
 				FatalError(WRITE_E, listfilename);
 
 #ifdef STDPRN_SUPPORTED
 		if (printer)
-			if (fprintf(stdprn, "Compiling %5d lines of %s\n\r", totallines, PRINTED_FILENAME(sourcefilename)) < 0)
+			if (fprintf(stdprn, "Compiling %5d hugolines of %s\n\r", totalhugolines, PRINTED_FILENAME(sourcefilename)) < 0)
 				FatalError(WRITE_E, "printer");
 #endif
 	}
@@ -353,7 +353,7 @@
 	}
 	Printout(errbuf);
 
-	/* Don't continue with the line-count/percentage-completion after
+	/* Don't continue with the hugoline-count/percentage-completion after
 	   an error--it gets messy.
 	*/
 	percent = false;
@@ -379,13 +379,13 @@
 
 	if (percent && passnumber==1)
 	{
-		printf("\rCompiling %5d lines of %s", totallines, PRINTED_FILENAME(sourcefilename));
+		printf("\rCompiling %5d hugolines of %s", totalhugolines, PRINTED_FILENAME(sourcefilename));
 		if (listing==true)
-			fprintf(listfile, "Compiling %5d lines of %s\n", totallines, PRINTED_FILENAME(sourcefilename));
+			fprintf(listfile, "Compiling %5d hugolines of %s\n", totalhugolines, PRINTED_FILENAME(sourcefilename));
 
 #if defined (STDPRN_SUPPORTED)
 		if (printer)
-			fprintf(stdprn, "Compiling %5d lines of %s\n\r", totallines, PRINTED_FILENAME(sourcefilename));
+			fprintf(stdprn, "Compiling %5d hugolines of %s\n\r", totalhugolines, PRINTED_FILENAME(sourcefilename));
 #endif
 	}
 
@@ -415,42 +415,42 @@
 			break;}
 
 		case OPEN_E:
-			{sprintf(line, "Unable to open %s", PRINTED_FILENAME(a));
-			Printout(line);
+			{sprintf(hugoline, "Unable to open %s", PRINTED_FILENAME(a));
+			Printout(hugoline);
 			break;}
 
 		case READ_E:
-			{sprintf(line, "Cannot read from %s", PRINTED_FILENAME(a));
-			Printout(line);
+			{sprintf(hugoline, "Cannot read from %s", PRINTED_FILENAME(a));
+			Printout(hugoline);
 			break;}
 
 		case WRITE_E:
-			{sprintf(line, "Cannot write to %s", PRINTED_FILENAME(a));
-			Printout(line);
+			{sprintf(hugoline, "Cannot write to %s", PRINTED_FILENAME(a));
+			Printout(hugoline);
 			break;}
 
 		case OVERFLOW_E:
-			{sprintf(line, "Line overflow in %s", PRINTED_FILENAME(a));
-			Printout(line);
+			{sprintf(hugoline, "Line overflow in %s", PRINTED_FILENAME(a));
+			Printout(hugoline);
 			break;}
 
 		case EOF_COMMENT_E:
-			{sprintf(line, "Unexpected end-of-file in comment in %s", PRINTED_FILENAME(a));
-			Printout(line);
+			{sprintf(hugoline, "Unexpected end-of-file in comment in %s", PRINTED_FILENAME(a));
+			Printout(hugoline);
 			break;}
 
 		case EOF_TEXT_E:
-			{sprintf(line, "Unexpected end-of-file in text in %s", PRINTED_FILENAME(a));
-			Printout(line);
+			{sprintf(hugoline, "Unexpected end-of-file in text in %s", PRINTED_FILENAME(a));
+			Printout(hugoline);
 			break;}
 			
 		case EOF_ENDIF_E:
-			{sprintf(line, "Unexpected end-of-file before #endif in %s", PRINTED_FILENAME(a));
-			Printout(line);
+			{sprintf(hugoline, "Unexpected end-of-file before #endif in %s", PRINTED_FILENAME(a));
+			Printout(hugoline);
 			break;}
 
 		case COMP_LINK_LIMIT_E:
-			{Printout(line);
+			{Printout(hugoline);
 			break;}
 	}
 	CleanUpFiles();
@@ -471,10 +471,10 @@
 
 	if (word[a][0]!=t[0])
 	{
-		sprintf(line, "Expecting %s", d);
+		sprintf(hugoline, "Expecting %s", d);
 		if (t[0]!='\0')
-			sprintf(line+strlen(line), ":  '%s'", t);
-		Error(line);
+			sprintf(hugoline+strlen(hugoline), ":  '%s'", t);
+		Error(hugoline);
 		return false;
 	}
 	return true;
@@ -571,8 +571,8 @@
 
 	if (argc==1)
 	{
-		sprintf(line, "\nSYNTAX:   %s [options] sourcefile [objectfile[.HEX]]", argv[0]); //, PROGRAM_NAME);
-		Printout(line);
+		sprintf(hugoline, "\nSYNTAX:   %s [options] sourcefile [objectfile[.HEX]]", argv[0]); //, PROGRAM_NAME);
+		Printout(hugoline);
 		Printout("OPTIONS:  -<switches>  $<limit setting>  #<compiler flag>  @<directory>");
 		Printout("\nSWITCHES:");
 		Printout("  -a  Abort on first error                -d  build .HDX Debuggable executable");
@@ -715,36 +715,36 @@
 {
 	char errbuf[256];
 
-	/* errline is recorded in the allfile for reading during
+	/* errhugoline is recorded in the allfile for reading during
 	   Pass2...
 	*/
-	if (passnumber==2 && errline)
+	if (passnumber==2 && errhugoline)
 	{
 		if (expandederr)
 		{
-			sprintf(errbuf, "%s:  Line %u, in %s", PRINTED_FILENAME(errfile), errline, object_id);
+			sprintf(errbuf, "%s:  Line %u, in %s", PRINTED_FILENAME(errfile), errhugoline, object_id);
 			Printout(errbuf);
 		}
 		else
 		{
-			sprintf(errbuf, "%s:%u:  %s:  \\;", errfile, errline, object_id);
+			sprintf(errbuf, "%s:%u:  %s:  \\;", errfile, errhugoline, object_id);
 			Printout(errbuf);
 		}
 	}
 
-	/* ...before which, we can use totallines and the name of
+	/* ...before which, we can use totalhugolines and the name of
 	   the current source file.
 	*/
-	else if (passnumber==1 && totallines)
+	else if (passnumber==1 && totalhugolines)
 	{
 		if (expandederr)
 		{
-			sprintf(errbuf, "%s:  Line %u", PRINTED_FILENAME(sourcefilename), totallines);
+			sprintf(errbuf, "%s:  Line %u", PRINTED_FILENAME(sourcefilename), totalhugolines);
 			Printout(errbuf);
 		}
 		else
 		{
-			sprintf(errbuf, "%s:%u:  \\;", sourcefilename, totallines);
+			sprintf(errbuf, "%s:%u:  \\;", sourcefilename, totalhugolines);
 			Printout(errbuf);
 		}
 	}
@@ -800,16 +800,16 @@
 
 void PrintLimit(char *a, unsigned int n, int nl)
 {
-	if (n) sprintf(line, "\t%-15s %5u\\;", a, n);
-	else sprintf(line, "\t%-15s   (0)\\;", a);
-	Printout(line);
+	if (n) sprintf(hugoline, "\t%-15s %5u\\;", a, n);
+	else sprintf(hugoline, "\t%-15s   (0)\\;", a);
+	Printout(hugoline);
 	if (!nl) Printout("");
 }
 
 
 /* PRINTLINE
 
-	Prints a line of <n> repetitions of character <a>.
+	Prints a hugoline of <n> repetitions of character <a>.
 */
 
 void PrintLine(int n, char a)
@@ -896,13 +896,13 @@
 		if (attrctr) Printout("\n  ATTRIBUTE NUMBERS:");
 
 		for (i=0; i<attrctr; i++)
-			{sprintf(line, "     $%2s (%2d):  %s", PrintHex((long)i, 1), i, attribute[i]);
-			Printout(line);}
+			{sprintf(hugoline, "     $%2s (%2d):  %s", PrintHex((long)i, 1), i, attribute[i]);
+			Printout(hugoline);}
 		for (i=0; i<aliasctr; i++)
 		{
 			if (aliasof[i] < MAXATTRIBUTES)
-				{sprintf(line, "\t\t%s ALIAS OF %s", alias[i], attribute[aliasof[i]]);
-				Printout(line);}
+				{sprintf(hugoline, "\t\t%s ALIAS OF %s", alias[i], attribute[aliasof[i]]);
+				Printout(hugoline);}
 		}
 
 		Printout("\n  PROPERTY NUMBERS:");
@@ -913,27 +913,27 @@
 			if (propadd[i]&COMPLEX_FLAG) strcat(atype, "$COMPLEX ");
 
 			if (propdef[i])
-				sprintf(line, "    $%2s (%3d):  %s %s (DEFAULT VALUE:  %d)", PrintHex((long)i, 1), i, property[i], atype, (short)propdef[i]);
+				sprintf(hugoline, "    $%2s (%3d):  %s %s (DEFAULT VALUE:  %d)", PrintHex((long)i, 1), i, property[i], atype, (short)propdef[i]);
 			else
-				sprintf(line, "    $%2s (%3d):  %s %s", PrintHex((long)i, 1), i, property[i], atype);
-			Printout(line);
+				sprintf(hugoline, "    $%2s (%3d):  %s %s", PrintHex((long)i, 1), i, property[i], atype);
+			Printout(hugoline);
 		}
 		for (i=0; i<aliasctr; i++)
 		{
 			if (aliasof[i]>=MAXATTRIBUTES)
-				{sprintf(line, "\t\t%s ALIAS OF %s", alias[i], property[aliasof[i]-MAXATTRIBUTES]);
-				Printout(line);}
+				{sprintf(hugoline, "\t\t%s ALIAS OF %s", alias[i], property[aliasof[i]-MAXATTRIBUTES]);
+				Printout(hugoline);}
 		}
 
 		Printout("\n  GLOBAL VARIABLE NUMBERS:");
 		for (i=0; i<globalctr; i++)
-			{sprintf(line, "    $%2s (%3d):  %s", PrintHex((long)i, 1), i, global[i]);
-			Printout(line);}
+			{sprintf(hugoline, "    $%2s (%3d):  %s", PrintHex((long)i, 1), i, global[i]);
+			Printout(hugoline);}
 
 		if (arrayctr) Printout("\n  ARRAY ADDRESSES:");
 		for (i=0; i<arrayctr; i++)
-			{sprintf(line, "    $%4s:  %s", PrintHex((long)arrayaddr[i], 2), array[i]);
-			Printout(line);}
+			{sprintf(hugoline, "    $%4s:  %s", PrintHex((long)arrayaddr[i], 2), array[i]);
+			Printout(hugoline);}
 
 		Printout("\n  PROPERTY ROUTINE ADDRESSES:");
 		obj = 0;
@@ -961,9 +961,9 @@
 					n = propdata[a/PROPBLOCKSIZE][a%PROPBLOCKSIZE];
 					a++;
 					if (dflag==1)
-						{sprintf(line, "    $%6s:  %s.%s",
+						{sprintf(hugoline, "    $%6s:  %s.%s",
 							PrintHex((long)n*address_scale, 3), object[obj], property[p]);
-						Printout(line);
+						Printout(hugoline);
 						dflag = 0;}
 				}
 			}
@@ -972,17 +972,17 @@
 
 		Printout("\n  ROUTINE ADDRESSES:");
 		for (i=0; i<routines; i++)
-			{sprintf(line, "    $%6s:  %s", PrintHex((long)raddr[i]*address_scale, 3), routine[i]);
-			Printout(line);}
+			{sprintf(hugoline, "    $%6s:  %s", PrintHex((long)raddr[i]*address_scale, 3), routine[i]);
+			Printout(hugoline);}
 
 		if (events) Printout("\n  EVENT ADDRESSES:");
 		for (i=0; i<events; i++)
 		{
-			sprintf(line, "    $%6s:  \\;", PrintHex((long)eventaddr[i]*address_scale, 3));
-			Printout(line);
+			sprintf(hugoline, "    $%6s:  \\;", PrintHex((long)eventaddr[i]*address_scale, 3));
+			Printout(hugoline);
 			if (eventin[i])
-				{sprintf(line, "Event in:  %s", object[eventin[i]]);
-				Printout(line);}
+				{sprintf(hugoline, "Event in:  %s", object[eventin[i]]);
+				Printout(hugoline);}
 			else Printout("Global event");
 		}
 	}
@@ -992,54 +992,54 @@
 	{
 		Printout("");
 		PrintLine(79, '=');
-		sprintf(line, "HUGO COMPILER v%d.%d%s STATISTICS FOR:  %s",
+		sprintf(hugoline, "HUGO COMPILER v%d.%d%s STATISTICS FOR:  %s",
 			HCVERSION, HCREVISION, HCINTERIM, PRINTED_FILENAME(sourcefilename));
-		Printout(line);
-		strftime(line, 32, "%m/%d/%y %H:%M:%S", localtime(&tick2));
-		Printout(line);
+		Printout(hugoline);
+		strftime(hugoline, 32, "%m/%d/%y %H:%M:%S", localtime(&tick2));
+		Printout(hugoline);
 		PrintLine(79, '=');
 
-		sprintf(line, "Compiled %d lines in %d file(s)", tlines, totalfiles);
-		Printout(line);
-		sprintf(line, "\nObjects:    %5d (maximum %5d)      Routines: %5d (maximum %5d)", objectctr, MAXOBJECTS, routinectr, MAXROUTINES);
-		Printout(line);
-		sprintf(line, "Attributes: %5d (maximum %5d)      Events:   %5d (maximum %5d)", attrctr, MAXATTRIBUTES, eventctr, MAXEVENTS);
-		Printout(line);
-		sprintf(line, "Properties: %5d (maximum %5d)      Labels:   %5d (maximum %5d)", propctr, MAXPROPERTIES, labelctr, MAXLABELS);
-		Printout(line);
-		sprintf(line, "Aliases:    %5d (maximum %5d)      Globals:  %5d (maximum %5d)", aliasctr, MAXALIASES, globalctr, MAXGLOBALS);
-		Printout(line);
-		sprintf(line, "Constants:  %5d (maximum %5d)      Arrays:   %5d (maximum %5d)", constctr, MAXCONSTANTS, arrayctr, MAXARRAYS);
-		Printout(line);
+		sprintf(hugoline, "Compiled %d hugolines in %d file(s)", thugolines, totalfiles);
+		Printout(hugoline);
+		sprintf(hugoline, "\nObjects:    %5d (maximum %5d)      Routines: %5d (maximum %5d)", objectctr, MAXOBJECTS, routinectr, MAXROUTINES);
+		Printout(hugoline);
+		sprintf(hugoline, "Attributes: %5d (maximum %5d)      Events:   %5d (maximum %5d)", attrctr, MAXATTRIBUTES, eventctr, MAXEVENTS);
+		Printout(hugoline);
+		sprintf(hugoline, "Properties: %5d (maximum %5d)      Labels:   %5d (maximum %5d)", propctr, MAXPROPERTIES, labelctr, MAXLABELS);
+		Printout(hugoline);
+		sprintf(hugoline, "Aliases:    %5d (maximum %5d)      Globals:  %5d (maximum %5d)", aliasctr, MAXALIASES, globalctr, MAXGLOBALS);
+		Printout(hugoline);
+		sprintf(hugoline, "Constants:  %5d (maximum %5d)      Arrays:   %5d (maximum %5d)", constctr, MAXCONSTANTS, arrayctr, MAXARRAYS);
+		Printout(hugoline);
 
-		sprintf(line, "\nWords in dictionary: %5d    Special words: %5d    Verbs: %5d", dictcount, syncount, verbs);
-		Printout(line);
+		sprintf(hugoline, "\nWords in dictionary: %5d    Special words: %5d    Verbs: %5d", dictcount, syncount, verbs);
+		Printout(hugoline);
 
-		sprintf(line, "\nObject file:  %s (%ld bytes)", PRINTED_FILENAME(objectfilename), codeptr);
-		Printout(line);
+		sprintf(hugoline, "\nObject file:  %s (%ld bytes)", PRINTED_FILENAME(objectfilename), codeptr);
+		Printout(hugoline);
 
 		if (hlb || builddebug)
 		{
-			strcpy(line, "(");
-			if (hlb) strcat(line, "precompiled ");
-			if (builddebug) strcat(line, "debuggable ");
-			strcat(line, "format)");
-			Printout(line);
+			strcpy(hugoline, "(");
+			if (hlb) strcat(hugoline, "precompiled ");
+			if (builddebug) strcat(hugoline, "debuggable ");
+			strcat(hugoline, "format)");
+			Printout(hugoline);
 		}
 
 		if (listing)
-			{sprintf(line, "List file:    %s", PRINTED_FILENAME(listfilename));
-			Printout(line);}
+			{sprintf(hugoline, "List file:    %s", PRINTED_FILENAME(listfilename));
+			Printout(hugoline);}
 
-		sprintf(line, "\nElapsed compile time:  %u seconds", (unsigned int)tick);
-		Printout(line);
+		sprintf(hugoline, "\nElapsed compile time:  %u seconds", (unsigned int)tick);
+		Printout(hugoline);
 
 		if (er || warn)
 		{
-			strcpy(line, "\n");
-			if (er) sprintf(line+1, "ERRORS:  %d    ", er);
-			if (warn) sprintf(line+strlen(line), "WARNINGS:  %d", warn);
-			Printout(line);
+			strcpy(hugoline, "\n");
+			if (er) sprintf(hugoline+1, "ERRORS:  %d    ", er);
+			if (warn) sprintf(hugoline+strlen(hugoline), "WARNINGS:  %d", warn);
+			Printout(hugoline);
 		}
 
 		PrintLine(79, '=');
@@ -1072,8 +1072,8 @@
 		}
 		if (fputs(":!\n", allfile)==EOF) FatalError(WRITE_E, allfilename);
 
-		/* then print line number for later error trapping */
-		WriteWord(totallines, allfile);
+		/* then print hugoline number for later error trapping */
+		WriteWord(totalhugolines, allfile);
 	}
 }
 
@@ -1452,8 +1452,8 @@
 			if ((unsigned char)b < 32)
 #endif
 			{
-				sprintf(line, "?Non-ASCII character value:  %d", (unsigned char)b);
-				Error(line);
+				sprintf(hugoline, "?Non-ASCII character value:  %d", (unsigned char)b);
+				Error(hugoline);
 			}
 			buffer[bloc] = b;
 			buffer[++bloc] = '\0';
@@ -1505,10 +1505,10 @@
 	}
 	word[words+1] = "";
 /*
-strcpy(line, "");
+strcpy(hugoline, "");
 for (i=1; i<=words; i++)
-	sprintf(line+strlen(line), "\"%s\" ", word[i]);
-Printout(line);
+	sprintf(hugoline+strlen(hugoline), "\"%s\" ", word[i]);
+Printout(hugoline);
 */
 }
 
@@ -1539,8 +1539,8 @@
 			j = atoi(a+i+1);
 			if ((j==0) && (a[i+1]!='0'))
 			{
-				sprintf(line, "Invalid limit setting:  $%s=%s", a, a+i+1);
-				Error(line);
+				sprintf(hugoline, "Invalid limit setting:  $%s=%s", a, a+i+1);
+				Error(hugoline);
 				return;
 			}
 
@@ -1584,23 +1584,23 @@
 
 			if (flag==0)
 			{
-				sprintf(line, "No such limit:  %s", a);
-				Error(line);
+				sprintf(hugoline, "No such limit:  %s", a);
+				Error(hugoline);
 			}
 			if (flag==2)
 			{
-				sprintf(line, "Limit not modifiable:  %s", a);
-				Error(line);
+				sprintf(hugoline, "Limit not modifiable:  %s", a);
+				Error(hugoline);
 			}
 			if (flag==3)
 			{
-				sprintf(line, "Limit exceeds maximum of %u:  $%s=%s", limit, a, a+i+1);
-				Error(line);
+				sprintf(hugoline, "Limit exceeds maximum of %u:  $%s=%s", limit, a, a+i+1);
+				Error(hugoline);
 			}
 			if (flag==4)
 			{
-				sprintf(line, "Limit must be at least %u:  $%s=%s", limit, a, a+i+1);
-				Error(line);
+				sprintf(hugoline, "Limit must be at least %u:  $%s=%s", limit, a, a+i+1);
+				Error(hugoline);
 			}
 
 			return;
@@ -1866,8 +1866,8 @@
 
 		else
 		{
-			sprintf(line, "Invalid switch:  %c", b);
-			Error(line);
+			sprintf(hugoline, "Invalid switch:  %c", b);
+			Error(hugoline);
 		}
 	}
 
@@ -1883,7 +1883,7 @@
 		{a[strlen(a)-1] = '\0';
 		strcpy(a, a+1);}
 	else
-		{sprintf(line, "Missing quotes:  %s", a);
-		Error(line);}
+		{sprintf(hugoline, "Missing quotes:  %s", a);
+		Error(hugoline);}
 }
 
diff -Naur hugov3.1.03/source/hcpass.c /usr/glenda/cursesif/hugo/source/hcpass.c
--- hugov3.1.03/source/hcpass.c	Fri Oct  9 18:12:02 2015
+++ /usr/glenda/cursesif/hugo/source/hcpass.c	Thu Oct  1 02:31:39 2015
@@ -52,7 +52,7 @@
 	so that they are recognizable to the compiler during Pass2().
 	Here, everything contained in an object, routine, or event is
 	written into the temporary allfile, which is a contiguous master
-	file of parsed lines (i.e. broken down into tokens).
+	file of parsed hugolines (i.e. broken down into tokens).
 */
 
 void Pass1(void)
@@ -78,7 +78,7 @@
 		GetLine(0);
 
 		if (percent)
-			printf("\rCompiling %5d lines of %s", totallines, sourceupper);
+			printf("\rCompiling %5d hugolines of %s", totalhugolines, sourceupper);
 
 		if (words > 0)
 		{
@@ -108,8 +108,8 @@
 
 				if (objectctr==MAXOBJECTS)
 					{objectctr = MAXOBJECTS-1;
-					sprintf(line, "Maximum of %d objects exceeded", MAXOBJECTS);
-					Error(line);}
+					sprintf(hugoline, "Maximum of %d objects exceeded", MAXOBJECTS);
+					Error(hugoline);}
 
 				DefOther();
 			}
@@ -126,8 +126,8 @@
 
 				if (routinectr==MAXROUTINES)
 					{routinectr = MAXROUTINES-1;
-					sprintf(line, "Maximum of %d routines exceeded", MAXROUTINES);
-					Error(line);}
+					sprintf(hugoline, "Maximum of %d routines exceeded", MAXROUTINES);
+					Error(hugoline);}
 
 				DefOther();
 			}
@@ -146,13 +146,13 @@
 				{
 					if (token_val<objinitial)
 					{
-						sprintf(line, "?Precompiled references to old \"%s\" may be invalid", object[token_val]);
-						Error(line);
+						sprintf(hugoline, "?Precompiled references to old \"%s\" may be invalid", object[token_val]);
+						Error(hugoline);
 					}
 
-					sprintf(line, "<replaced \"%s\">", object[token_val]);
+					sprintf(hugoline, "<replaced \"%s\">", object[token_val]);
 					free(object[token_val]);
-					object[token_val] = MakeString(line);
+					object[token_val] = MakeString(hugoline);
 					object_hash[token_val] = 0;
 					oreplace[token_val]++;
 					word[1] = "object";
@@ -162,8 +162,8 @@
 				}
 				else
 				{
-					sprintf(line, "Not an object or routine:  %s", word[2]);
-					Error(line);
+					sprintf(hugoline, "Not an object or routine:  %s", word[2]);
+					Error(hugoline);
 				}
 			}
 
@@ -177,8 +177,8 @@
 
 				if (eventctr==MAXEVENTS)
 					{eventctr = MAXEVENTS-1;
-					sprintf(line, "Maximum of %d events exceeded", MAXEVENTS);
-					Error(line);}
+					sprintf(hugoline, "Maximum of %d events exceeded", MAXEVENTS);
+					Error(hugoline);}
 
 				DefOther();
 			}
@@ -234,8 +234,8 @@
 
 						if (objectctr==MAXOBJECTS)
 							{objectctr = MAXOBJECTS-1;
-							sprintf(line, "Maximum of %d objects exceeded", MAXOBJECTS);
-							Error(line);}
+							sprintf(hugoline, "Maximum of %d objects exceeded", MAXOBJECTS);
+							Error(hugoline);}
 
 						DefOther();
 						flag = 1;
@@ -244,8 +244,8 @@
 				}
 
 				if (!flag)
-					{sprintf(line, "Unknown compiler directive:  %s", word[1]);
-					Error(line);}
+					{sprintf(hugoline, "Unknown compiler directive:  %s", word[1]);
+					Error(hugoline);}
 			}
 		}
 	}
@@ -274,12 +274,12 @@
 	{
 		printf("\n");
 		if (listing)
-			if (fprintf(listfile, "Compiling %5d lines of %s\n", totallines, PRINTED_FILENAME(sourcefilename)) < 0)
+			if (fprintf(listfile, "Compiling %5d hugolines of %s\n", totalhugolines, PRINTED_FILENAME(sourcefilename)) < 0)
 				FatalError(WRITE_E, listfilename);
 
 #if defined (STDPRN_SUPPORTED)
 		if (printer)
-			if (fprintf(stdprn, "Compiling %5d lines of %s\n\r", totallines, PRINTED_FILENAME(sourcefilename)) < 0)
+			if (fprintf(stdprn, "Compiling %5d hugolines of %s\n\r", totalhugolines, PRINTED_FILENAME(sourcefilename)) < 0)
 				FatalError(WRITE_E, "printer");
 #endif
 	}
@@ -393,8 +393,8 @@
 				}
 				else
 				{
-					sprintf(line, "Syntax error:  %s", word[2]);
-					Error(line);
+					sprintf(hugoline, "Syntax error:  %s", word[2]);
+					Error(hugoline);
 				}
 			}
 
@@ -428,8 +428,8 @@
 							if (!oreplace[objectctr])
 							{
 								sprintf(object_id, "object %s", object[objectctr]);
-								sprintf(line, "?Cannot inherit from unbuilt \"%s\"", object[i]);
-								Error(line);
+								sprintf(hugoline, "?Cannot inherit from unbuilt \"%s\"", object[i]);
+								Error(hugoline);
 							}
 							i = 0;
 						}
@@ -448,8 +448,8 @@
 				{
 					if (word[1][0]=='\0') break;
 
-					sprintf(line, "Unknown build directive:  %s", word[1]);
-					Error(line);
+					sprintf(hugoline, "Unknown build directive:  %s", word[1]);
+					Error(hugoline);
 				}
 			}
 		}
@@ -502,8 +502,8 @@
 	if (mainaddr==0 && !hlb) Error("No \"main\" routine");
 
 	if (codeptr >= 65536L*address_scale)
-		{sprintf(line, "Grammar and executable code exceed %dK", 64*address_scale);
-		Error(line);}
+		{sprintf(hugoline, "Grammar and executable code exceed %dK", 64*address_scale);
+		Error(hugoline);}
 
 
 	/*
@@ -524,15 +524,15 @@
 #if defined (DEBUG_FULLOBJ)
 		if (fullobj)
 		{
-			sprintf(line, "\nOBJECT %d:  %s", i, object[i]);
-			Printout(line);
+			sprintf(hugoline, "\nOBJECT %d:  %s", i, object[i]);
+			Printout(hugoline);
 
-			sprintf(line, "Parent:  %s    Sibling:  %s    Child:  %s",
+			sprintf(hugoline, "Parent:  %s    Sibling:  %s    Child:  %s",
 					object[parent[i]], object[sibling[i]], object[child[i]]);
-                        Printout(line);
+                        Printout(hugoline);
 
-			sprintf(line, "Property table address:  %s", PrintHex((unsigned)objpropaddr[i], 2));
-			Printout(line);
+			sprintf(hugoline, "Property table address:  %s", PrintHex((unsigned)objpropaddr[i], 2));
+			Printout(hugoline);
 
 			/* Property number */
 			p = propdata[a/PROPBLOCKSIZE][a%PROPBLOCKSIZE];
@@ -566,8 +566,8 @@
 
 					d = propdata[a/PROPBLOCKSIZE][a%PROPBLOCKSIZE];
 					a++;
-					sprintf(line, "Routine address:  %6s", PrintHex((long)(d+j)*address_scale, 3));
-					strcat(buffer, line);
+					sprintf(hugoline, "Routine address:  %6s", PrintHex((long)(d+j)*address_scale, 3));
+					strcat(buffer, hugoline);
 				}
 				else
 				{
@@ -575,9 +575,9 @@
 					/* Get property data */
 					for (k=1; k<=d; k++)
 					{
-						sprintf(line, "%s ", PrintHex(propdata[a/PROPBLOCKSIZE][a%PROPBLOCKSIZE], 2));
+						sprintf(hugoline, "%s ", PrintHex(propdata[a/PROPBLOCKSIZE][a%PROPBLOCKSIZE], 2));
 						a++;
-						strcat(buffer, line);
+						strcat(buffer, hugoline);
 					}
 				}
 				Printout(buffer);
@@ -590,8 +590,8 @@
 			{
 				if (objattr[j/32][i] & 1L<<(j%32))
 				{
-					sprintf(line, "\tAttribute:  %s", attribute[j]);
-					Printout(line);
+					sprintf(hugoline, "\tAttribute:  %s", attribute[j]);
+					Printout(hugoline);
 				}
 			}
 		}
@@ -955,53 +955,53 @@
 
 	if (memmap)
 	{
-		sprintf(line, "\nMEMORY USAGE FOR:  %s", PRINTED_FILENAME(objectfilename));
-		Printout(line);
-		sprintf(line, "\n          (Top:  $%6s)", PrintHex(codeptr, 3));
-		Printout(line);
+		sprintf(hugoline, "\nMEMORY USAGE FOR:  %s", PRINTED_FILENAME(objectfilename));
+		Printout(hugoline);
+		sprintf(hugoline, "\n          (Top:  $%6s)", PrintHex(codeptr, 3));
+		Printout(hugoline);
                 PrintFrameLine();
 
 		if (hlb)
 			Printout("| Link tables and |               |");
 
-		sprintf(line, "| Text bank       | $%6s bytes |", PrintHex(codeptr-textbankaddr*16L, 3));
-		Printout(line);
+		sprintf(hugoline, "| Text bank       | $%6s bytes |", PrintHex(codeptr-textbankaddr*16L, 3));
+		Printout(hugoline);
                 PrintFrameLine();
-	   	sprintf(line, "| Dictionary      |   $%4s bytes |",
+	   	sprintf(hugoline, "| Dictionary      |   $%4s bytes |",
 			PrintHex(textbankaddr*16L-dictaddr*16L, 2));
-		Printout(line);
+		Printout(hugoline);
                 PrintFrameLine();
-	   	sprintf(line, "| Special words   |   $%4s bytes |",
+	   	sprintf(hugoline, "| Special words   |   $%4s bytes |",
 			PrintHex(dictaddr*16L-synaddr*16L, 2));
-		Printout(line);
+		Printout(hugoline);
                 PrintFrameLine();
-	   	sprintf(line, "| Array space     |   $%4s bytes |",
+	   	sprintf(hugoline, "| Array space     |   $%4s bytes |",
 			PrintHex(synaddr*16L-arraytableaddr*16L, 2));
-		Printout(line);
+		Printout(hugoline);
                 PrintFrameLine();
-	   	sprintf(line, "| Event table     |   $%4s bytes |",
+	   	sprintf(hugoline, "| Event table     |   $%4s bytes |",
 			PrintHex(arraytableaddr*16L-eventtableaddr*16L, 2));
-		Printout(line);
+		Printout(hugoline);
                 PrintFrameLine();
-	   	sprintf(line, "| Property table  |   $%4s bytes |",
+	   	sprintf(hugoline, "| Property table  |   $%4s bytes |",
 			PrintHex(eventtableaddr*16L-proptableaddr*16L, 2));
-		Printout(line);
+		Printout(hugoline);
                 PrintFrameLine();
-	   	sprintf(line, "| Object table    |   $%4s bytes |",
+	   	sprintf(hugoline, "| Object table    |   $%4s bytes |",
 			PrintHex(proptableaddr*16L-objtableaddr*16L, 2));
-		Printout(line);
+		Printout(hugoline);
                 PrintFrameLine();
-	   	sprintf(line, "| Executable code | $%6s bytes |",
+	   	sprintf(hugoline, "| Executable code | $%6s bytes |",
 			PrintHex(objtableaddr*16L-codestart, 3));
-		Printout(line);
+		Printout(hugoline);
                 PrintFrameLine();
-	   	sprintf(line, "| Grammar table   |   $%4s bytes |",
+	   	sprintf(hugoline, "| Grammar table   |   $%4s bytes |",
 			PrintHex(codestart-HEADER_LENGTH, 2));
-		Printout(line);
+		Printout(hugoline);
                 PrintFrameLine();
-		sprintf(line, "| Header          |   $%4s bytes |",
+		sprintf(hugoline, "| Header          |   $%4s bytes |",
 			PrintHex(HEADER_LENGTH, 2));
-		Printout(line);
+		Printout(hugoline);
                 PrintFrameLine();
 		Printout("        (Bottom:  $000000)");
 	}
diff -Naur hugov3.1.03/source/hcres.c /usr/glenda/cursesif/hugo/source/hcres.c
--- hugov3.1.03/source/hcres.c	Fri Oct  9 18:12:02 2015
+++ /usr/glenda/cursesif/hugo/source/hcres.c	Thu Oct  1 02:31:39 2015
@@ -142,8 +142,8 @@
 		{
 			if (rescount==MAX_RESOURCES_PER_FILE)
 			{
-				sprintf(line, "Maximum of %d resources per resource file exceeded", MAX_RESOURCES_PER_FILE);
-				Error(line);
+				sprintf(hugoline, "Maximum of %d resources per resource file exceeded", MAX_RESOURCES_PER_FILE);
+				Error(hugoline);
 				break;
 			}
 	
@@ -166,8 +166,8 @@
 	
 			if (resource==NULL)
 			{
-				sprintf(line, "Unable to find resource \"%s\"", word[j]);
-				Error(line);
+				sprintf(hugoline, "Unable to find resource \"%s\"", word[j]);
+				Error(hugoline);
 	
 				/* At any point if there's an error initially finding
 				   or reading the resource, remove it from the list
@@ -201,8 +201,8 @@
 			{
 				if (!strcmp(resourcename[i], filename))
 				{
-					sprintf(line, "Duplicate resource name \"%s\" in \"%s\"", filename, resfilename);
-					Error(line);
+					sprintf(hugoline, "Duplicate resource name \"%s\" in \"%s\"", filename, resfilename);
+					Error(hugoline);
 				}
 			}
 	
diff -Naur hugov3.1.03/source/hcreset.c /usr/glenda/cursesif/hugo/source/hcreset.c
--- hugov3.1.03/source/hcreset.c	Fri Oct  9 18:12:02 2015
+++ /usr/glenda/cursesif/hugo/source/hcreset.c	Thu Oct  1 02:31:39 2015
@@ -228,7 +228,7 @@
 	compile_v25 = 1;
 	#endif
 	
-	percent = 0, totallines = 0, tlines = 0;
+	percent = 0, totalhugolines = 0, thugolines = 0;
 	er = 0;
 	warn = 0;
 	
diff -Naur hugov3.1.03/source/hd.c /usr/glenda/cursesif/hugo/source/hd.c
--- hugov3.1.03/source/hd.c	Fri Oct  9 18:12:02 2015
+++ /usr/glenda/cursesif/hugo/source/hd.c	Thu Oct  1 02:31:39 2015
@@ -18,6 +18,8 @@
 
 #include "heheader.h"
 #include "hdheader.h"
+#include "hdinter.h"
+
 
 
 /* Function prototypes: */
@@ -56,7 +58,7 @@
 char debugger_run = 0;                  /* true when running freely     */
 char debugger_interrupt = 0;		/* true if stepping 		*/
 char debugger_collapsing;		/* true if collapsing calls	*/
-char during_input;			/* true in hugo_getline() 	*/
+char during_input;			/* true in hugo_gethugoline() 	*/
 char trace_complex_prop_routine = 0;	/* true if running obj.prop	*/
 char debugger_step_over = 0;		/* true if stepping over	*/
 char debugger_skip = 0;			/* true if skipping next	*/
@@ -65,7 +67,7 @@
 char debugger_has_stepped_back = 0;	/* true once stepped back	*/
 int step_nest;				/* stepping over nested calls	*/
 
-char debug_line[MAXBUFFER];
+char debug_hugoline[MAXBUFFER];
 
 /* For engine routines: */
 /* hemisc.c */
@@ -148,14 +150,14 @@
 	{
 		/* print the bottom caption */
 #if !defined (USE_OTHER_MENUS)
-		sprintf(debug_line, " Press %s for menu", MENUBAR_KEY);
+		sprintf(debug_hugoline, " Press %s for menu", MENUBAR_KEY);
 #else
-/*		sprintf(debug_line, " Hugo Debugger v%d.%d%s", HEVERSION, HEREVISION, HEINTERIM); */
-		sprintf(debug_line, " %s", gamefile);
+/*		sprintf(debug_hugoline, " Hugo Debugger v%d.%d%s", HEVERSION, HEREVISION, HEINTERIM); */
+		sprintf(debug_hugoline, " %s", gamefile);
 		if (RoutineName(currentroutine)[0]!='<')
-			sprintf(debug_line+strlen(debug_line), ": %s", RoutineName(currentroutine));
+			sprintf(debug_hugoline+strlen(debug_hugoline), ": %s", RoutineName(currentroutine));
 #endif
-		debug_windowbottomrow(debug_line);
+		debug_windowbottomrow(debug_hugoline);
 
 		debug_settextpos(D_SCREENWIDTH, D_SCREENHEIGHT);
 
@@ -169,7 +171,7 @@
 			case DOUBLECLICK:
 				/* The SINGLECLICK and DOUBLECLICK action 
 				   currently assume that the newly clicked 
-				   line is already visible on the screen
+				   hugoline is already visible on the screen
                                 */
 				if ((unsigned)event.object >= window[active_window].count)
 				{
@@ -237,7 +239,7 @@
 			case TAB:
 			{
 ToggleGameWindow:
-				if (during_input)	/* hugo_getline() */
+				if (during_input)	/* hugo_gethugoline() */
 				{
 					SwitchtoGame();
 					return;
@@ -273,8 +275,8 @@
 				{
 					if (game==NULL) break;
 
-					sprintf(debug_line, "Restart %s?", gamefile);
-					DebugMessageBox("Restart", debug_line);
+					sprintf(debug_hugoline, "Restart %s?", gamefile);
+					DebugMessageBox("Restart", debug_hugoline);
 					if (event.action==CANCEL)
 						break;
 
@@ -285,13 +287,13 @@
 					debugger_collapsing = 2;
 					var[endflag] = true;
 					during_input = false;
-					buffered_code_lines = FORCE_REDRAW;
+					buffered_code_hugolines = FORCE_REDRAW;
 					return;
 				}
 				case MENU_FILE + FILE_PRINT:
 				{
-					sprintf(debug_line, "Print active window to %s", printer_name);
-					DebugMessageBox("Print", debug_line);
+					sprintf(debug_hugoline, "Print active window to %s", printer_name);
+					DebugMessageBox("Print", debug_hugoline);
 					if (event.action!=CANCEL)
 						HardCopy();
 					break;
@@ -326,7 +328,7 @@
 					debugger_finish = true;
 
 					/* Force redraw */
-					buffered_code_lines = FORCE_REDRAW;
+					buffered_code_hugolines = FORCE_REDRAW;
 					window[VIEW_CALLS].changed = true;
 
 					/* Lose track of history*/
@@ -428,7 +430,7 @@
 					debugger_has_stepped_back = true;
 
 					RecoverLastGood();
-					free(codeline[--window[CODE_WINDOW].count]);
+					free(codehugoline[--window[CODE_WINDOW].count]);
 					codeptr = code_history[history_last];
 					dbnest = dbnest_history[history_last];
 
@@ -532,8 +534,8 @@
 
 				default:
 				{
-					sprintf(debug_line, "Hugo Debugger v%d.%d%s", HEVERSION, HEREVISION, HEINTERIM);
-					DebugMessageBox(debug_line, "Command not available");
+					sprintf(debug_hugoline, "Hugo Debugger v%d.%d%s", HEVERSION, HEREVISION, HEINTERIM);
+					DebugMessageBox(debug_hugoline, "Command not available");
 					break;
 				}
 			}
diff -Naur hugov3.1.03/source/hddecode.c /usr/glenda/cursesif/hugo/source/hddecode.c
--- hugov3.1.03/source/hddecode.c	Fri Oct  9 18:12:02 2015
+++ /usr/glenda/cursesif/hugo/source/hddecode.c	Thu Oct  1 02:31:39 2015
@@ -1,7 +1,7 @@
 /*
 	HDDECODE.C
 
-	contains line-decoding routines:
+	contains hugoline-decoding routines:
 
 		AddLinetoCodeWindow
 			AddAddress
@@ -24,6 +24,8 @@
 
 #include "heheader.h"
 #include "hdheader.h"
+#include "hdinter.h"
+
 
 
 #define WORD_VAL(x) (unsigned int)(arr[x]+arr[x+1]*256)
@@ -35,22 +37,22 @@
 
 long this_codeptr;			/* for error recovery    */
 long next_codeptr;			/* for skipping over     */
-int **codeline;                         /* code window contents  */
-int buffered_code_lines = 0;            /* waiting to be printed */
+int **codehugoline;                         /* code window contents  */
+int buffered_code_hugolines = 0;            /* waiting to be printed */
 
 char format_nesting = 1;	/* for spacing in Code window */
-char screen_line[256];
+char screen_hugoline[256];
 
 
 /* ADDLINETOCODEWINDOW
 
 	Calls DecodeLine to decode the next instruction, and looks
-	after storing it in the codeline array.
+	after storing it in the codehugoline array.
 */
 
 void AddLinetoCodeWindow(long addr)
 {
-	int *decoded_line;
+	int *decoded_hugoline;
 	struct window_structure *win;
 
 	win = &window[CODE_WINDOW];
@@ -60,26 +62,26 @@
 		ShiftCodeLines();
 	}
 
-	decoded_line = DecodeLine(addr);
+	decoded_hugoline = DecodeLine(addr);
 
-	/* Allocate memory for the new line */
-	while ((codeline[win->count]=malloc((size_t)(int_strlen(decoded_line)+1)*sizeof(int)))==NULL)
+	/* Allocate memory for the new hugoline */
+	while ((codehugoline[win->count]=malloc((size_t)(int_strlen(decoded_hugoline)+1)*sizeof(int)))==NULL)
 	{
 		ShiftCodeLines();
 	}
 
-	int_strcpy(codeline[win->count], decoded_line);
+	int_strcpy(codehugoline[win->count], decoded_hugoline);
 
-	/* Only need to count buffered code lines to a point */
-	if (++buffered_code_lines > FORCE_REDRAW) buffered_code_lines = FORCE_REDRAW;
+	/* Only need to count buffered code hugolines to a point */
+	if (++buffered_code_hugolines > FORCE_REDRAW) buffered_code_hugolines = FORCE_REDRAW;
 
         win->count++;
 
-	/* Current code line--set it to the new line, and if it was more
-	   than one full window height back of the new line, force a full-
+	/* Current code hugoline--set it to the new hugoline, and if it was more
+	   than one full window height back of the new hugoline, force a full-
 	   window redraw
 	*/
-	if (win->selected < win->count - win->height) buffered_code_lines = FORCE_REDRAW;
+	if (win->selected < win->count - win->height) buffered_code_hugolines = FORCE_REDRAW;
 	win->selected = win->count-1;
 	win->horiz = 0;
 }
@@ -98,19 +100,19 @@
 		ShiftCodeLines();
 	}
 
-	/* Allocate memory for the new line */
-	while ((codeline[win->count]=malloc((size_t)(strlen(a)+1)*sizeof(int)))==NULL)
+	/* Allocate memory for the new hugoline */
+	while ((codehugoline[win->count]=malloc((size_t)(strlen(a)+1)*sizeof(int)))==NULL)
 	{
 		ShiftCodeLines();
 	}
 
-	AddString(a, codeline[win->count], 0, ROUTINE_TEXT);
+	AddString(a, codehugoline[win->count], 0, ROUTINE_TEXT);
 
-        buffered_code_lines++;
+        buffered_code_hugolines++;
         win->count++;
 
-	/* Current code line adjustment--see AddLinetoCodeWindow() */
-	if (win->selected < win->count - win->height) buffered_code_lines = 100;
+	/* Current code hugoline adjustment--see AddLinetoCodeWindow() */
+	if (win->selected < win->count - win->height) buffered_code_hugolines = 100;
 	win->selected = win->count-1;
 	win->horiz = 0;
 }
@@ -118,7 +120,7 @@
 
 /* ADDADDRESS
 
-	Adds the supplied address to the line <l> at the given position,
+	Adds the supplied address to the hugoline <l> at the given position,
 	in the specified color type.
 */
 
@@ -140,7 +142,7 @@
 
 /* ADDSTRING
 
-	Adds the supplied string to the line <l> at the given position,
+	Adds the supplied string to the hugoline <l> at the given position,
 	in the specified color type.
 */
 
@@ -160,7 +162,7 @@
 /* ADDSYMBOL
 
 	Adds the current symbol (taken from the supplied array, usually
-	mem[]), to the line <l> at the given position, and returns the
+	mem[]), to the hugoline <l> at the given position, and returns the
 	number of characters added.
 */
 
@@ -218,9 +220,9 @@
 
 /* DECODELINE
 
-	The main line-decoding routine, decodes the chunk of code at the
-	supplied address into a line of pseudo-source, and returns a
-	pointer to the int array containing the line.  It's an int
+	The main hugoline-decoding routine, decodes the chunk of code at the
+	supplied address into a hugoline of pseudo-source, and returns a
+	pointer to the int array containing the hugoline.  It's an int
 	array since the low byte contains the character, and the high
 	byte contains the color.
 */
@@ -237,7 +239,7 @@
 	AddString(":  ", l, lpos+6, TOKEN_TEXT);
 	lpos += 9;
 
-	/* Indent current line if this option is selected */
+	/* Indent current hugoline if this option is selected */
 	if (format_nesting)
 	{
 		for (b=0; b<dbnest; b++)
@@ -247,15 +249,15 @@
 		}
 	}
 
-	/* Based on what the first token in the line is, we can determine
-	   what the rest of the line will look like:
+	/* Based on what the first token in the hugoline is, we can determine
+	   what the rest of the hugoline will look like:
 	*/
 	switch (MEM(addr))
 	{
 		case CLOSE_BRACE_T:
 			break;
 
-		/* Normal case:  lines with EOL at the end */
+		/* Normal case:  hugolines with EOL at the end */
 		case RETURN_T:
 		case RUN_T:
 		case PRINT_T:
@@ -334,20 +336,20 @@
 		/* Special case:  printing from text bank */
 		case TEXTDATA_T:
 		{
-			debug_line[0] = '\"';
-			strncpy(debug_line+1, GetText((long)(MEM(addr+1)*65536+PeekWord(addr+2))), D_SCREENWIDTH-4-lpos);
-			sprintf(debug_line+D_SCREENWIDTH-7-lpos, "...");
-			debug_line[strlen(debug_line)+1] = '\0';
-			debug_line[strlen(debug_line)] = '\"';
+			debug_hugoline[0] = '\"';
+			strncpy(debug_hugoline+1, GetText((long)(MEM(addr+1)*65536+PeekWord(addr+2))), D_SCREENWIDTH-4-lpos);
+			sprintf(debug_hugoline+D_SCREENWIDTH-7-lpos, "...");
+			debug_hugoline[strlen(debug_hugoline)+1] = '\0';
+			debug_hugoline[strlen(debug_hugoline)] = '\"';
 			addr+=4;
 			if (MEM(addr)==SEMICOLON_T)
 			{
-				strcat(debug_line, ";");
+				strcat(debug_hugoline, ";");
 				addr++;
 			}
-			else strcat(debug_line, " ");
-			AddString(debug_line, l, lpos, STRING_TEXT);
-			lpos+=strlen(debug_line);
+			else strcat(debug_hugoline, " ");
+			AddString(debug_hugoline, l, lpos, STRING_TEXT);
+			lpos+=strlen(debug_hugoline);
 			break;
 		}
 
@@ -376,13 +378,13 @@
 			break;
 		}
 
-		/* Anything else is a one-word line */
+		/* Anything else is a one-word hugoline */
 		default:
 AddSingleSymbol:
 			lpos += AddSymbol(mem, &addr, l, lpos);
 	}
 
-	next_codeptr = addr;	/* for skipping over this line */
+	next_codeptr = addr;	/* for skipping over this hugoline */
 
 	return l;
 }
@@ -405,7 +407,7 @@
 	int tlen, col, n;
 	static struct token_structure tok;
 
-	/* If start of the line, there was no first token */
+	/* If start of the hugoline, there was no first token */
 	if (firsttoken==1) lasttoken = 0;
 
 	switch (arr[addr])
@@ -442,8 +444,8 @@
 		{
 PrintDictWord:
 			col = STRING_TEXT;
-			sprintf(screen_line, "\"%s\"", GetWord(WORD_VAL(addr+1)));
-			a = screen_line;
+			sprintf(screen_hugoline, "\"%s\"", GetWord(WORD_VAL(addr+1)));
+			a = screen_hugoline;
 			tlen = 3;
 			break;
 		}
@@ -458,8 +460,8 @@
 		{
 			if (lasttoken==PRINT_T) goto PrintDictWord;
 			col = VALUE_TEXT;
-			itoa((short)WORD_VAL(addr+1), screen_line, 10);
-			a = screen_line;
+			itoa((short)WORD_VAL(addr+1), screen_hugoline, 10);
+			a = screen_hugoline;
 			tlen = 3;
 			break;
 		}
@@ -479,24 +481,24 @@
 		}
 		case STRINGDATA_T:
 		{
-			int nlen;	/* Don't overflow screen_line */
+			int nlen;	/* Don't overflow screen_hugoline */
 			col = STRING_TEXT;
 			n = arr[addr+1]+arr[addr+2]*256;
 			nlen = n;
 			if (nlen >= 251) nlen = 250;
-			screen_line[0] = '\"';
+			screen_hugoline[0] = '\"';
 			j = 1;
 			for (i=0; i<nlen; i++)
-				screen_line[j++] = (char)(arr[addr+3+i]-CHAR_TRANSLATION);
+				screen_hugoline[j++] = (char)(arr[addr+3+i]-CHAR_TRANSLATION);
 			if (nlen < n)
 			{
 				for (i=1; i<=3; i++)
-					screen_line[j++] = '.';
+					screen_hugoline[j++] = '.';
 			}
-			screen_line[j] = '\"';
-			screen_line[j+1] = '\0';
+			screen_hugoline[j] = '\"';
+			screen_hugoline[j+1] = '\0';
 			tlen = n+3;
-			a = screen_line;
+			a = screen_hugoline;
 			break;
 		}
 
@@ -512,7 +514,7 @@
 
 
 	/* Adapted from PrintWords in hcmisc.c to adjust the spacing of
-	   certain symbols/operators in a line: */
+	   certain symbols/operators in a hugoline: */
 
 	/* Only worry if a single-character token is involved */
 	if (((arr[addr]<=TOKENS && arr[addr+tlen]<=TOKENS)) &&
@@ -591,30 +593,30 @@
 /* SHIFTCODELINES
 
 	Shifts the array of window information up, deleting the
-	50 oldest lines.  Used by the AllocMem() function to
-	cannibalize code lines for other purposes.
+	50 oldest hugolines.  Used by the AllocMem() function to
+	cannibalize code hugolines for other purposes.
 */
 
 void ShiftCodeLines(void)
 {
 	unsigned int i;
 
-	/* Can only cannibalize as many lines as aren't visible */
+	/* Can only cannibalize as many hugolines as aren't visible */
 	if (window[CODE_WINDOW].count<=(unsigned)window[CODE_WINDOW].height + 50)
 		DebuggerFatal(D_MEMORY_ERROR);
 
-	/* Delete 50 oldest lines */
+	/* Delete 50 oldest hugolines */
 	for (i=0; i<50; i++)
-		free(codeline[i]);
+		free(codehugoline[i]);
 
-	/* Shift lines up */
+	/* Shift hugolines up */
 	for (i=50; i<window[CODE_WINDOW].count; i++)
-		codeline[i-49] = codeline[i];
+		codehugoline[i-49] = codehugoline[i];
 
-	/* Delete the oldest line, and add "..." to the start */
-	if ((codeline[0]=malloc(4*sizeof(int)))==NULL)
+	/* Delete the oldest hugoline, and add "..." to the start */
+	if ((codehugoline[0]=malloc(4*sizeof(int)))==NULL)
 		DebuggerFatal(D_MEMORY_ERROR);
-	AddString("...", codeline[0], 0, ROUTINE_TEXT);
+	AddString("...", codehugoline[0], 0, ROUTINE_TEXT);
 
 	window[CODE_WINDOW].count -= 49;
 	window[CODE_WINDOW].first -= 49;
@@ -650,9 +652,9 @@
 	{
 		for (i=pos; i<int_strlen(a); i++)
 		{
-			sprintf(screen_line, "%c", a[i]&0x00FF);
+			sprintf(screen_hugoline, "%c", a[i]&0x00FF);
 			if (col==-1) debug_settextcolor(color[(a[i]&0xFF00)/256]);
-			debug_print(screen_line);
+			debug_print(screen_hugoline);
 			if (++printed==width) return;
 		}
 	}
@@ -663,9 +665,9 @@
 		debug_settextcolor(color[NORMAL_TEXT]);
 		debug_setbackcolor(color[NORMAL_BACK]);
 	}
-	memset(screen_line, ' ', width-printed);
-	screen_line[width-printed] = '\0';
-	debug_print(screen_line);
+	memset(screen_hugoline, ' ', width-printed);
+	screen_hugoline[width-printed] = '\0';
+	debug_print(screen_hugoline);
 }
 
 void int_strcpy(int *a, int *b)
diff -Naur hugov3.1.03/source/hdheader.h /usr/glenda/cursesif/hugo/source/hdheader.h
--- hugov3.1.03/source/hdheader.h	Fri Oct  9 18:12:02 2015
+++ /usr/glenda/cursesif/hugo/source/hdheader.h	Thu Oct  1 02:31:39 2015
@@ -13,6 +13,7 @@
 
 	by ct
 ---------------------------------------------------------------------------*/
+#define GCC_UNIX
 
 #if defined (ACORN)
 
@@ -107,9 +108,6 @@
 char *strupr(char *s);
 char *strlwr(char *s);
 
-#ifndef malloc
-#define malloc(a) AmigaMalloc(a)
-#endif
 
 #endif  /* defined (AMIGA) */
 
@@ -142,17 +140,17 @@
 #define DEFAULT_VALUE_TEXT      12      /* light red     */
 #define DEFAULT_VARIABLE_TEXT   15      /* bright white  */
 
-/* PC Extended-ASCII line-drawing characters (could be replaced
+/* PC Extended-ASCII hugoline-drawing characters (could be replaced
    with regular ASCII characters, i.e., '-', '+', and '|')
 */
-#define HORIZONTAL_LINE         ''
-#define HORIZONTAL_LEFT         ''
-#define HORIZONTAL_RIGHT        ''
-#define VERTICAL_LINE           ''
-#define TOP_LEFT                ''
-#define TOP_RIGHT               ''
-#define BOTTOM_LEFT             ''
-#define BOTTOM_RIGHT            ''
+#define HORIZONTAL_LINE         ''
+#define HORIZONTAL_LEFT         ''
+#define HORIZONTAL_RIGHT        ''
+#define VERTICAL_LINE           ''
+#define TOP_LEFT                ''
+#define TOP_RIGHT               ''
+#define BOTTOM_LEFT             ''
+#define BOTTOM_RIGHT            ''
 
 #define MENUBAR_KEY "ALT"               /* name of menubar activation key */
 
@@ -345,17 +343,17 @@
 #define DEFAULT_VALUE_TEXT      12      /* light red     */
 #define DEFAULT_VARIABLE_TEXT   15      /* bright white  */
 
-/* PC Extended-ASCII line-drawing characters (could be replaced
+/* PC Extended-ASCII hugoline-drawing characters (could be replaced
    with regular ASCII characters, i.e., '-', '+', and '|')
 */
-#define HORIZONTAL_LINE         ''
-#define HORIZONTAL_LEFT         ''
-#define HORIZONTAL_RIGHT        ''
-#define VERTICAL_LINE           ''
-#define TOP_LEFT                ''
-#define TOP_RIGHT               ''
-#define BOTTOM_LEFT             ''
-#define BOTTOM_RIGHT            ''
+#define HORIZONTAL_LINE         ''
+#define HORIZONTAL_LEFT         ''
+#define HORIZONTAL_RIGHT        ''
+#define VERTICAL_LINE           ''
+#define TOP_LEFT                ''
+#define TOP_RIGHT               ''
+#define BOTTOM_LEFT             ''
+#define BOTTOM_RIGHT            ''
 
 #define MENUBAR_KEY "ALT"               /* name of menubar activation key */
 
@@ -495,7 +493,7 @@
 void debug_windowbottomrow(char *caption);
 void debug_windowrestore(void *buf, int xpos, int ypos);
 void *debug_windowsave(int left, int top, int right, int bottom);
-void debug_windowscroll(int left, int top, int right, int bottom, int param, int lines);
+void debug_windowscroll(int left, int top, int right, int bottom, int param, int hugolines);
 void debug_windowshadow(int left, int top, int right, int bottom);
 
 
@@ -517,7 +515,7 @@
 void int_strcpy(int *a, int *b);
 
 extern char format_nesting;
-extern char screen_line[];
+extern char screen_hugoline[];
 
 
 /* hdmisc.c */
diff -Naur hugov3.1.03/source/hdinter.h /usr/glenda/cursesif/hugo/source/hdinter.h
--- hugov3.1.03/source/hdinter.h	Fri Oct  9 18:12:02 2015
+++ /usr/glenda/cursesif/hugo/source/hdinter.h	Thu Oct  1 02:31:39 2015
@@ -12,6 +12,7 @@
 
 /*-------------------------------------------------------------------------*/
 
+#define GCC_UNIX
 
 #if !defined (PROGRAM_NAME)
 #define PROGRAM_NAME 	"hd"
@@ -67,7 +68,7 @@
 
 	/* START and FINISH are used to move to the very top or bottom,
 	   while HOME and END generally refer to the start and end of
-	   a line, respectively.
+	   a hugoline, respectively.
 	*/
 	START, FINISH, HOME, END
 };
@@ -85,11 +86,11 @@
 
 struct window_structure
 {
-	unsigned int first;	/* first line appearing in the window 	*/
-	unsigned int selected;	/* selected line 			*/
-	unsigned int count;	/* total lines in (or out of) window	*/
-	unsigned int top;       /* where top line is on the screen      */
-	unsigned int height;    /* maximum # of lines                   */
+	unsigned int first;	/* first hugoline appearing in the window 	*/
+	unsigned int selected;	/* selected hugoline 			*/
+	unsigned int count;	/* total hugolines in (or out of) window	*/
+	unsigned int top;       /* where top hugoline is on the screen      */
+	unsigned int height;    /* maximum # of hugolines                   */
 	int width;              /* maximum # of characters              */
 	int horiz;              /* horizontal shift                     */
 	char changed;		/* true if window needs updating	*/
@@ -127,7 +128,7 @@
 void Debugger(void);
 void StartDebugger(void);
 
-extern char debug_line[];
+extern char debug_hugoline[];
 extern struct event_structure event;
 extern char debugger_run, debugger_interrupt, during_input,
 	debugger_collapsing;
@@ -155,8 +156,8 @@
 void ShiftCodeLines(void);
 
 extern long this_codeptr, next_codeptr;
-extern int **codeline;
-extern int buffered_code_lines;
+extern int **codehugoline;
+extern int buffered_code_hugolines;
 
 
 /* hdmisc.c */
diff -Naur hugov3.1.03/source/hdmisc.c /usr/glenda/cursesif/hugo/source/hdmisc.c
--- hugov3.1.03/source/hdmisc.c	Fri Oct  9 18:12:02 2015
+++ /usr/glenda/cursesif/hugo/source/hdmisc.c	Thu Oct  1 02:31:39 2015
@@ -99,33 +99,33 @@
 	debug_setbackcolor(color[NORMAL_BACK]);
 	debug_clearview(VIEW_HELP);
 
-	sprintf(debug_line, "About the Hugo v%d.%d%s Debugger\n\n", HEVERSION, HEREVISION, HEINTERIM);
-	debug_settextpos(Center(debug_line), 1);
+	sprintf(debug_hugoline, "About the Hugo v%d.%d%s Debugger\n\n", HEVERSION, HEREVISION, HEINTERIM);
+	debug_settextpos(Center(debug_hugoline), 1);
 	debug_settextcolor(color[SELECT_TEXT]);
 	debug_setbackcolor(color[SELECT_BACK]);
-	debug_print(debug_line);
+	debug_print(debug_hugoline);
 
 	debug_settextcolor(color[NORMAL_TEXT]);
 	debug_setbackcolor(color[NORMAL_BACK]);
 
 	/* For formatting Help window text: */
-	memset(debug_line, ' ', (size_t)(l = ((window[VIEW_HELP].width-64)/2+4)));
-	debug_line[l] = '\0';
+	memset(debug_hugoline, ' ', (size_t)(l = ((window[VIEW_HELP].width-64)/2+4)));
+	debug_hugoline[l] = '\0';
 
-	debug_print(debug_line);
+	debug_print(debug_hugoline);
 	debug_print("Written by Kent Tessman\n");
-	debug_print(debug_line);
+	debug_print(debug_hugoline);
 	debug_print("Copyright (c) 1995-2006\n");
-	debug_print(debug_line);
+	debug_print(debug_hugoline);
 	debug_print("The General Coffee Company Film Productions\n\n");
-	debug_print(debug_line);
+	debug_print(debug_hugoline);
 	debug_print("(");
 	debug_print(PORT_NAME);
 	debug_print(" port by ");
 	debug_print(PORTER_NAME);
 	debug_print(")\n\n");
 
-	debug_print(debug_line);
+	debug_print(debug_hugoline);
 	debug_print("Select \"Topic\" from the Help menu, then type \"help\".\n");
 
 #if !defined (NO_WINDOW_PROMPTS)
@@ -141,7 +141,7 @@
 /* ALLOCMEMORY
 
 	Used in place of malloc() when it may be necessary to cannibalize
-	the memory allocated for code-line history if needed, e.g., for
+	the memory allocated for code-hugoline history if needed, e.g., for
 	saving a rectangle of screen text or adding a watch value.
 */
 
@@ -185,8 +185,8 @@
 	{
 		if (val < 0 || val > max)
 		{
-			sprintf(debug_line, "%c%s out of range:  %ld", toupper(what[0]), what+1, (long)val);
-			RuntimeWarning(debug_line);
+			sprintf(debug_hugoline, "%c%s out of range:  %ld", toupper(what[0]), what+1, (long)val);
+			RuntimeWarning(debug_hugoline);
 			return false;
 		}
 	}
@@ -244,12 +244,12 @@
 	{
 		case D_MEMORY_ERROR:
 		{
-			strcpy(debug_line, "Out of memory");
+			strcpy(debug_hugoline, "Out of memory");
 			break;
 		}
 		case D_VERSION_ERROR:
 		{
-			sprintf(debug_line, "File must be compiled with version %d.%d", HEVERSION, HEREVISION);
+			sprintf(debug_hugoline, "File must be compiled with version %d.%d", HEVERSION, HEREVISION);
 			break;
 		}
 	}
@@ -258,7 +258,7 @@
 	hugo_clearfullscreen();
 
 	top = D_SCREENHEIGHT/2-3;
-	width = (strlen(debug_line)>40)?strlen(debug_line):40;
+	width = (strlen(debug_hugoline)>40)?strlen(debug_hugoline):40;
 	left = D_SCREENWIDTH/2-width/2-2;
 	right = D_SCREENWIDTH/2+width/2+2;
 
@@ -267,23 +267,23 @@
 	/* Tweak the borders a little to draw a shadow */
 	debug_windowshadow(left, top, right+2, top+7);
 
-	debug_settextpos(Center(debug_line), top+3);
-	debug_print(debug_line);
+	debug_settextpos(Center(debug_hugoline), top+3);
+	debug_print(debug_hugoline);
 
-	strcpy(debug_line, "DEBUGGER FATAL ERROR");
-	debug_settextpos(Center(debug_line), top+1);
-	debug_print(debug_line);
+	strcpy(debug_hugoline, "DEBUGGER FATAL ERROR");
+	debug_settextpos(Center(debug_hugoline), top+1);
+	debug_print(debug_hugoline);
 
 	debug_cursor(1);
-	strcpy(debug_line, "[Press Enter to terminate...]");
-	debug_settextpos(Center(debug_line), top+5);
-	debug_print(debug_line);
+	strcpy(debug_hugoline, "[Press Enter to terminate...]");
+	debug_settextpos(Center(debug_hugoline), top+5);
+	debug_print(debug_hugoline);
 
 	while (hugo_waitforkey()!=ENTER_KEY);
 
 	hugo_cleanup_screen();
 #else
-	DEBUGGER_PRINTFATALERROR(debug_line);
+	DEBUGGER_PRINTFATALERROR(debug_hugoline);
 #endif
 
 	exit(n);
@@ -375,7 +375,7 @@
 			window[VIEW_BREAKPOINTS].changed = true;
 
 			/* Force Code window redraw */
-			buffered_code_lines = FORCE_REDRAW;
+			buffered_code_hugolines = FORCE_REDRAW;
 			window[CODE_WINDOW].selected = window[CODE_WINDOW].count - 1;
 
 			UpdateDebugScreen();
@@ -394,7 +394,7 @@
 
 	t = "Set Breakpoint";
 
-	/* First try getting the highlighted line from the code window: */
+	/* First try getting the highlighted hugoline from the code window: */
 	if (window[CODE_WINDOW].count)
 		paddr = StealAddress(window[CODE_WINDOW].selected-window[CODE_WINDOW].first);
 
@@ -456,8 +456,8 @@
 
 	debug_windowbottomrow("Searching...");
 
-	/* Skim through lines, first from the next line to
-	   the last-recorded code line
+	/* Skim through hugolines, first from the next hugoline to
+	   the last-recorded code hugoline
 	*/
 	for (l=win->selected+1; l<win->count; l++)
 	{
@@ -469,8 +469,8 @@
 	}
 
 	/* If we haven't matched yet, skim from the oldest code
-	  line to the previous starting point (i.e., the current
-	  line)
+	  hugoline to the previous starting point (i.e., the current
+	  hugoline)
 	*/
 	if (!found)
 	{
@@ -488,12 +488,12 @@
 
 	if (!found)
 	{
-		sprintf(debug_line, "Not found:  %s", search);
-		DebugMessageBox("Search", debug_line);
+		sprintf(debug_hugoline, "Not found:  %s", search);
+		DebugMessageBox("Search", debug_hugoline);
 		return;
 	}
 
-	/* If we get to this point, then l holds the (next) line
+	/* If we get to this point, then l holds the (next) hugoline
 	   containing the search string.
 	*/
 	strcpy(last_search, search);
@@ -602,13 +602,13 @@
 	{
 		hugo_clearfullscreen();
 		hugo_cleanup_screen();
-		sprintf(debug_line, "File \"%s\" not compiled as .HDX file.\n", gamefile);
-		sprintf(debug_line+strlen(debug_line), "(Use -d switch during compilation.)\n");
+		sprintf(debug_hugoline, "File \"%s\" not compiled as .HDX file.\n", gamefile);
+		sprintf(debug_hugoline+strlen(debug_hugoline), "(Use -d switch during compilation.)\n");
 
 #if defined (DEBUGGER_PRINTFATALERROR)
-		DEBUGGER_PRINTFATALERROR(debug_line);
+		DEBUGGER_PRINTFATALERROR(debug_hugoline);
 #else
-		printf(debug_line);
+		printf(debug_hugoline);
 #endif
 		
 		exit(READ_E);                           /* unable to read */
@@ -702,7 +702,7 @@
 
 	/* Reserve space for window information: */
 
-	if ((codeline = malloc((size_t)MAX_CODE_LINES*sizeof(int *)))==NULL)
+	if ((codehugoline = malloc((size_t)MAX_CODE_LINES*sizeof(int *)))==NULL)
 		FatalError(MEMORY_E);
 }
 
@@ -823,18 +823,18 @@
 
 	i = window[CODE_WINDOW].count;
 	c = i - window[CODE_WINDOW].selected;
-	free(codeline[--i]);
+	free(codehugoline[--i]);
 
 	if (!runtime_error)
 	{
-		while((i>0) && (codeline[i-1][0]&0xFF)!='0')
-			free(codeline[--i]);
+		while((i>0) && (codehugoline[i-1][0]&0xFF)!='0')
+			free(codehugoline[--i]);
 	}
 
 	window[CODE_WINDOW].count = i;
 	window[CODE_WINDOW].selected = i-c;
 
-	buffered_code_lines = FORCE_REDRAW;
+	buffered_code_hugolines = FORCE_REDRAW;
 
 	/* lost track of calls */
 	window[VIEW_CALLS].count = 0;
@@ -959,7 +959,7 @@
 	char drive[MAXDRIVE], dir[MAXDIR], fname[MAXFILENAME], ext[MAXEXT];
 	char help_path[MAXPATH];
 	char *t, topic[33], compare_topic[33];
-	int i, l, linecount;
+	int i, l, hugolinecount;
 	FILE *helpfile = NULL;
 
 	if (in_help_mode) return false;
@@ -985,8 +985,8 @@
 
 	if ((helpfile = fopen(help_path, "rb"))==NULL)
 	{
-		sprintf(debug_line, "Unable to load help file:  %s", HELP_FILE);
-		DebugMessageBox(t, debug_line);
+		sprintf(debug_hugoline, "Unable to load help file:  %s", HELP_FILE);
+		DebugMessageBox(t, debug_hugoline);
 		goto ReturnFalse;
 	}
 
@@ -998,34 +998,34 @@
 
 	while (!feof(helpfile))
 	{
-		if (fgets(debug_line, MAXBUFFER, helpfile)==NULL) goto HelpError;
+		if (fgets(debug_hugoline, MAXBUFFER, helpfile)==NULL) goto HelpError;
 
-		if (!STRICMP(debug_line, "$end\n")) break;
+		if (!STRICMP(debug_hugoline, "$end\n")) break;
 
 		/* Lines of keywords are in quotation marks--check for
 		   a match against the topic
 		*/
-		else if (debug_line[0]=='\"')
+		else if (debug_hugoline[0]=='\"')
 		{
 			/* First off, change the last quote to a space */
-			debug_line[strlen(debug_line)+1] = '\0';
-			debug_line[strlen(debug_line)-1] = ' ';
+			debug_hugoline[strlen(debug_hugoline)+1] = '\0';
+			debug_hugoline[strlen(debug_hugoline)-1] = ' ';
 
 			/* Check if a match is found */
 			l = 0;
-			for (i=0; (size_t)i<strlen(debug_line)-strlen(topic); i++)
+			for (i=0; (size_t)i<strlen(debug_hugoline)-strlen(topic); i++)
 			{
-				if (strlen(debug_line) < strlen(topic) || strlen(topic) > 32)
+				if (strlen(debug_hugoline) < strlen(topic) || strlen(topic) > 32)
 					break;
 
 				/* The first word begins at 1, since 0 is
 				   the opening '"' */
 				if (i > 1)
 					/* Find the start of the next word */
-					while (debug_line[i++]!=' ')
-						if (debug_line[i]=='\0') break;
+					while (debug_hugoline[i++]!=' ')
+						if (debug_hugoline[i]=='\0') break;
 
-				strncpy(compare_topic, debug_line+i, strlen(topic));
+				strncpy(compare_topic, debug_hugoline+i, strlen(topic));
 				compare_topic[strlen(topic)] = '\0';
 				if (!STRICMP(topic, compare_topic))
 				{
@@ -1043,38 +1043,38 @@
 					goto HelpError;
 				help_path[strlen(help_path)-1] = '\0';
 
-				sprintf(debug_line, "Help on \"%s\"\n", help_path);
-				debug_settextpos(Center(debug_line), 1);
+				sprintf(debug_hugoline, "Help on \"%s\"\n", help_path);
+				debug_settextpos(Center(debug_hugoline), 1);
 				debug_settextcolor(color[SELECT_TEXT]);
 				debug_setbackcolor(color[SELECT_BACK]);
-				debug_print(debug_line);
-				linecount = 2;
+				debug_print(debug_hugoline);
+				hugolinecount = 2;
 
 GetAnotherLine:
-				/* Help file lines are a maximum of 64 characters
+				/* Help file hugolines are a maximum of 64 characters
 				   long; this is to center them in the Help
 				   window:
 				*/
-				memset(debug_line, ' ', (size_t)(l = ((window[VIEW_HELP].width-64)/2)));
+				memset(debug_hugoline, ' ', (size_t)(l = ((window[VIEW_HELP].width-64)/2)));
 
 				do
 				{
-					if (fgets(debug_line+l, MAXBUFFER, helpfile)==NULL)
+					if (fgets(debug_hugoline+l, MAXBUFFER, helpfile)==NULL)
 						goto HelpError;
 				}
-				while (linecount==0 && debug_line[l]=='\n');
+				while (hugolinecount==0 && debug_hugoline[l]=='\n');
 
-				/* If the line doesn't start with a helpfile
+				/* If the hugoline doesn't start with a helpfile
 				   control character, it must be printed help
 				   text
 				*/
-				if (debug_line[l]!='\"' && debug_line[l]!='$' && debug_line[l]!='#')
+				if (debug_hugoline[l]!='\"' && debug_hugoline[l]!='$' && debug_hugoline[l]!='#')
 				{
 					debug_settextcolor(color[NORMAL_TEXT]);
 					debug_setbackcolor(color[NORMAL_BACK]);
-					debug_print(debug_line);
+					debug_print(debug_hugoline);
 #if !defined (NO_WINDOW_PROMPTS)
-					if (++linecount >= D_SCREENHEIGHT)
+					if (++hugolinecount >= D_SCREENHEIGHT)
 					{
 						debug_windowbottomrow("Enter to continue, Escape to quit");
 						debug_settextcolor(color[NORMAL_TEXT]);
@@ -1089,7 +1089,7 @@
 						hugo_clearfullscreen();
 						debug_windowbottomrow("");
 						debug_settextpos(1, 1);
-						linecount = 0;
+						hugolinecount = 0;
 					}
 #endif
 					goto GetAnotherLine;
@@ -1119,8 +1119,8 @@
 		}
 	}
 
-	sprintf(debug_line, "Unable to find topic:  %s", topic);
-	DebugMessageBox(t, debug_line);
+	sprintf(debug_hugoline, "Unable to find topic:  %s", topic);
+	DebugMessageBox(t, debug_hugoline);
 	goto ReturnFalse;
 
 HelpError:
@@ -1141,7 +1141,7 @@
 {
 	int i, len, start, nomatch = true;
 
-	if ((len = int_strlen(codeline[ln])) < (int)strlen(a)) return false;
+	if ((len = int_strlen(codehugoline[ln])) < (int)strlen(a)) return false;
 
 	len-=strlen(a);
 
@@ -1150,7 +1150,7 @@
 		nomatch = 0;
 		for (i=0; i<(int)strlen(a); i++)
 		{
-			if (toupper((int)(codeline[ln][i+start]&0xFF))!=toupper(a[i]))
+			if (toupper((int)(codehugoline[ln][i+start]&0xFF))!=toupper(a[i]))
 			{
 				nomatch = true;
 				continue;
@@ -1206,8 +1206,8 @@
 
 	if (window[VIEW_BREAKPOINTS].count==MAXBREAKPOINTS)
 	{
-		sprintf(debug_line, "Maximum of %d breakpoints", MAXBREAKPOINTS);
-		DebugMessageBox("Set Breakpoint", debug_line);
+		sprintf(debug_hugoline, "Maximum of %d breakpoints", MAXBREAKPOINTS);
+		DebugMessageBox("Set Breakpoint", debug_hugoline);
 		return;
 	}
 
@@ -1236,7 +1236,7 @@
 /* STEALADDRESS
 
 	Attempts in a backwards manner to get the address at the start of
-	the given line in the Code window.  Returns false if it doesn't
+	the given hugoline in the Code window.  Returns false if it doesn't
 	start with an address.
 */
 
@@ -1250,12 +1250,12 @@
 		return 0;
 
 	/* not even a potential address */
-	if (((!window[CODE_WINDOW].count) || (codeline[l][0]&0xFF)=='\0') || int_strlen(codeline[l])<6)
+	if (((!window[CODE_WINDOW].count) || (codehugoline[l][0]&0xFF)=='\0') || int_strlen(codehugoline[l])<6)
 		return 0;
 
 	for (i=0; i<=5; i++)
-		debug_line[i] = (unsigned char)(codeline[l][i]&0xFF);
-	debug_line[6] = '\0';
+		debug_hugoline[i] = (unsigned char)(codehugoline[l][i]&0xFF);
+	debug_hugoline[6] = '\0';
 
-	return HextoDec(debug_line);
+	return HextoDec(debug_hugoline);
 }
diff -Naur hugov3.1.03/source/hdtools.c /usr/glenda/cursesif/hugo/source/hdtools.c
--- hugov3.1.03/source/hdtools.c	Fri Oct  9 18:12:02 2015
+++ /usr/glenda/cursesif/hugo/source/hdtools.c	Thu Oct  1 02:31:39 2015
@@ -56,7 +56,7 @@
 char setup_path[MAXPATH];
 char last_object_tree[33] = "";
 int tree_nest;                  /* the branching level of an object tree */
-int tree_lines;                 /* the number of objects printed         */
+int tree_hugolines;                 /* the number of objects printed         */
 
 
 /* DEBUGMOVEOBJ */
@@ -73,9 +73,9 @@
 	if (!strcmp(a, "")) return;
 	else if ((obj = ObjectNumber(a))==-1) goto NoSuchObject;
 
-	sprintf(debug_line, "Move %s to new parent:", a);
+	sprintf(debug_hugoline, "Move %s to new parent:", a);
 
-	a = InputBox(t, debug_line, 33, "");
+	a = InputBox(t, debug_hugoline, 33, "");
 
 	if (!strcmp(a, "")) return;
 	else if ((to_obj = ObjectNumber(a))==-1) goto NoSuchObject;
@@ -84,8 +84,8 @@
 	return;
 
 NoSuchObject:
-	sprintf(debug_line, "No such object as \"%s\"", a);
-	DebugMessageBox("Object Name", debug_line);
+	sprintf(debug_hugoline, "No such object as \"%s\"", a);
+	DebugMessageBox("Object Name", debug_hugoline);
 }
 
 
@@ -94,7 +94,7 @@
 	Called by DrawTree(), below.
 */
 
-/* ContinueBranch determines the appropriate type of branch line for an 
+/* ContinueBranch determines the appropriate type of branch hugoline for an 
    object tree depending on whether the given branch continues onward from
    obj.  The current parameter is either 1 or 0, depending on whether the
    choice in question is regarding the current branch or the continuation
@@ -129,7 +129,7 @@
 	int i, j, lastobj;
 
 #if !defined (NO_WINDOW_PROMPTS)
-	if (++tree_lines%(D_SCREENHEIGHT-1)==0)
+	if (++tree_hugolines%(D_SCREENHEIGHT-1)==0)
 	{
 		debug_windowbottomrow("Enter to continue, Escape to quit");
 
@@ -144,8 +144,8 @@
 	debug_settextcolor(color[NORMAL_TEXT]);
 	debug_setbackcolor(color[NORMAL_BACK]);
 
-	/* Scroll the window up a line if necessary */
-	if (tree_lines>=D_SCREENHEIGHT-1)
+	/* Scroll the window up a hugoline if necessary */
+	if (tree_hugolines>=D_SCREENHEIGHT-1)
 	{
 		debug_windowscroll(1, 1, D_SCREENWIDTH, D_SCREENHEIGHT-1, UP, 1);
 		debug_settextpos(1, D_SCREENHEIGHT-1);
@@ -163,20 +163,20 @@
 			for (j=1; j<tree_nest-i; j++)
 				lastobj = Parent(lastobj);
 				
-			sprintf(debug_line, "%c   ", (Sibling(lastobj) || Parent(lastobj)==0)
+			sprintf(debug_hugoline, "%c   ", (Sibling(lastobj) || Parent(lastobj)==0)
 						? ContinueBranch(lastobj, 0):' ');
-			debug_print(debug_line);
+			debug_print(debug_hugoline);
 		}
 
-		sprintf(debug_line, "%c%c%c%c", ContinueBranch(obj, 1),
+		sprintf(debug_hugoline, "%c%c%c%c", ContinueBranch(obj, 1),
 			HORIZONTAL_LINE, HORIZONTAL_LINE, HORIZONTAL_LINE);
 	}
-	else strcpy(debug_line, "");
+	else strcpy(debug_hugoline, "");
 
 	/* ...before printing the object name... */
 
-	strcat(debug_line, objectname[obj]);
-	debug_print(debug_line);
+	strcat(debug_hugoline, objectname[obj]);
+	debug_print(debug_hugoline);
 	debug_print("\n");
 
 	/* ...and recurse into its children (if any) */
@@ -225,11 +225,11 @@
 	/* Draw this object and all its children: */
 
 	debug_settextpos(1, 1);
-	sprintf(debug_line, "%s\n", objectname[obj]);
-	debug_print(debug_line);
+	sprintf(debug_hugoline, "%s\n", objectname[obj]);
+	debug_print(debug_hugoline);
 
 	tree_nest = 0;
-	tree_lines = 0;
+	tree_hugolines = 0;
 	
 	total_leftcolumn_objects = 0;
 	for (i=0; i<objects; i++)
@@ -267,8 +267,8 @@
 	return;
 
 NoSuchObject:
-	sprintf(debug_line, "No such object as \"%s\"", a);
-	DebugMessageBox("Object Name", debug_line);
+	sprintf(debug_hugoline, "No such object as \"%s\"", a);
+	DebugMessageBox("Object Name", debug_hugoline);
 }
 
 
@@ -309,8 +309,8 @@
 
 LoadSetupError:
 	fclose(setupfile);
-	sprintf(debug_line, "Unable to load \"%s\"", setup_path);
-	DebugMessageBox("Setup File Error", debug_line);
+	sprintf(debug_hugoline, "Unable to load \"%s\"", setup_path);
+	DebugMessageBox("Setup File Error", debug_hugoline);
 
 UseDefaults:
 
@@ -393,8 +393,8 @@
 	fclose(setupfile);              /* close (unsuccessfully) */
 
 SaveSetupError:
-	sprintf(debug_line, "Unable to save \"%s\"", setup_path);
-	DebugMessageBox("Setup File Error", debug_line);
+	sprintf(debug_hugoline, "Unable to save \"%s\"", setup_path);
+	DebugMessageBox("Setup File Error", debug_hugoline);
 
 	return;
 }
@@ -484,7 +484,7 @@
 	debug_settextcolor(color[NORMAL_TEXT]);
 	debug_setbackcolor(color[NORMAL_BACK]);
 	hugo_clearfullscreen();
-	buffered_code_lines = FORCE_REDRAW;	/* force Code window redraw */
+	buffered_code_hugolines = FORCE_REDRAW;	/* force Code window redraw */
 	UpdateDebugScreen();
 }
 
@@ -501,7 +501,7 @@
 	if (f==1) a = "Printer";  /* only device for now */
 	else a = "(undefined)";
 
-	sprintf(debug_line, "%s Name", a);
+	sprintf(debug_hugoline, "%s Name", a);
 
 	if (f==1) c = "Enter path or device name:";
 	else c = "(undefined)";
diff -Naur hugov3.1.03/source/hdupdate.c /usr/glenda/cursesif/hugo/source/hdupdate.c
--- hugov3.1.03/source/hdupdate.c	Fri Oct  9 18:12:02 2015
+++ /usr/glenda/cursesif/hugo/source/hdupdate.c	Thu Oct  1 02:31:39 2015
@@ -78,9 +78,9 @@
 
 /* HARDCOPY
 
-	Sends the contents of the current window line-by-line
+	Sends the contents of the current window hugoline-by-hugoline
 	to the printer using debug_hardcopy(), which is responsible
-	for all system-specific interfacing.  Uses the regular line-
+	for all system-specific interfacing.  Uses the regular hugoline-
 	printing routines.
 */
 
@@ -101,8 +101,8 @@
 	if ((printer = fopen(printer_name, "wt"))==NULL)
 		goto DeviceError;
 
-	sprintf(debug_line, "\"%s\"\n", gamefile);
-	debug_hardcopy(printer, debug_line);
+	sprintf(debug_hugoline, "\"%s\"\n", gamefile);
+	debug_hardcopy(printer, debug_hugoline);
 
 	if (active_window==CODE_WINDOW)
 	{
@@ -110,7 +110,7 @@
 		end = win->first+win->height;
 		if (end>=win->count) end = win->count-1;
 
-		strcpy(debug_line, "Code Window:\n");
+		strcpy(debug_hugoline, "Code Window:\n");
 	}
 	else
 	{
@@ -123,13 +123,13 @@
 		for (i=0; i<strlen(menu[m][active_view]); i++)
 		{
 			if (menu[m][active_view][i]!='&')
-				debug_line[j++] = menu[m][active_view][i];
+				debug_hugoline[j++] = menu[m][active_view][i];
 		}
-		sprintf(debug_line+j, ":\n");
+		sprintf(debug_hugoline+j, ":\n");
 	}
 
 	/* Print the name of the active window */
-	debug_hardcopy(printer, debug_line);
+	debug_hardcopy(printer, debug_hugoline);
 
 	if (win->count==0) goto FinishPrinting;
 
@@ -158,8 +158,8 @@
 	if (!device_error) return;
 
 DeviceError:
-	sprintf(debug_line, "Unable to print to %s", printer_name);
-	DebugMessageBox("Printing Error", debug_line);
+	sprintf(debug_hugoline, "Unable to print to %s", printer_name);
+	DebugMessageBox("Printing Error", debug_hugoline);
 	device_error = false;
 }
 
@@ -167,7 +167,7 @@
 /* HIGHLIGHTCURRENT
 
 	Depending on the value of a, either draws (1) or erases (0)
-	the highlight from the current line in the active window.
+	the highlight from the current hugoline in the active window.
 */
 
 void HighlightCurrent(int a)
@@ -191,7 +191,7 @@
 	debug_settextpos(2, (win->top - win->first + win->selected));
 
 	/* If erasing current highlight, cheat the currently selected
-	   line and restore it later.
+	   hugoline and restore it later.
 	*/
 	if (!a) win->selected = -1;
 	
@@ -349,8 +349,8 @@
 CheckLeftRight:
 				if (active_window==CODE_WINDOW)
 				{
-					if (win->horiz > (int)int_strlen(codeline[win->selected])-win->width)
-						win->horiz = int_strlen(codeline[win->selected])-win->width;
+					if (win->horiz > (int)int_strlen(codehugoline[win->selected])-win->width)
+						win->horiz = int_strlen(codehugoline[win->selected])-win->width;
 					if (win->horiz < 0) win->horiz = 0;
 				}
 				else if (active_window==VIEW_WATCH)
@@ -372,22 +372,22 @@
 			{
 				new_selected = win->horiz;
 
-				/* Move to the start of the line */
+				/* Move to the start of the hugoline */
 				if (win->horiz!=0 && event.object==HOME)
 					win->horiz = 0;
 
-				/* Move to the end of the line */
+				/* Move to the end of the hugoline */
 				else if (event.object==END)
-					if ((active_window==CODE_WINDOW && win->horiz < (int)int_strlen(codeline[win->selected])-win->width)
+					if ((active_window==CODE_WINDOW && win->horiz < (int)int_strlen(codehugoline[win->selected])-win->width)
 					|| (active_window==VIEW_WATCH && win->horiz < (int)watch[win->selected].strlen-win->width))
 
 						/* Cheat a large enough value to force
-						   the end-of-line-figuring mechanism
+						   the end-of-hugoline-figuring mechanism
 						   to trigger:
 						*/
 						win->horiz = 32767;
 
-				/* Now move the line position if anything changed */
+				/* Now move the hugoline position if anything changed */
 				if ((unsigned)win->horiz!=new_selected) goto CheckLeftRight;
 
 				break;
@@ -443,14 +443,14 @@
 
 	if (hard_copy)
 	{
-		ConverttoChar(l, debug_line);
-		debug_hardcopy(printer, debug_line);
+		ConverttoChar(l, debug_hugoline);
+		debug_hardcopy(printer, debug_hugoline);
 		return;
 	}
 
-	memset(screen_line, ' ', window[VIEW_ALIASES].width-2-int_strlen(l));
-	screen_line[window[VIEW_ALIASES].width-int_strlen(l)] = '\0';
-	AddString(screen_line, l, int_strlen(l), TOKEN_TEXT);
+	memset(screen_hugoline, ' ', window[VIEW_ALIASES].width-2-int_strlen(l));
+	screen_hugoline[window[VIEW_ALIASES].width-int_strlen(l)] = '\0';
+	AddString(screen_hugoline, l, int_strlen(l), TOKEN_TEXT);
 
 	int_print(l, printflag, 0, window[VIEW_ALIASES].width);
 }
@@ -460,13 +460,13 @@
 
 void PrintBlankLine(unsigned int l)
 {
-	memset(screen_line, ' ', window[active_view].width);
-	screen_line[window[active_view].width] = '\0';
+	memset(screen_hugoline, ' ', window[active_view].width);
+	screen_hugoline[window[active_view].width] = '\0';
 	debug_settextpos(2, l+window[active_view].top);
 	debug_settextcolor(color[NORMAL_TEXT]);
 	debug_setbackcolor(color[NORMAL_BACK]);
 
-	debug_print(screen_line);
+	debug_print(screen_hugoline);
 }       
 
 
@@ -474,17 +474,17 @@
 
 void PrintBreakpoint(unsigned int i)
 {
-	sprintf(screen_line, "  %6s:", PrintHex(breakpoint[i].addr));
-	sprintf(screen_line+strlen(screen_line), "  in %s", ((breakpoint[i].in)[0]=='\0')?"(Unknown)":breakpoint[i].in);
+	sprintf(screen_hugoline, "  %6s:", PrintHex(breakpoint[i].addr));
+	sprintf(screen_hugoline+strlen(screen_hugoline), "  in %s", ((breakpoint[i].in)[0]=='\0')?"(Unknown)":breakpoint[i].in);
 
 	if (hard_copy)
 	{
-		debug_hardcopy(printer, screen_line);
+		debug_hardcopy(printer, screen_hugoline);
 		return;
 	}
 
-	memset(screen_line+strlen(screen_line), ' ', window[VIEW_BREAKPOINTS].width-strlen(screen_line));
-	screen_line[window[VIEW_BREAKPOINTS].width] = '\0';
+	memset(screen_hugoline+strlen(screen_hugoline), ' ', window[VIEW_BREAKPOINTS].width-strlen(screen_hugoline));
+	screen_hugoline[window[VIEW_BREAKPOINTS].width] = '\0';
 
 	if (i==window[VIEW_BREAKPOINTS].selected && active_window==VIEW_BREAKPOINTS)
 	{
@@ -497,7 +497,7 @@
 		debug_setbackcolor(color[NORMAL_BACK]);
 	}
 
-	debug_print(screen_line);
+	debug_print(screen_hugoline);
 }
 
 
@@ -510,24 +510,24 @@
 
 	indent = i-window[VIEW_CALLS].first;
 
-	memset(screen_line, ' ', indent);
-	sprintf(screen_line+indent, "%s", (r = RoutineName(call[i].addr)));
+	memset(screen_hugoline, ' ', indent);
+	sprintf(screen_hugoline+indent, "%s", (r = RoutineName(call[i].addr)));
 	
 	/* If this isn't a property routine or an event, print either "()"
 	   or "(...)" depending on whether any arguments were passed
 	   when the routine was called.
 	*/
 	if (strchr(r, '.')==NULL && strstr(r, "vent ")==NULL)
-		sprintf(screen_line+strlen(screen_line), "(%s)", (call[i].param)?"...":"");
+		sprintf(screen_hugoline+strlen(screen_hugoline), "(%s)", (call[i].param)?"...":"");
 
 	if (hard_copy)
 	{
-		debug_hardcopy(printer, screen_line);
+		debug_hardcopy(printer, screen_hugoline);
 		return;
 	}
 
-	memset(screen_line+strlen(screen_line), ' ', window[VIEW_BREAKPOINTS].width-strlen(screen_line));
-	screen_line[window[VIEW_BREAKPOINTS].width] = '\0';
+	memset(screen_hugoline+strlen(screen_hugoline), ' ', window[VIEW_BREAKPOINTS].width-strlen(screen_hugoline));
+	screen_hugoline[window[VIEW_BREAKPOINTS].width] = '\0';
 
 	if (i==window[VIEW_CALLS].selected && active_window==VIEW_CALLS)
 	{
@@ -545,7 +545,7 @@
 		debug_setbackcolor(color[NORMAL_BACK]);
 	}
 
-	debug_print(screen_line);
+	debug_print(screen_hugoline);
 }
 
 
@@ -571,12 +571,12 @@
 
 	if (hard_copy)
 	{
-		ConverttoChar(codeline[l], debug_line);
-		debug_hardcopy(printer, debug_line);
+		ConverttoChar(codehugoline[l], debug_hugoline);
+		debug_hardcopy(printer, debug_hugoline);
 		return;
 	}
 
-	int_print(codeline[l], printflag, horizontal, width);
+	int_print(codehugoline[l], printflag, horizontal, width);
 }
 
 
@@ -598,21 +598,21 @@
 	/* In case the local variable name has been blanked, likely by
 	   stepping backward
 	*/
-	sprintf(screen_line, "  %s : ", localname[i]);
-	strcpy(debug_line, "");
-	ReturnWatchValue(debug_line, var[MAXGLOBALS+i], local_view_type);
-	strcat(screen_line, debug_line);
+	sprintf(screen_hugoline, "  %s : ", localname[i]);
+	strcpy(debug_hugoline, "");
+	ReturnWatchValue(debug_hugoline, var[MAXGLOBALS+i], local_view_type);
+	strcat(screen_hugoline, debug_hugoline);
 
 	if (hard_copy)
 	{
-		debug_hardcopy(printer, screen_line);
+		debug_hardcopy(printer, screen_hugoline);
 		return;
 	}
 
-	memset(screen_line+strlen(screen_line), ' ', window[VIEW_LOCALS].width-strlen(screen_line));
-	screen_line[window[VIEW_LOCALS].width] = '\0';
+	memset(screen_hugoline+strlen(screen_hugoline), ' ', window[VIEW_LOCALS].width-strlen(screen_hugoline));
+	screen_hugoline[window[VIEW_LOCALS].width] = '\0';
 
-	debug_print(screen_line);	
+	debug_print(screen_hugoline);	
 }
 
 
@@ -643,7 +643,7 @@
 void PrintWatch(unsigned int w)
 {
 	char c[3];                      /* following character(s) */
-	char startofline = true;
+	char startofhugoline = true;
 	int pos = 0;
 	int val;
 	struct token_structure tok;
@@ -675,8 +675,8 @@
 	*/
 	while (watch[w].expr[pos]!=EOL_T)
 	{
-		tok = GetToken(mem, (long)arraytable*16L + (long)debug_workspace + (long)pos, startofline);
-		startofline = false;
+		tok = GetToken(mem, (long)arraytable*16L + (long)debug_workspace + (long)pos, startofhugoline);
+		startofhugoline = false;
 
 		strcat(watch_buffer, tok.token);
 		if (tok.following)
@@ -738,7 +738,7 @@
 	else
 		pos = 0;
 
-	/* Fill the rest of the line, if necessary, with spaces */
+	/* Fill the rest of the hugoline, if necessary, with spaces */
 	if (pos < win->width)
 	{
 		memset(watch_buffer, ' ', win->width);
@@ -782,50 +782,50 @@
 
 /* UPDATECODEWINDOW
 
-	Draws only the most recently buffered (i.e., unprinted) lines.
+	Draws only the most recently buffered (i.e., unprinted) hugolines.
 	A redraw of the entire code window can be forced by setting
-	buffered_code_lines to a number greater than the window height,
+	buffered_code_hugolines to a number greater than the window height,
 	e.g., FORCE_REDRAW.
 */
 
 void UpdateCodeWindow(void)
 {
-	unsigned int i, selected_line, pos, start, amount_to_scroll;
+	unsigned int i, selected_hugoline, pos, start, amount_to_scroll;
 	struct window_structure *win;
 	win = &window[CODE_WINDOW];     /* shorthand */
 
 	currently_updating = CODE_WINDOW;
 
-	if ((unsigned)buffered_code_lines > win->height)
+	if ((unsigned)buffered_code_hugolines > win->height)
 	{
 		start = (win->count > win->height)?win->count - win->height:0;
 
 		window[CODE_WINDOW].first = start;
 		UpdateFullCodeWindow(start, win->horiz, win->width);
-		buffered_code_lines = 0;
+		buffered_code_hugolines = 0;
 		return;
 	}
-	else if (buffered_code_lines==0) return;
+	else if (buffered_code_hugolines==0) return;
 
-	/* The next line to be printed */
-	selected_line = win->count - buffered_code_lines;
+	/* The next hugoline to be printed */
+	selected_hugoline = win->count - buffered_code_hugolines;
 
-	/* Unhighlight the old last-line highlight, if any */
-	if (selected_line > 0)
+	/* Unhighlight the old last-hugoline highlight, if any */
+	if (selected_hugoline > 0)
 	{
-		pos = win->top + win->count-1-buffered_code_lines;
+		pos = win->top + win->count-1-buffered_code_hugolines;
 		if (pos > win->top + win->height-1) pos = win->top + win->height-1;
 		debug_settextpos(2, pos);
-		PrintCodeLine(selected_line-1, win->horiz, win->width);
+		PrintCodeLine(selected_hugoline-1, win->horiz, win->width);
 	}
 
 	/* Scroll the existing window up if need be */
 	if (win->count > win->first + win->height)
 	{
-		if (win->count - (win->first+win->height) < (unsigned)buffered_code_lines)
+		if (win->count - (win->first+win->height) < (unsigned)buffered_code_hugolines)
 			amount_to_scroll = win->count - (win->first+win->height);
 		else
-			amount_to_scroll = buffered_code_lines;
+			amount_to_scroll = buffered_code_hugolines;
 
 		debug_windowscroll(2, win->top, 
 			D_SCREENWIDTH-1, win->top+win->height-1, UP, amount_to_scroll);
@@ -833,15 +833,15 @@
 		win->first += amount_to_scroll;
 	}
 
-	/* Now print the buffered lines */
-	for (i=0; buffered_code_lines>0; i++, buffered_code_lines--)
+	/* Now print the buffered hugolines */
+	for (i=0; buffered_code_hugolines>0; i++, buffered_code_hugolines--)
 	{
-		pos = win->top + min(win->height, win->count) - buffered_code_lines;
+		pos = win->top + min(win->height, win->count) - buffered_code_hugolines;
 		debug_settextpos(2, pos);
-		PrintCodeLine(selected_line+i, win->horiz, win->width);
+		PrintCodeLine(selected_hugoline+i, win->horiz, win->width);
 	}
 
-	buffered_code_lines = 0;
+	buffered_code_hugolines = 0;
 }
 
 
diff -Naur hugov3.1.03/source/hdval.c /usr/glenda/cursesif/hugo/source/hdval.c
--- hugov3.1.03/source/hdval.c	Fri Oct  9 18:12:02 2015
+++ /usr/glenda/cursesif/hugo/source/hdval.c	Thu Oct  1 02:31:39 2015
@@ -77,8 +77,8 @@
 
 	if ((w = window[VIEW_WATCH].count)==MAXWATCHES)
 	{
-		sprintf(debug_line, "Maximum of %d watch expressions", MAXWATCHES);
-		DebugMessageBox(t, debug_line);
+		sprintf(debug_hugoline, "Maximum of %d watch expressions", MAXWATCHES);
+		DebugMessageBox(t, debug_hugoline);
 		return;
 	}
 
@@ -165,7 +165,7 @@
 
 	Heisted (largely) from the compiler's HCBUILD.C.  If the token
 	is invalid, returns -1 and stores an appropriate error message
-	in the line array.  Otherwise, it returns the token code, and
+	in the hugoline array.  Otherwise, it returns the token code, and
 	stores the real value in z (if applicable).
 */
 
@@ -193,7 +193,7 @@
 			ReturnSymbol(DICTENTRY_T);
 		}
 		
-		sprintf(debug_line, "Not in dictionary:  \"%s\"", a);
+		sprintf(debug_hugoline, "Not in dictionary:  \"%s\"", a);
 		ReturnSymbol(-1);
 	}
 
@@ -223,7 +223,7 @@
 		i = atoi(a+6);
 		if (i<1 || i>MAXLOCALS)
 		{
-			sprintf(debug_line, "Local variable out of range:  %s", a);
+			sprintf(debug_hugoline, "Local variable out of range:  %s", a);
 			ReturnSymbol(-1);
 		}
 		else
@@ -241,7 +241,7 @@
 		{
 			if (last_symbol!=AMPERSAND_T)
 			{
-				sprintf(debug_line, "Routine call illegal in expression");
+				sprintf(debug_hugoline, "Routine call illegal in expression");
 				ReturnSymbol(-1);
 			}
 
@@ -303,7 +303,7 @@
 	if (a[0]=='\'')
 	{
 		if ((a[2]!='\'' && a[1]!='\\') || (a[1]=='\\' && a[3]!='\''))
-			{sprintf(debug_line, "Unknown ASCII value:  %s", a);
+			{sprintf(debug_hugoline, "Unknown ASCII value:  %s", a);
 			ReturnSymbol(-1);}
 		if (a[1]=='\\') token_val = toascii(a[2]);
 		else token_val = toascii(a[1]);
@@ -311,7 +311,7 @@
 	}
 
 	/* If we get here, then no match was made */
-	sprintf(debug_line, "Syntax error in expression:  %s", a);
+	sprintf(debug_hugoline, "Syntax error in expression:  %s", a);
 	ReturnSymbol(-1);
 }
 
@@ -396,7 +396,7 @@
 	for (i=0; i<(int)strlen(expr); i++)
 	{
 		/* Must be room for at least 3 more bytes (the largest any
-		   expression element will be) + 1 for end-of-line.
+		   expression element will be) + 1 for end-of-hugoline.
 		*/
 		if (m > debug_workspace+251)
 		{
@@ -427,7 +427,7 @@
 
 			if (size+i > (int)strlen(expr))
 			{
-				strcpy(debug_line, "Missing closing quote");
+				strcpy(debug_hugoline, "Missing closing quote");
 				goto PrintExpressionError;
 			}
 
@@ -449,12 +449,12 @@
 		tok = IDWord(expr+i);
 
 		/* If IDWord() returns -1, the token is invalid,
-		   and the line array holds the error message.
+		   and the hugoline array holds the error message.
 		*/
 		if (tok==-1)
 		{
 PrintExpressionError:
-			DebugMessageBox("Expression Error", debug_line);
+			DebugMessageBox("Expression Error", debug_hugoline);
 			return false;
 		}
 
diff -Naur hugov3.1.03/source/hdwindow.c /usr/glenda/cursesif/hugo/source/hdwindow.c
--- hugov3.1.03/source/hdwindow.c	Fri Oct  9 18:12:02 2015
+++ /usr/glenda/cursesif/hugo/source/hdwindow.c	Thu Oct  1 02:31:39 2015
@@ -148,24 +148,24 @@
 	saved_menu = debug_windowsave(menu_data[m].position-2, 2, 
 		menu_data[m].position+len+3, count+4);
 
-	/* Print top line of menu */
+	/* Print top hugoline of menu */
 	debug_settextpos(menu_data[m].position-2, 2);
-	debug_line[0] = TOP_LEFT;
-	memset(debug_line+1, HORIZONTAL_LINE, len+2);
-	sprintf(debug_line+len+3, "%c", TOP_RIGHT);
-	debug_print(debug_line);
+	debug_hugoline[0] = TOP_LEFT;
+	memset(debug_hugoline+1, HORIZONTAL_LINE, len+2);
+	sprintf(debug_hugoline+len+3, "%c", TOP_RIGHT);
+	debug_print(debug_hugoline);
 
-	/* Print each line of menu */
+	/* Print each hugoline of menu */
 	for (i=1; i<=count; i++)
 	{
 		debug_settextpos(menu_data[m].position-2, i+2);
 
 		if (menu[m][i][0]=='-')		/* separator */
 		{
-			debug_line[0] = HORIZONTAL_LEFT;
-			memset(debug_line+1, HORIZONTAL_LINE, len+2);
-			sprintf(debug_line+len+3, "%c", HORIZONTAL_RIGHT);
-			debug_print(debug_line);
+			debug_hugoline[0] = HORIZONTAL_LEFT;
+			memset(debug_hugoline+1, HORIZONTAL_LINE, len+2);
+			sprintf(debug_hugoline+len+3, "%c", HORIZONTAL_RIGHT);
+			debug_print(debug_hugoline);
 			menu_shortcut_keys[i] = 0;
 		}
 		else
@@ -174,12 +174,12 @@
 		}
 	}
 
-	/* Print bottom line of menu */
+	/* Print bottom hugoline of menu */
 	debug_settextpos(menu_data[m].position-2, 3+menu_data[m].items);
-	debug_line[0] = BOTTOM_LEFT;
-	memset(debug_line+1, HORIZONTAL_LINE, len+2);
-	sprintf(debug_line+len+3, "%c", BOTTOM_RIGHT);
-	debug_print(debug_line);
+	debug_hugoline[0] = BOTTOM_LEFT;
+	memset(debug_hugoline+1, HORIZONTAL_LINE, len+2);
+	sprintf(debug_hugoline+len+3, "%c", BOTTOM_RIGHT);
+	debug_print(debug_hugoline);
 }
 
 
@@ -530,22 +530,22 @@
 
 /* PRINTLINEANDCAPTION
 
-	Prints a horizontal line with the specified caption centered in
+	Prints a horizontal hugoline with the specified caption centered in
 	the middle.
 */
 
 void PrintLineandCaption(int row, char *a, int highlight)
 {
-	char *l;	/* since 'a' may be debug_line */
+	char *l;	/* since 'a' may be debug_hugoline */
 	l = strdup(a);
 	
 	debug_settextpos(2, row);
 
-	memset(debug_line, HORIZONTAL_LINE, D_SCREENWIDTH/2-strlen(l)/2-1);
-	debug_line[D_SCREENWIDTH/2-strlen(l)/2-1] = '\0';
+	memset(debug_hugoline, HORIZONTAL_LINE, D_SCREENWIDTH/2-strlen(l)/2-1);
+	debug_hugoline[D_SCREENWIDTH/2-strlen(l)/2-1] = '\0';
 	debug_settextcolor(color[NORMAL_TEXT]);
 	debug_setbackcolor(color[NORMAL_BACK]);
-	debug_print(debug_line);
+	debug_print(debug_hugoline);
 
 	if (highlight)
 	{
@@ -554,11 +554,11 @@
 	}
 	debug_print(l);
 
-	memset(debug_line, HORIZONTAL_LINE, D_SCREENWIDTH/2-strlen(l)/2-1);
-	debug_line[D_SCREENWIDTH/2-strlen(l)/2-1-strlen(l)%2] = '\0';
+	memset(debug_hugoline, HORIZONTAL_LINE, D_SCREENWIDTH/2-strlen(l)/2-1);
+	debug_hugoline[D_SCREENWIDTH/2-strlen(l)/2-1-strlen(l)%2] = '\0';
 	debug_settextcolor(color[NORMAL_TEXT]);
 	debug_setbackcolor(color[NORMAL_BACK]);
-	debug_print(debug_line);
+	debug_print(debug_hugoline);
 	
 	free(l);
 }
@@ -589,10 +589,10 @@
 /* If USE_OTHER_MENUS is #defined, "Press ALT [or whatever] for menu"
    isn't printed
 */
-	sprintf(debug_line, "Hugo Debugger v%d.%d%s", HEVERSION, HEREVISION, HEINTERIM);
-	while (pos++ <= D_SCREENWIDTH-strlen(debug_line)-1) debug_print(" ");
-	debug_print(debug_line);
-	pos+=strlen(debug_line)-1;
+	sprintf(debug_hugoline, "Hugo Debugger v%d.%d%s", HEVERSION, HEREVISION, HEINTERIM);
+	while (pos++ <= D_SCREENWIDTH-strlen(debug_hugoline)-1) debug_print(" ");
+	debug_print(debug_hugoline);
+	pos+=strlen(debug_hugoline)-1;
 #endif
 	while (pos++ <= D_SCREENWIDTH) debug_print(" ");
 
@@ -670,43 +670,43 @@
 	debug_settextcolor(color[NORMAL_TEXT]);
 	debug_setbackcolor(color[NORMAL_BACK]);
 
-	/* print vertical lines */
-	sprintf(debug_line, "%c", VERTICAL_LINE);
+	/* print vertical hugolines */
+	sprintf(debug_hugoline, "%c", VERTICAL_LINE);
 	for (i=3; i<D_SCREENHEIGHT-1; i++)
 	{
 		if (i==D_SEPARATOR) continue;
 
 		debug_settextpos(1, i);
-		debug_print(debug_line);
+		debug_print(debug_hugoline);
 		debug_settextpos(D_SCREENWIDTH, i);
-		debug_print(debug_line);
+		debug_print(debug_hugoline);
 	}
 
 	/* print corners */
-	sprintf(debug_line, "%c", TOP_LEFT);
+	sprintf(debug_hugoline, "%c", TOP_LEFT);
 	debug_settextpos(1, 2);
-	debug_print(debug_line);
-	sprintf(debug_line, "%c", TOP_RIGHT);
+	debug_print(debug_hugoline);
+	sprintf(debug_hugoline, "%c", TOP_RIGHT);
 	debug_settextpos(D_SCREENWIDTH, 2);
-	debug_print(debug_line);
-	sprintf(debug_line, "%c", HORIZONTAL_LEFT);
+	debug_print(debug_hugoline);
+	sprintf(debug_hugoline, "%c", HORIZONTAL_LEFT);
 	debug_settextpos(1, D_SEPARATOR);
-	debug_print(debug_line);
-	sprintf(debug_line, "%c", HORIZONTAL_RIGHT);
+	debug_print(debug_hugoline);
+	sprintf(debug_hugoline, "%c", HORIZONTAL_RIGHT);
 	debug_settextpos(D_SCREENWIDTH, D_SEPARATOR);
-	debug_print(debug_line);
-	sprintf(debug_line, "%c", BOTTOM_LEFT);
+	debug_print(debug_hugoline);
+	sprintf(debug_hugoline, "%c", BOTTOM_LEFT);
 	debug_settextpos(1, D_SCREENHEIGHT-1);
-	debug_print(debug_line);
-	sprintf(debug_line, "%c", BOTTOM_RIGHT);
+	debug_print(debug_hugoline);
+	sprintf(debug_hugoline, "%c", BOTTOM_RIGHT);
 	debug_settextpos(D_SCREENWIDTH, D_SCREENHEIGHT-1);
-	debug_print(debug_line);
+	debug_print(debug_hugoline);
 
 	/* non-code window */
-	strcpy(debug_line, menu[MENU_VIEW/0x10-1][active_view]);
+	strcpy(debug_hugoline, menu[MENU_VIEW/0x10-1][active_view]);
 	if (active_view==VIEW_LOCALS)
 	{
-		strcat(debug_line, " (as ");
+		strcat(debug_hugoline, " (as ");
 		switch (local_view_type)
 		{
 			case VALUE_T:
@@ -726,23 +726,23 @@
 			default:
 				{a = "UNDEFINED)"; break;}
 		}
-		strcat(debug_line, a);
+		strcat(debug_hugoline, a);
 	}
-	for (i=0; i<(int)strlen(debug_line); i++)
+	for (i=0; i<(int)strlen(debug_hugoline); i++)
 	{
-		if (debug_line[i]=='&')
+		if (debug_hugoline[i]=='&')
 		{
-			for (j=i; j<(int)strlen(debug_line); j++)
-				debug_line[j] = debug_line[j+1];
+			for (j=i; j<(int)strlen(debug_hugoline); j++)
+				debug_hugoline[j] = debug_hugoline[j+1];
 			goto ErasedAmpersand;
 		}
 	}
 ErasedAmpersand:
-	PrintLineandCaption(2, debug_line, (active_window!=CODE_WINDOW));
+	PrintLineandCaption(2, debug_hugoline, (active_window!=CODE_WINDOW));
 
 	/* Code window */
-	sprintf(debug_line, "Current:  %s", RoutineName(currentroutine));
-	PrintLineandCaption(D_SEPARATOR, debug_line, (active_window==CODE_WINDOW));
+	sprintf(debug_hugoline, "Current:  %s", RoutineName(currentroutine));
+	PrintLineandCaption(D_SEPARATOR, debug_hugoline, (active_window==CODE_WINDOW));
 
 	/* bottom of Code window */
 	PrintLineandCaption(D_SCREENHEIGHT-1, "", 0);
@@ -762,8 +762,8 @@
 	debug_settextcolor(color[MENU_TEXT]);
 	debug_setbackcolor(color[MENU_BACK]);
 
-	sprintf(debug_line, "%c", VERTICAL_LINE);
-	debug_print(debug_line);
+	sprintf(debug_hugoline, "%c", VERTICAL_LINE);
+	debug_print(debug_hugoline);
 
 	if (highlight)
 	{
@@ -776,14 +776,14 @@
 	if (highlight) context_help = menu[m][i];
 
 	menu_shortcut_keys[i] = PrintMenuItem(menu[m][i], true, highlight);
-	memset(debug_line, ' ', menu_data[m].longest-strlen(menu[m][i])+3);
-	debug_line[menu_data[m].longest-strlen(menu[m][i])+2] = '\0';
-	debug_print(debug_line);
+	memset(debug_hugoline, ' ', menu_data[m].longest-strlen(menu[m][i])+3);
+	debug_hugoline[menu_data[m].longest-strlen(menu[m][i])+2] = '\0';
+	debug_print(debug_hugoline);
 
 	debug_settextcolor(color[MENU_TEXT]);
 	debug_setbackcolor(color[MENU_BACK]);
-	sprintf(debug_line, "%c", VERTICAL_LINE);
-	debug_print(debug_line);
+	sprintf(debug_hugoline, "%c", VERTICAL_LINE);
+	debug_print(debug_hugoline);
 }
 
 
@@ -822,7 +822,7 @@
 	/* height = title + 1 + caption + 2 + visible choices + 1 */
 	height = 6 + visible;
 
-	/* Make space for the "Sample Text" line, if this is a
+	/* Make space for the "Sample Text" hugoline, if this is a
 	   color selection box
 	*/
 	if (selecting_color) height+=2;
@@ -840,11 +840,11 @@
 	DrawBox(y, y+height+1, x, x+width+1, color[MENU_TEXT], color[MENU_BACK]);
 
 	/* Draw separator */
-	debug_line[0] = HORIZONTAL_LEFT;
-	memset(debug_line+1, HORIZONTAL_LINE, width);
-	sprintf(debug_line+width+1, "%c", HORIZONTAL_RIGHT);
+	debug_hugoline[0] = HORIZONTAL_LEFT;
+	memset(debug_hugoline+1, HORIZONTAL_LINE, width);
+	sprintf(debug_hugoline+width+1, "%c", HORIZONTAL_RIGHT);
 	debug_settextpos(x, y+4);
-	debug_print(debug_line);
+	debug_print(debug_hugoline);
 
 	debug_settextpos(x+2, y+3);
 	debug_print("Select:");
@@ -878,11 +878,11 @@
 		if (first+i > n) a = "";
 		else a = choice[first+i];
 
-		/* create line padded w/spaces */
-		memset(debug_line, ' ', width);
-		debug_line[width] = '\0';
-                sprintf(debug_line, " %s", a);
-		debug_line[strlen(debug_line)] = ' ';
+		/* create hugoline padded w/spaces */
+		memset(debug_hugoline, ' ', width);
+		debug_hugoline[width] = '\0';
+                sprintf(debug_hugoline, " %s", a);
+		debug_hugoline[strlen(debug_hugoline)] = ' ';
 
 		if (this==first+i)
 		{
@@ -895,7 +895,7 @@
 			debug_setbackcolor(color[MENU_BACK]);
 		}
 		debug_settextpos(x+1, y+6+i);
-		debug_print(debug_line);
+		debug_print(debug_hugoline);
 	}
 
 	/* endless loop */
@@ -1006,14 +1006,14 @@
 }
 
 
-int saved_currentline = 0;
+int saved_currenthugoline = 0;
 
 
 /* SWITCHTODEBUGGER */
 
 void SwitchtoDebugger(void)
 {
-	saved_currentline = currentline;
+	saved_currenthugoline = currenthugoline;
 
 	debug_switchscreen(DEBUGGER);
 	active_screen = DEBUGGER;
@@ -1030,7 +1030,7 @@
 
 void SwitchtoGame(void)
 {
-	currentline = saved_currentline;
+	currenthugoline = saved_currenthugoline;
 
 	HighlightCurrent(0);
 	debug_switchscreen(GAME);
diff -Naur hugov3.1.03/source/he.c /usr/glenda/cursesif/hugo/source/he.c
--- hugov3.1.03/source/he.c	Fri Oct  9 18:12:02 2015
+++ /usr/glenda/cursesif/hugo/source/he.c	Thu Oct  1 02:31:39 2015
@@ -39,8 +39,8 @@
 /* "display" object properties */
 const int screenwidth = 1;
 const int screenheight = 2;
-const int linelength = 3;
-const int windowlines = 4;
+const int hugolinelength = 3;
+const int windowhugolines = 4;
 const int cursor_column = 5;
 const int cursor_row = 6;
 const int hasgraphics = 7;
@@ -87,7 +87,7 @@
 	SRANDOM((unsigned int)time((time_t *)&seed));
 #endif
 
-#if !defined (GLK)	/* no command line under Glk */
+#if !defined (GLK)	/* no command hugoline under Glk */
 	ParseCommandLine(argc, argv);
 #endif
 
diff -Naur hugov3.1.03/source/heblank.c /usr/glenda/cursesif/hugo/source/heblank.c
--- hugov3.1.03/source/heblank.c	Fri Oct  9 18:12:02 2015
+++ /usr/glenda/cursesif/hugo/source/heblank.c	Thu Oct  1 02:31:39 2015
@@ -13,7 +13,7 @@
 		hugo_closefiles         hugo_settextcolor
 					hugo_setbackcolor
 		hugo_getkey             hugo_color
-		hugo_getline
+		hugo_gethugoline
 		hugo_waitforkey         hugo_print
 		hugo_iskeywaiting	hugo_charwidth
 		hugo_timewait		hugo_textwidth
@@ -41,12 +41,14 @@
 #include "heheader.h"
 
 /* For the stdio version, the ARBITRARY_SCREEN_WIDTH must be equal
-   to the width of the target text display in order for proper line-
-   wrapping (since printf() wraps the line automatically at the
+   to the width of the target text display in order for proper hugoline-
+   wrapping (since printf() wraps the hugoline automatically at the
    right edge)
 */
 #define ARBITRARY_SCREEN_WIDTH 80
 #define ARBITRARY_SCREEN_HEIGHT 24
+#define STAT_UNAVAILABLE	((short)-1)
+
 
 
 /* Function prototypes: */
@@ -77,7 +79,7 @@
 #define HUGO_BRIGHT_WHITE  15
 
 /* Since we provide our own command history: */
-#define HISTORY_SIZE    16              /* for command-line editing */
+#define HISTORY_SIZE    16              /* for command-hugoline editing */
 int hcount = 0;
 char *history[HISTORY_SIZE];
 
@@ -178,7 +180,7 @@
 /* hugo_getfilename
 
     Loads the name of the filename to save or restore (as specified by
-    the argument <a>) into the line[] array.
+    the argument <a>) into the hugoline[] array.
 
     The reason this is in the system-specific file is because it may be
     preferable to replace it with, for example, a dialog-based file
@@ -189,12 +191,12 @@
 {
 	unsigned int i, p;
 
-	sprintf(line, "Enter path and filename %s.", a);
+	sprintf(hugoline, "Enter path and filename %s.", a);
 
-	AP(line);
+	AP(hugoline);
 
-	sprintf(line,"%c(Default is %s): \\;", NO_CONTROLCHAR, b);
-	AP(line);
+	sprintf(hugoline,"%c(Default is %s): \\;", NO_CONTROLCHAR, b);
+	AP(hugoline);
 
 	p = var[prompt];
 	var[prompt] = 0;        /* null string */
@@ -205,13 +207,13 @@
 
 	remaining = 0;
 
-	strcpy(line, "");
+	strcpy(hugoline, "");
 	if (words==0)
-		strcpy(line, b);
+		strcpy(hugoline, b);
 	else
 	{
 		for (i=1; i<=(unsigned int)words; i++)
-			strcat(line, word[i]);
+			strcat(hugoline, word[i]);
 	}
 }
 
@@ -306,12 +308,12 @@
 }
 
 
-/* hugo_getline
+/* hugo_gethugoline
 
-    Gets a line of input from the keyboard, storing it in <buffer>.
+    Gets a hugoline of input from the keyboard, storing it in <buffer>.
 */
 
-void hugo_getline(char *p)
+void hugo_gethugoline(char *p)
 {
 	/* stdio implementation */
 	hugo_print(p);
@@ -379,10 +381,10 @@
 
    The currently selected font's width and height:
 
-	charwidth, lineheight
+	charwidth, hugolineheight
 
    The non-proportional/fixed-width font's width and height (i.e., equal
-   to charwidth and lineheight when the current font is the fixed-width
+   to charwidth and hugolineheight when the current font is the fixed-width
    font):
 
 	FIXEDCHARWIDTH, FIXEDLINEHEIGHT
@@ -390,7 +392,7 @@
    Must be set by hugo_settextpos(), hugo_clearfullscreen(), and
    hugo_clearwindow():
 
-	currentpos, currentline
+	currentpos, currenthugoline
 */
 
 void hugo_init_screen(void)
@@ -428,7 +430,7 @@
 	
 	/* Must be set: */
 	currentpos = 0;
-	currentline = 1;
+	currenthugoline = 1;
 }
 
 void hugo_clearwindow(void)
@@ -440,7 +442,7 @@
 
 	/* Must be set: */
 	currentpos = 0;
-	currentline = 1;
+	currenthugoline = 1;
 }
 
 void hugo_settextmode(void)
@@ -471,14 +473,14 @@
 	Then set:
 	
 	charwidth = current font width, in pixels or 1
-	lineheight = current font height, in pixels or 1
+	hugolineheight = current font height, in pixels or 1
 
-	Both charwidth and lineheight must change dynamically if the
+	Both charwidth and hugolineheight must change dynamically if the
 	metrics for the currently selected font change
 */
 
 	/* stdio implementation: */
-	charwidth = lineheight = FIXEDCHARWIDTH = FIXEDLINEHEIGHT = 1;
+	charwidth = hugolineheight = FIXEDCHARWIDTH = FIXEDLINEHEIGHT = 1;
 	SCREENWIDTH = ARBITRARY_SCREEN_WIDTH;
 	SCREENHEIGHT = ARBITRARY_SCREEN_HEIGHT;
 
@@ -507,10 +509,10 @@
 	
 	/* No window setting under stdio, but print a separator: */
 #ifndef NO_STDIO_WINDOWS
-	line[0] = '\n';
-	memset(line+1, '-', ARBITRARY_SCREEN_WIDTH);
-	line[ARBITRARY_SCREEN_WIDTH+1] = '\0';
-	printf(line);
+	hugoline[0] = '\n';
+	memset(hugoline+1, '-', ARBITRARY_SCREEN_WIDTH);
+	hugoline[ARBITRARY_SCREEN_WIDTH+1] = '\0';
+	printf(hugoline);
 #endif
 
 	/* Must be set: */
@@ -547,8 +549,8 @@
 
    All cursor-location is based on FIXEDCHARWIDTH and FIXEDLINEHEIGHT.
 
-   This function must also properly set currentline and currentpos (where
-   currentline is a the current character line, and currentpos may be
+   This function must also properly set currenthugoline and currentpos (where
+   currenthugoline is a the current character hugoline, and currentpos may be
    either in pixels or characters, depending on the measure being used).
 
    Note that the Hugo function call uses x and y directly as text-
@@ -562,7 +564,7 @@
 	if (inwindow) printf(" ");
 
 	/* Must be set: */
-	currentline = y;
+	currenthugoline = y;
 	currentpos = (x-1)*charwidth;   /* Note:  zero-based */
 }
 
@@ -572,10 +574,10 @@
    generally doesn't take into account color setting, font changes,
    windowing, etc.
 
-   The newline character '\n' must be explicitly included at the end of
-   a line in order to produce a linefeed.  The new cursor position is set
+   The newhugoline character '\n' must be explicitly included at the end of
+   a hugoline in order to produce a hugolinefeed.  The new cursor position is set
    to the end of this printed text.  Upon hitting the right edge of the
-   screen, the printing position wraps to the start of the next line.
+   screen, the printing position wraps to the start of the next hugoline.
 */
 
 	/* Output <a>, taking into account fore/background color,
@@ -591,7 +593,7 @@
 
 void hugo_scrollwindowup()
 {
-	/* Scroll the current text window up one line */
+	/* Scroll the current text window up one hugoline */
 	
 	/* stdio implementation */
 	printf("\n");
@@ -602,7 +604,7 @@
 /* The <f> argument is a mask containing any or none of:
    BOLD_FONT, UNDERLINE_FONT, ITALIC_FONT, PROP_FONT.
 
-   If charwidth and lineheight change with a font change, these must be
+   If charwidth and hugolineheight change with a font change, these must be
    reset here as well.
 */
 
diff -Naur hugov3.1.03/source/hebuffer.c /usr/glenda/cursesif/hugo/source/hebuffer.c
--- hugov3.1.03/source/hebuffer.c	Fri Oct  9 18:12:02 2015
+++ /usr/glenda/cursesif/hugo/source/hebuffer.c	Thu Oct  1 02:31:39 2015
@@ -361,7 +361,7 @@
 
 		/* Remove first the cells which will be scrolled away */
 		if (TB_InBounds(i, physical_windowleft, physical_windowtop,
-			physical_windowright, physical_windowtop+lineheight/2))
+			physical_windowright, physical_windowtop+hugolineheight/2))
 		{
 #ifdef TB_DEBUG
 			printf("TB_Scroll(): ");
@@ -370,14 +370,14 @@
 		}
 
 		/* Then scroll up the remaining cells */
-		if (TB_InBounds(i, physical_windowleft, physical_windowtop+lineheight,
+		if (TB_InBounds(i, physical_windowleft, physical_windowtop+hugolineheight,
 			physical_windowright, physical_windowbottom))
 		{
 #ifdef TB_DEBUG
 //			printf("TB_Scroll(): scrolling tb_list[%d]: '%s'\n", i, tb_list[i].data);
 #endif
-			tb_list[i].top -= lineheight;
-			tb_list[i].bottom -= lineheight;
+			tb_list[i].top -= hugolineheight;
+			tb_list[i].bottom -= hugolineheight;
 			
 			/* Don't scroll areas into the invalidation zone until the
 			   bottom is invalidated
diff -Naur hugov3.1.03/source/heexpr.c /usr/glenda/cursesif/hugo/source/heexpr.c
--- hugov3.1.03/source/heexpr.c	Fri Oct  9 18:12:02 2015
+++ /usr/glenda/cursesif/hugo/source/heexpr.c	Thu Oct  1 02:31:39 2015
@@ -125,15 +125,15 @@
 				if (next_prec >= last_precedence)
 				{
 #if defined (DEBUG_PRECEDENCE)
-sprintf(line, "Not preferring %s to %s because of previous level %d", token[eval[p+7]], token[oper], last_precedence);
-Printout(line);
+sprintf(hugoline, "Not preferring %s to %s because of previous level %d", token[eval[p+7]], token[oper], last_precedence);
+Printout(hugoline);
 #endif
 					goto ReturnResult;
 				}
 
 #if defined (DEBUG_PRECEDENCE)
-sprintf(line, "Preferring %s to %s", token[eval[p+7]], token[oper]);
-Printout(line);
+sprintf(hugoline, "Preferring %s to %s", token[eval[p+7]], token[oper]);
+Printout(hugoline);
 #endif
 
 				temp_lp = last_precedence;
@@ -148,8 +148,8 @@
 		}
 
 #if defined (DEBUG_PRECEDENCE)
-sprintf(line, "Solving %d %s %d", n1, token[oper], n2);
-Printout(line);
+sprintf(hugoline, "Solving %d %s %d", n1, token[oper], n2);
+Printout(hugoline);
 #endif
 
 		switch (oper)
@@ -258,7 +258,7 @@
 
 
 	/* Keep looping while there are expression elements, or until there
-	   is a ")", "]", or end of line
+	   is a ")", "]", or end of hugoline
 	*/
 	} while ((evalcount>p+2) && !(eval[p+2]==1 &&
 		(eval[p+3]==CLOSE_BRACKET_T || eval[p+3]==CLOSE_SQUARE_T ||
@@ -273,8 +273,8 @@
 #if defined (DEBUG_EXPR_EVAL)
 	if (p==0 && exprt)
 	{
-		sprintf(line, " = %d", result);
-		AP(line);
+		sprintf(hugoline, " = %d", result);
+		AP(hugoline);
 	}
 #endif
 	return result;
@@ -404,7 +404,7 @@
 
 			if (game_version >= 22)
 			{
-				/* Pre-v2.4 included linelength and pagelength as
+				/* Pre-v2.4 included hugolinelength and pagelength as
 				   global variables after objectcount
 				*/
 				if (i <= ((game_version>=24)?objectcount:objectcount+2))
@@ -422,7 +422,7 @@
 #endif
 					}
 					else if (i==objectcount+2)
-						val = SCREENHEIGHT/lineheight;
+						val = SCREENHEIGHT/hugolineheight;
 				}
 			}
 			codeptr++;
@@ -1023,8 +1023,8 @@
 	if (t && debug_eval)
 	{
 		debug_eval_error = true;
-		sprintf(debug_line, "'%s%s' illegal in watch/assignment", token[a], token[MEM(addr+1)]);
-		DebugMessageBox("Expression Error", debug_line);
+		sprintf(debug_hugoline, "'%s%s' illegal in watch/assignment", token[a], token[MEM(addr+1)]);
+		DebugMessageBox("Expression Error", debug_hugoline);
 		t = 0;
 	}
 #endif
@@ -1093,8 +1093,8 @@
 		{
 			case 0:
 			{
-				sprintf(line, "%d ", eval[i + 1]);
-				strcat(e, line);
+				sprintf(hugoline, "%d ", eval[i + 1]);
+				strcat(e, hugoline);
 				break;
 			}
 			case 1:
@@ -1107,8 +1107,8 @@
 				if (token[eval[i+1]][0]=='~')
 					strcat(e, "\\");
 				if (eval[i+1] != 255)
-					{sprintf(line, "%s ", token[eval[i+1]]);
-					strcat(e, line);}
+					{sprintf(hugoline, "%s ", token[eval[i+1]]);
+					strcat(e, hugoline);}
 				break;
 			}
 		}
diff -Naur hugov3.1.03/source/hegcc.c /usr/glenda/cursesif/hugo/source/hegcc.c
--- hugov3.1.03/source/hegcc.c	Thu Jan  1 00:00:00 1970
+++ /usr/glenda/cursesif/hugo/source/hegcc.c	Thu Oct  1 02:31:39 2015
@@ -0,0 +1,1303 @@
+/*
+	HEGCC.C (by Bill Lash lash@tellabs.com)
+
+	(revised for Hugo v2.5.x by Kent Tessman)
+
+	Non-portable functions specific to GCC and UNIX
+
+	This file provides the user interface functions specific
+	to the port, as well as some file handling and allocation
+	routines.
+
+	This version finally gets a lot of the screen handling issues
+	of the previous ports working properly.  In prior versions,
+	the title at the top of the help menus was not being shown
+	properly.  I also finally got around to adding color to the
+	port when using ncurses (the color handling can be enabled
+	and disabled in the makefile.gcc by setting the DO_COLOR 
+	define).
+
+	Kent added a few features to Hugo that affected the port as
+	well.  The first is ability to specify bold, italic, underhugoline
+	and proportional fonts.  This port supports bold, underhugoline,
+	and italic (italic is indicated as reverse video).  No support
+	is provided here for proportional fonts.
+
+	Kent also added support for special characters (such as characters
+	with umlauts, cedilla, the British pound sign, etc).  I have
+	added the support to this port.  It seems to work ok as long
+	as the terminal supports these characters.  I use xterms with
+	the fixed font at work, and there the fixed font does not contain
+	these special characters.  However, if I use the courier font
+	the characters do exist.  Under Linux at home, both fonts have
+	the special characters.  If you want to compile without support
+	for these characters, you may remove the define for DO_SPECIAL
+	in the makefile.gcc.
+*/
+#include <stdlib.h>
+
+#include "heheader.h"
+
+#ifdef NCURSES
+#include <ncurses.h>
+#else
+#include <curses.h>
+#endif
+
+/* Function prototypes: */
+void hugo_addcommand(void);
+void hugo_restorecommand(int);
+int hugo_color(int c);
+
+/* Specific to hegcc.c: */
+void ResetXtermDimensions(void);
+void ConstrainCursor(void);
+
+/* Defined Hugo colors: */
+#define HUGO_BLACK 	   0
+#define HUGO_BLUE	   1
+#define HUGO_GREEN	   2
+#define HUGO_CYAN	   3
+#define HUGO_RED	   4
+#define HUGO_MAGENTA	   5
+#define HUGO_BROWN	   6
+#define HUGO_WHITE	   7
+#define HUGO_DARK_GRAY	   8
+#define HUGO_LIGHT_BLUE	   9
+#define HUGO_LIGHT_GREEN   10
+#define HUGO_LIGHT_CYAN	   11
+#define HUGO_LIGHT_RED	   12
+#define HUGO_LIGHT_MAGENTA 13
+#define HUGO_YELLOW	   14
+#define HUGO_BRIGHT_WHITE  15
+
+
+#define HISTORY_SIZE    16      /* for command-hugoline editing */
+int hcount = 0;
+char *history[HISTORY_SIZE];
+
+WINDOW *current_window;
+
+/* Now some variables and constants to manage text/graphics display--
+   all specific to hegcc.c (taken from hedjgpp.c):
+*/
+int text_windowleft, text_windowtop, text_windowright, text_windowbottom,
+	text_windowwidth;
+int insert_mode = true;
+int print_cursor = false;       /* probably never be needed */
+int current_text_col, current_text_row, current_text_color, current_back_color;
+
+
+/*
+    MEMORY ALLOCATION:
+
+    hugo_blockalloc(), and hugo_blockfree() are necessary because of
+    the way MS-DOS handles memory allocation across more than 64K.
+    For most systems, these will simply be normal ANSI function calls.
+*/
+
+void *hugo_blockalloc(long num)
+{
+        return malloc(num * sizeof(char));
+}
+
+void hugo_blockfree(void *block)
+{
+        free(block);
+}
+
+
+/*
+    FILENAME MANAGEMENT:
+
+    Different operating systems will have their own ways of naming
+    files.  The following routines are simply required to know and
+    be able to dissect/build the components of a particular filename,
+    storing/restoring the compenents via the specified char arrays.
+
+    For example, in MS-DOS:
+
+        hugo_splitpath("C:\HUGO\FILES\HUGOLIB.H", ...)
+                becomes:  C:, HUGO\FILES, HUGOLIB, H
+
+    and
+
+        hugo_makepath(..., "C:", "HUGO\FILES", "HUGOLIB", "H")
+                becomes:  C:\HUGO\FILES\HUGOLIB.H
+
+    The appropriate equivalent nomenclature should be used for the
+    operating system in question.
+*/
+
+void hugo_splitpath(char *path, char *drive, char *dir, char *fname, char *ext)
+{
+char *file;
+char *extension;
+
+        strcpy(drive,"");
+        strcpy(dir,"");
+        strcpy(fname,"");
+        strcpy(ext,"");
+
+        if ((file = strrchr(path,'/')) == 0)
+        {
+                if ((file = strrchr(path,':')) == 0) file = path;
+        }
+        strncpy(dir,path,strlen(path)-strlen(file));
+        *(dir+strlen(path)-strlen(file)) = 0;
+        extension = strrchr(path,'.');
+        if ((extension != 0) && strlen(extension) < strlen(file))
+        {
+                strncpy(fname,file,strlen(file)-strlen(extension));
+                *(fname+strlen(file)-strlen(extension)) = 0;
+                strcpy(ext,extension+1);
+        }
+        else strcpy(fname,file);
+
+        if (strcmp(dir, "") && fname[0]=='/') strcpy(fname, fname+1);
+}
+
+void hugo_makepath(char *path, char *drive, char *dir, char *fname, char *ext)
+{
+        if (*ext == '.') ext++;
+        strcpy(path,drive);
+        strcat(path,dir);
+        switch (*(path+strlen(path)))
+        {
+        case '/':
+        case ':':
+/*        case 0: */
+                break;
+        default:
+                if (strcmp(path, "")) strcat(path,"/");
+                break;
+        }
+        strcat(path,fname);
+        if (strcmp(ext, "")) strcat(path,".");
+/* Crashes without -fwritable-strings:
+        strcat(path,strlwr(ext)); */
+	strcat(path, ext);
+}
+
+
+/*
+    OVERWRITE:
+
+    Checks to see if the given filename already exists, and prompts to
+    replace it.  Returns true if file may be overwritten.
+*/
+
+int hugo_overwrite(char *f)
+{
+	FILE *tempfile;
+
+	if (!(tempfile = fopen(f, "rb")))	/* if file doesn't exist */
+		return true;
+
+	fclose(tempfile);
+
+	sprintf(pbuffer, "Overwrite existing \"%s\" (Y or N)?", f);
+	RunInput();
+
+	if (words==1 && (!strcmp(strupr(word[1]), "Y") || !strcmp(strupr(word[1]), "YES")))
+		return true;
+
+	return false;
+}
+
+
+/*
+    CLOSEFILES:
+
+    Closes all open files.  NOTE:  If the operating system automatically
+    closes any open streams upon exit from the program, this function may
+    be left empty.
+*/
+
+void hugo_closefiles()
+{
+/*
+        fclose(game);
+  	if (script) fclose(script);
+  	if (io) fclose(io);
+  	if (record) fclose(record);
+*/
+}
+
+
+/*
+    GETFILENAME:
+
+    Loads the name of the filename to save or restore (as specified by
+    the argument <a>) into the hugoline[] array.
+*/
+
+void hugo_getfilename(char *a, char *b)
+{
+	unsigned int i, p;
+
+	sprintf(hugoline, "Enter path and filename %s.", a);
+	AP(hugoline);
+
+	sprintf(hugoline,"%c(Default is %s): \\;", NO_CONTROLCHAR, b);
+	AP(hugoline);
+
+	p = var[prompt];
+	var[prompt] = 0;        /* null string */
+
+	RunInput();
+
+	var[prompt] = p;
+
+	remaining = 0;
+
+	strcpy(hugoline, "");
+	if (words==0)
+		strcpy(hugoline, b);
+	else
+	{
+		for (i=1; i<=(unsigned int)words; i++)
+			strcat(hugoline, word[i]);
+	}
+}
+
+
+/*
+    GETKEY:
+
+    Returns the next keystroke waiting in the keyboard buffer.  It is
+    expected that hugo_getkey() will return the following modified
+    keystrokes:
+
+	up-arrow        11 (CTRL-K)
+	down-arrow      10 (CTRL-J)
+	left-arrow       8 (CTRL-H)
+	right-arrow     21 (CTRL-U)
+
+    Also, accented characters are converted to non-accented characters.
+    Invalid keystrokes are returned as 255.
+*/
+
+int hugo_getkey(void)
+{
+	int b;
+
+        /*
+         * In case this is used in halfdelay() or nodelay() mode
+         * need to make sure we don't pass bad data to gethugoline()
+         */
+        while ((b = getch())==ERR)
+        {
+        }
+
+	switch (b)
+	{
+		case KEY_UP:
+			{b = 11; break;}
+		case KEY_LEFT:
+			{b = 8; break;}
+		case KEY_RIGHT:
+			{b = 21; break;}
+		case KEY_DOWN:
+			{b = 10; break;}
+			
+		case (21):	/* Ctrl+U */
+			{b = 27; break;}
+	}
+        return b;
+}
+
+/*
+    GETLINE
+
+    Gets a hugoline of input from the keyboard, storing it in <buffer>.
+
+    (NOTE:  The function keys used here are QuickC/MS-DOS specific.
+    They have been chosen to somewhat mirror the command-hugoline editing
+    keys of MS-DOS.  For other systems, the 'if (b==<value>)' hugolines
+    will likely need to be changed.)
+
+    If a similar library input function is available, it will almost
+    certainly be preferable to use that; in QuickC such was unfortunately
+    not the case.
+
+    Note also that this input function assumes a non-proportional font.
+*/
+
+#define CURRENT_CHAR(c) ((c<(int)strlen(buffer))?buffer[c]:' ')
+
+void hugo_gethugoline(char *p)
+{
+	char ch[2];
+	int a, b, thiscommand;
+	int c;                          /* c is the character being added */
+	int x, y, oldx, oldy;
+
+NewPrompt:
+	hugo_settextcolor(fcolor);
+	hugo_setbackcolor(bgcolor);
+
+	strcpy(buffer, "");
+	c = 0;
+	thiscommand = hcount;
+
+	oldx = (currentpos+charwidth)/charwidth;
+	oldy = currenthugoline;
+	y = oldy;
+	x = oldx + hugo_strlen(p);
+
+	hugo_print(p);
+
+GetKey:
+
+	hugo_settextpos(x, y);
+
+	b = hugo_getkey();
+
+	hugo_settextcolor(icolor);
+	hugo_setbackcolor(bgcolor);
+
+	/* Now, start key checking */
+	switch (b)
+	{
+
+		case (10):                      /* Enter */
+	        case KEY_ENTER:
+		{
+			hugo_settextpos(x, y);
+			sprintf(ch, "%c", CURRENT_CHAR(c));
+			hugo_print(ch);
+			full = 0;
+
+			if (script) fprintf(script, "%s%s\n", p, buffer);
+
+			hugo_settextpos(1, y + 2);
+			if (y >= physical_windowheight/hugolineheight - 1)
+				hugo_scrollwindowup();
+
+			strcpy(buffer, Rtrim(buffer));
+			hugo_addcommand();
+//#if defined (NO_LATIN1_CHARSET)
+//			hugo_stripaccents(buffer);
+//#endif
+			return;
+		}
+	        case KEY_IC:    /* Insert */
+		{
+			insert_mode = !insert_mode;
+			goto GetKey;
+		}
+	        case KEY_BACKSPACE:
+	        case KEY_DC:
+	        case (127):
+	        case (4):	/* Ctrl+D */
+		{
+			if (strlen(buffer)>0)
+			{
+				if (b==KEY_BACKSPACE || c==strlen(buffer))
+				{
+					b = KEY_BACKSPACE;
+					if (c==0) goto GetKey;
+					c--;
+				}
+
+				buffer[strlen(buffer)+1] = '\0';
+				for (a=c; a<=(int)strlen(buffer); a++)
+					buffer[a] = buffer[a+1];
+
+				if (b==KEY_BACKSPACE) x--;
+
+				hugo_settextpos(oldx+hugo_strlen(p), y);
+				hugo_print(buffer);
+				hugo_settextpos(oldx+hugo_strlen(p)+strlen(buffer), y);
+				hugo_print("  ");
+			}
+			goto GetKey;
+		}
+		case (8):                       /* left-arrow */
+	        case KEY_LEFT:
+		case (2):			/* Ctrl+B */
+		{
+			if (c > 0)
+			{
+				hugo_settextpos(x, y);
+				sprintf(ch, "%c", CURRENT_CHAR(c));
+				hugo_print(ch);
+				x--, c--;
+			}
+			goto GetKey;
+		}
+		case (21):                      /* right-arrow */
+	        case KEY_RIGHT:
+		case (6):			/* Ctrl+F */
+		{
+			if (c<(int)strlen(buffer))
+			{
+				hugo_settextpos(x, y);
+				sprintf(ch, "%c", CURRENT_CHAR(c));
+				hugo_print(ch);
+				x++, c++;
+			}
+			goto GetKey;
+		}
+/*
+		case CTRL_LEFT_KEY:
+		{
+			if (c)
+			{
+				hugo_settextpos(x, y);
+				sprintf(ch, "%c", CURRENT_CHAR(c));
+				hugo_print(ch);
+				do
+				{
+					do
+						c--, x--;
+					while (c && buffer[c-1]!=' ');
+				}
+				while (c && buffer[c]==' ');
+			}
+			goto GetKey;
+		}
+		case CTRL_RIGHT_KEY:
+		{
+			if (c<(int)strlen(buffer))
+			{
+				hugo_settextpos(x, y);
+				sprintf(ch, "%c", CURRENT_CHAR(c));
+				hugo_print(ch);
+				do
+				{
+					do
+						c++, x++;
+					while (c<(int)strlen(buffer) &&
+						buffer[c-1]!=' ');
+				}
+				while (c<(int)strlen(buffer) && buffer[c]==' ');
+			}
+			goto GetKey;
+		}
+*/
+	        case KEY_HOME:
+		case (1):			/* Ctrl+A */
+		case (362):
+		{
+			hugo_settextpos(x, y);
+			sprintf(ch, "%c", CURRENT_CHAR(c));
+			hugo_print(ch);
+			c = 0;
+			x = oldx + hugo_strlen(p);
+			goto GetKey;
+		}
+		case KEY_END:
+		case (5):			/* Ctrl+E */
+		case (385):
+		{
+			hugo_settextpos(x, y);
+			sprintf(ch, "%c", CURRENT_CHAR(c));
+			hugo_print(ch);
+			c = strlen(buffer);
+			x = oldx + hugo_strlen(p) + strlen(buffer);
+			goto GetKey;
+		}
+		case (27):                      /* Escape */
+		case (24):                      /* Ctrl+X */
+		{
+BlankLine:
+			hugo_settextpos(oldx+hugo_strlen(p), y);
+
+			memset(buffer, ' ', text_windowwidth);
+
+			buffer[text_windowwidth-oldx-hugo_strlen(p)] = '\0';
+			hugo_print(buffer);
+			hugo_settextpos(oldx, y);
+
+			goto NewPrompt;
+		}
+                case KEY_F(3):                  /* F3 scan code */
+	        case KEY_UP:
+		case (11):                      /* up-arrow */
+		{
+			if (--thiscommand<0)
+			{
+				thiscommand = 0;
+				goto GetKey;
+			}
+			a = strlen(buffer);
+RestoreCommand:
+			hugo_restorecommand(thiscommand);
+			x = oldx + strlen(buffer) + hugo_strlen(p);
+			hugo_settextpos(oldx+hugo_strlen(p), y);
+			hugo_print(buffer);
+			while (a >= (int)strlen(buffer))
+				{hugo_print(" ");
+				a--;}
+			hugo_settextpos(x-1, y);
+			c = strlen(buffer);
+			goto GetKey;
+		}
+#if 0
+		case (10):                      /* down-arrow */
+		case KEY_DOWN:
+		{
+			a = strlen(buffer);
+			if (++thiscommand>=hcount) goto BlankLine;
+			goto RestoreCommand;
+		}
+#endif
+	}
+
+	/* Disallow invalid keystrokes */
+	if (b < 32 || b>=256) goto GetKey;
+	
+	/* Hugo circa v2.2 allowed '^' && '~' for '\n' && '\"',
+	   respectively
+	*/
+	if (game_version<=22 && (b=='^' || b=='~')) goto GetKey;
+
+	if (oldx+strlen(buffer) >= text_windowwidth-2)
+		goto GetKey;
+
+	hugo_settextpos(x++, y);
+	sprintf(ch, "%c", b);                   /* add the new character */
+	hugo_print(ch);
+	buffer[strlen(buffer)+1] = '\0';
+	if (c<(int)strlen(buffer) && insert_mode)
+	{
+		hugo_settextpos(x, y);
+		hugo_print(buffer+c);
+		for (a=strlen(buffer); a>c; a--)
+			buffer[a] = buffer[a-1];
+	}
+	buffer[c] = (char)b;
+
+	c++;
+
+	goto GetKey;
+}
+
+
+/* hugo_iskeywaiting
+
+    Returns true if a keypress is waiting to be retrieved.
+*/
+
+int hugo_iskeywaiting(void)
+{
+        int c;
+
+        /*
+         * Normally we want to be in cbreak mode so that nothing happens
+         * as long as the user doesn't press a key.  To sort of mimic
+         * the behavior of kbhit() we can switch to either halfdelay or
+         * nodelay() mode.  Some curses implementations don't have ungetch().
+         * Deleting the ungetch() call would cause the character to be swallowed
+         * This doesn't seem to cause a problem (I originally had it that way).
+         *
+         * Kent's note:  circumventing ungetch() may cause a bit of a problem
+         * since I changed all key input (such as via hugo_waitforkey()) to
+         * be routed through hugo_getkey() for keycode translation.
+         *
+         */
+
+        halfdelay(1);
+        if((c=getch()) != ERR)
+        {
+                nocbreak();
+                cbreak();
+                ungetch(c);
+                return 1;
+        }
+        else
+        {
+                nocbreak();
+                cbreak();
+                return 0;
+        }
+}
+
+/*
+    WAITFORKEY:
+
+    Provided to be replaced by multitasking systems where cycling while
+    waiting for a keystroke may not be such a hot idea.
+*/
+
+int hugo_waitforkey(void)
+{
+        wmove(current_window, current_text_row-1, current_text_col-1);
+        
+        while (hugo_iskeywaiting())       /* clear key buffer */
+        {
+                /*
+                 * If hugo_keywaiting() were made to swallow
+                 * the character, we would want to delete this call.
+                 */
+                hugo_getkey();
+        }
+        while (!hugo_iskeywaiting())
+        {
+        }
+        /*
+         * If hugo_keywaiting() were made to swallow
+         * the character, we would want to delete this call.
+         */
+        return hugo_getkey();
+}
+
+
+/* hugo_timewait
+
+    Waits for 1/n seconds.  Returns false if waiting is unsupported.
+*/
+
+int hugo_timewait(int n)
+{
+	wtimeout(current_window, 1000/n);
+	return true;
+}
+
+
+/*
+    COMMAND HISTORY:
+
+    To store/retrieve player inputs for editing.
+*/
+
+void hugo_addcommand(void)
+{
+	int i;
+
+	if (!strcmp(buffer, "")) return;
+
+        if (hcount>=HISTORY_SIZE)
+	{
+		hugo_blockfree(history[0]);
+		for (i=0; i<HISTORY_SIZE-1; i++)
+			history[i] = history[i+1];
+		hcount = HISTORY_SIZE-1;
+	}
+
+	/* Because the debugger might use (up to) all available memory for
+	   code hugoline storage, a different means of memory allocation is
+	   needed (at least in MS-DOS due to limited available memory to
+	   begin with).
+	*/
+#if !defined (DEBUGGER)
+	if ((history[hcount] = (char *)hugo_blockalloc((long)((strlen(buffer)+1)*sizeof(char))))==NULL)
+#else
+	if ((history[hcount] = (char *)AllocMemory((size_t)((strlen(buffer)+1)*sizeof(char))))==NULL)
+#endif
+	{
+		hugo_blockfree(history[0]);
+		if (hcount)
+		{
+			for (i=0; i<hcount; i++)
+				history[i] = history[i+1];
+			hcount--;
+		}
+		return;
+	}
+
+	for (i=0; i<=(int)strlen(buffer); i++)
+		history[hcount][i] = buffer[i];
+	hcount++;
+}
+
+void hugo_restorecommand(int n)
+{
+	int i;
+
+	if (n < 0 || (n>=hcount && hcount!=HISTORY_SIZE-1)) return;
+
+	i = 0;
+	do
+		buffer[i] = history[n][i];
+	while (history[n][i++]!='\0');
+}
+
+
+/*
+    DISPLAY CONTROL:
+
+    These functions are specific library calls to QuickC/MS-DOS
+    for screen control.  Each _function() should be replaced by
+    the equivalent call for the operating system in question.  If
+    a particular operation is unavailable, in some cases it may be
+    left empty.  In other cases, it may be necessary to write a
+    brief function to achieve the desired effect.
+*/
+
+/* ResetXtermDimensions
+
+	Since you can dynamically resize an xterm window, try to
+	adjust the current display dimensions to follow.
+*/
+
+int last_SCREENWIDTH, last_SCREENHEIGHT;
+
+void ResetXtermDimensions(void)
+{
+	getmaxyx(current_window, SCREENHEIGHT, SCREENWIDTH);
+
+	if (SCREENWIDTH!=last_SCREENWIDTH || SCREENHEIGHT!=last_SCREENHEIGHT)
+	{
+		if (text_windowright==last_SCREENWIDTH)
+			text_windowright = SCREENWIDTH;
+		if (text_windowbottom==last_SCREENHEIGHT)
+			text_windowbottom = SCREENHEIGHT;
+
+		hugo_settextwindow(text_windowleft, text_windowtop,
+				   text_windowright, text_windowbottom);
+	}
+
+	last_SCREENWIDTH = SCREENWIDTH, last_SCREENHEIGHT = SCREENHEIGHT;
+}
+	
+void hugo_setgametitle(char *t)
+{}
+
+void rectangle(int left, int top, int right, int bottom)
+{
+	int i, j;
+
+	for (i=top; i<=bottom; i++)
+	{
+		for (j=left; j<=right; j++)
+		{
+			wmove(current_window, i-1, j-1);
+			waddch(current_window, ' ');
+		}
+	}
+}
+
+void hugo_clearfullscreen(void)
+{
+/* Clears everything on the screen, moving the cursor to the top-left
+   corner of the screen */
+
+	rectangle(1, 1, SCREENWIDTH, SCREENHEIGHT);
+
+	/* Must be set: */
+	currentpos = 0;
+	currenthugoline = 1;
+}
+
+
+void hugo_clearwindow(void)
+{
+/* Clears the currently defined window, moving the cursor to the top-left
+   corner of the window */
+
+	rectangle(text_windowleft, text_windowtop, text_windowright, text_windowbottom);
+
+	/* Must be set: */
+	currentpos = 0;
+	currenthugoline = 1;
+}
+
+
+void hugo_settextmode(void)
+{
+/* This function does whatever is necessary to set the system up for
+   a standard text display */
+        charwidth = FIXEDCHARWIDTH = 1;          /* again, for non-proportional */
+        hugolineheight = FIXEDLINEHEIGHT = 1;
+
+	/* Must be set: */
+	getmaxyx(current_window, SCREENHEIGHT, SCREENWIDTH);
+
+	/* Must be set: */
+	hugo_settextwindow(1, 1,
+		SCREENWIDTH/FIXEDCHARWIDTH, SCREENHEIGHT/FIXEDLINEHEIGHT);
+}
+
+void hugo_settextwindow(int left, int top, int right, int bottom)
+{
+/* Once again, the arguments for the window are passed using the same
+   unit of measurement as SCREENRIGHT, SCREENLEFT, PAGETOP, etc., whether
+   that is pixels or numbers of characters.
+
+   The text window, once set, represents the scrolling/bottom part of the
+   screen. */
+
+	/* Character, not pixel, coordinates: */
+	text_windowtop = top;
+	text_windowbottom = bottom;
+	text_windowleft = left;
+	text_windowright = right;
+	text_windowwidth = text_windowright-text_windowleft+1;
+
+	/* Must be set: */
+	/* (Engine-required parameters) */
+	physical_windowleft = (left-1)*FIXEDCHARWIDTH;
+	physical_windowtop = (top-1)*FIXEDLINEHEIGHT;
+	physical_windowright = right*FIXEDCHARWIDTH-1;
+	physical_windowbottom = bottom*FIXEDLINEHEIGHT-1;
+	physical_windowwidth = (right-left+1)*FIXEDCHARWIDTH;
+	physical_windowheight = (bottom-top+1)*FIXEDLINEHEIGHT;
+
+	ConstrainCursor();
+}
+
+void hugo_settextpos(int x, int y)
+{
+/* The top-left corner of the current active window is (1, 1).
+
+   (In other words, if the screen is being windowed so that the top row
+   of the window is row 4 on the screen, the (1, 1) refers to the 4th
+   row on the screen, and (2, 1) refers to the 5th.)
+
+   This function must also properly set currenthugoline and currentpos (where
+   currenthugoline is a the current character hugoline, and currentpos may be
+   either in pixels or characters, depending on the measure being used).
+*/
+	/* Must be set: */
+	currenthugoline = y;
+	currentpos = (x-1)*charwidth;   /* Note:  zero-based */
+
+	current_text_col = text_windowleft-1+x;
+	current_text_row = text_windowtop-1+y;
+	ConstrainCursor();
+
+	wmove(current_window, current_text_row-1, current_text_col-1);
+}
+
+void ConstrainCursor(void)
+{
+	/* ConstrainCursor() is needed since HEDJGPP.C's cursor-
+	   positioning doesn't automatically pay attention to any
+	   currently-defined window.
+	*/
+	if (current_text_col > text_windowright) current_text_col = text_windowright;
+	if (current_text_col < text_windowleft) current_text_col = text_windowleft;
+	if (current_text_row > text_windowbottom) current_text_row = text_windowbottom;
+	if (current_text_row < text_windowtop) current_text_row = text_windowtop;
+}
+
+void hugo_print(char *a)
+{
+	char just_repositioned = false;
+        char last_was_newhugoline = false;
+	int i, len;
+
+
+	len = strlen(a);
+
+	for (i=0; i<len; i++)
+	{
+                last_was_newhugoline = false;
+
+		switch (a[i])
+		{
+			case '\n':
+				++current_text_row;
+				wmove(current_window, current_text_row, current_text_col);
+				just_repositioned = true;
+                                last_was_newhugoline = true;
+				break;
+			case '\r':
+CarriageReturn:
+				current_text_col = text_windowleft;
+				wmove(current_window, current_text_row, current_text_col);
+				just_repositioned = true;
+				break;
+			default:
+			{
+				wmove(current_window, current_text_row-1, current_text_col-1);
+				waddch(current_window, a[i]);
+
+				if (++current_text_col > text_windowright)
+				{
+					current_text_col = text_windowleft;
+					++current_text_row;
+				}
+				just_repositioned = false;
+			}
+		}
+
+		if (current_text_row > text_windowbottom)
+		{
+			current_text_row = text_windowbottom;
+                        hugo_scrollwindowup();
+		}
+	}
+
+	if (!just_repositioned) wmove(current_window, current_text_row, current_text_col);
+
+        /* Because '\n' should imply '\r' */
+	if (last_was_newhugoline)
+        {
+                last_was_newhugoline = false;
+                goto CarriageReturn;
+        }
+}
+
+
+void hugo_scrollwindowup()
+{
+	int x, y;
+	chtype c, attr;
+
+	/* Basically just copies a hunk of screen to an upward-
+	   shifted position and fills in the screen behind/below it
+	*/
+	for (x=text_windowleft; x<=text_windowright; x++)
+        for (y=text_windowtop+1; y<=text_windowbottom; y++)
+	{
+		wmove(current_window, y-1, x-1);
+		c = winch(current_window);      /* get the character */
+                attr = c & A_ATTRIBUTES;        /* extract attributes */
+                
+		wmove(current_window, y-2, x-1);
+		wattrset(current_window, attr);
+		wbkgdset(current_window, attr | ' ');
+		waddch(current_window, c);
+	}
+
+  	rectangle(text_windowleft, text_windowbottom, text_windowright, text_windowbottom);
+}
+
+
+/* The following static variable are used to save the current attributes and
+   color pair being used. */
+int current_color_pair = 0;
+int real_attributes = 0;
+
+
+/* The following defines are used for the real_attributes variable.  Note that
+   both REAL_BOLD and REAL_BRITE_COLOR cause the curses BOLD attribute to be set.
+   Also note that REAL_ITALIC is mapped to reverse video. */
+
+#define REAL_BOLD  1
+#define REAL_ITALIC  2
+#define REAL_UNDERLINE 4
+#define REAL_BRITE_COLOR 8
+
+void	hugo_real_attributes_mapper(int attrib, int pairnum)
+{
+	int	curs_attr=0;
+	if(attrib & REAL_ITALIC)
+	{
+		curs_attr|=A_REVERSE;
+	}
+	if(attrib & (REAL_BOLD | REAL_BRITE_COLOR))
+	{
+		curs_attr|=A_BOLD;
+	}
+	if(attrib & REAL_UNDERLINE)
+	{
+		curs_attr|=A_UNDERLINE;
+	}
+#if  defined DO_COLOR
+	if(has_colors())
+	{
+		curs_attr |= COLOR_PAIR(pairnum);
+	}
+#endif
+	wattrset(current_window,curs_attr);
+	wbkgdset(current_window,curs_attr | ' '); 
+}
+
+void hugo_font(int f)
+{
+	real_attributes &= ~(REAL_BOLD | REAL_ITALIC | REAL_UNDERLINE);
+
+        if (f & UNDERLINE_FONT)
+	{
+		real_attributes |= REAL_UNDERLINE;
+	}
+        if (f & ITALIC_FONT)
+	{
+		real_attributes |= REAL_ITALIC;
+	}
+        if (f & BOLD_FONT)
+	{
+		real_attributes |= REAL_BOLD;
+	}
+
+	hugo_real_attributes_mapper(real_attributes,current_color_pair);
+}
+
+/* The following local varibles are used to keep track of the current
+   foreground and background colors. */
+int local_fore_color= DEF_FCOLOR;
+int local_back_color = DEF_BGCOLOR;
+
+int find_color_pair(int fgc,int bgc)
+{
+	int	pair;
+#if defined DO_COLOR
+	int	max_col=COLORS;
+	
+	if(max_col > 8)
+	{
+		max_col=8;
+	}
+	if(fgc > (max_col-1))
+	{
+		fgc=max_col-1;
+	}
+	if(bgc > (max_col-1))
+	{
+		bgc=max_col-1;
+	}
+
+	pair=bgc*max_col + max_col - 1  - fgc;
+	if(pair > (COLOR_PAIRS-1)) 
+	{
+		pair = 0;
+	}
+#else
+	pair = 0;
+#endif
+	return	pair;
+	
+}
+void hugo_settextcolor(int c)   /* foreground (print) color */
+{
+	local_fore_color=hugo_color(c);
+
+        /* If the color value is greater than 8, make the text bold */ 
+        if(local_fore_color>=8)
+        {
+		local_fore_color -= 8;
+		real_attributes |= REAL_BRITE_COLOR;
+        }
+        else
+        {
+		real_attributes &= ~REAL_BRITE_COLOR;
+        }
+	current_color_pair=find_color_pair(local_fore_color,local_back_color);
+	hugo_real_attributes_mapper(real_attributes,current_color_pair);
+}
+
+void hugo_setbackcolor(int c)   /* background color */
+{
+	local_back_color=hugo_color(c);
+
+        if(local_back_color>=8)
+        {
+		local_fore_color -= 8;
+        }
+	current_color_pair=find_color_pair(local_fore_color,local_back_color);
+	hugo_real_attributes_mapper(real_attributes,current_color_pair);
+}
+
+int hugo_gettextcolor()
+{
+	return local_fore_color;
+}
+
+int hugo_getbackcolor()
+{
+	return local_back_color;
+}
+
+int hugo_color(int c)
+{
+	/* Color-setting functions should always pass the color through
+	   hugo_color() in order to properly set default fore/background
+	   colors:
+	*/
+
+        if (c==16)      c = DEF_FCOLOR;
+        else if (c==17) c = DEF_BGCOLOR;
+	else if (c==18) c = DEF_SLFCOLOR;
+	else if (c==19) c = DEF_SLBGCOLOR;
+	else if (c==20) c = hugo_color(fcolor);
+ 
+#if defined DO_COLOR
+        if (c==0)       c = COLOR_BLACK;
+        else if (c==1)  c = COLOR_BLUE;
+        else if (c==2)  c = COLOR_GREEN;
+        else if (c==3)  c = COLOR_CYAN;
+        else if (c==4)  c = COLOR_RED;
+        else if (c==5)  c = COLOR_MAGENTA;
+        else if (c==6)  c = COLOR_YELLOW;
+        else if (c==7)  c = COLOR_WHITE;
+        else if (c==8)  c = COLOR_BLACK + 8;
+        else if (c==9)  c = COLOR_BLUE + 8;
+        else if (c==10) c = COLOR_GREEN + 8;
+        else if (c==11) c = COLOR_CYAN + 8;
+        else if (c==12) c = COLOR_RED + 8;
+        else if (c==13) c = COLOR_MAGENTA + 8;
+        else if (c==14) c = COLOR_YELLOW + 8;
+        else if (c==15) c = COLOR_WHITE + 8;
+#endif
+        return c;
+}
+
+
+/* CHARACTER AND TEXT MEASUREMENT
+
+   	For non-proportional printing, these should be pretty much as
+	described below, as screen dimensions will be given in characters,
+	not pixels.
+
+	For proportional printing, screen dimensions need to be in
+	pixels, and each width routine must take into account the
+	current font and style.
+
+	The hugo_strlen() function is used to give the length of
+	the string not including any non-printing control characters.
+*/
+
+int hugo_charwidth(char a)
+{
+	if (a==FORCED_SPACE)
+		return FIXEDCHARWIDTH;	  /* same as ' ' */
+
+	else if ((unsigned char)a >= ' ') /* alphanumeric characters */
+
+		return FIXEDCHARWIDTH;    /* because printing 
+					     is non-proportional */
+	return 0;
+}
+
+int hugo_textwidth(char *a)
+{
+	int i, slen, len = 0;
+
+	slen = strlen(a);
+
+	for (i=0; i<slen; i++)
+	{
+		if (a[i]==COLOR_CHANGE) i+=2;
+		else if (a[i]==FONT_CHANGE) i++;
+		else
+			len += hugo_charwidth(a[i]);
+	}
+
+	return len;
+}
+
+int hugo_strlen(char *a)
+{
+	int i, slen, len = 0;
+
+	slen = strlen(a);
+
+	for (i=0; i<slen; i++)
+	{
+		if (a[i]==COLOR_CHANGE) i+=2;
+		else if (a[i]==FONT_CHANGE) i++;
+		else len++;
+	}
+
+	return len;
+}
+
+
+void hugo_init_screen(void)
+{
+        /*
+         * Need to initialize the screen before use by curses
+         */
+        initscr();
+	int width  = 60;
+	int height = 13;
+/*
+	current_window = newwin(height, width, (LINES - height) / 2, (COLS - width) / 2);
+*/
+#if defined DO_COLOR
+	start_color();
+	if(has_colors())
+	{
+		int	max_col=COLORS;
+		int	i;
+		if(max_col > 8)
+		{
+			max_col=8;
+		}
+		for(i=1;i<COLOR_PAIRS;i++)
+		{
+			init_pair(i,(max_col-1)-(i % max_col),i/max_col);
+			if(((max_col-1)-(i % max_col))==(i/max_col))
+			{
+				init_pair(i,COLOR_WHITE,COLOR_BLACK);
+			}
+		}
+	}
+#endif
+        cbreak();
+        noecho();
+        nonl();
+
+	current_window = stdscr;
+
+
+//        idlok(current_window, TRUE);
+        keypad(current_window, TRUE);
+		raw();
+
+	/* We're going to use our own scrolling trigger */
+	scrollok(current_window, FALSE);
+}
+
+void hugo_cleanup_screen(void)
+{
+        /*
+         * This will return the terminal to its original settings
+         */
+	hugo_settextcolor(DEF_FCOLOR);
+	hugo_setbackcolor(DEF_BGCOLOR);
+	hugo_font(0);
+	hugo_clearfullscreen();
+        endwin();
+}
+
+
+#if !defined (COMPILE_V25)
+int hugo_hasvideo(void)
+{
+	return false;
+}
+
+int hugo_playvideo(HUGO_FILE infile, long reslength,
+	char loop_flag, char background, int volume)
+{
+	fclose(infile);
+	return true;
+}
+
+void hugo_stopvideo(void)
+{}
+#endif
+
+int hugo_hasgraphics(void)
+{
+	return false;
+}
+
+int hugo_displaypicture(FILE *infile, long len)
+{
+        fclose(infile);         /* since infile will be open */
+
+        return 1;
+}
+
+#if !defined (SOUND_SUPPORTED)	
+int hugo_playmusic(FILE *f)		/* from hesound.c */
+{
+	fclose(f);
+	return true;	/* not an error */
+}
+
+void hugo_musicvolume(int vol)
+{}
+
+void hugo_stopmusic(void)
+{}
+
+int hugo_playsample(FILE *f)
+{
+	fclose(f);
+	return true;	/* not an error */
+}
+
+void hugo_samplevolume(int vol)
+{}
+
+void hugo_stopsample(void)
+{}
+#endif
diff -Naur hugov3.1.03/source/heheader.h /usr/glenda/cursesif/hugo/source/heheader.h
--- hugov3.1.03/source/heheader.h	Fri Oct  9 18:12:02 2015
+++ /usr/glenda/cursesif/hugo/source/heheader.h	Thu Oct  1 02:31:39 2015
@@ -48,6 +48,7 @@
 
    (although this is typically done in the makefile)
 */
+#define GCC_UNIX
 
 /*---------------------------------------------------------------------------
 	Definitions for the Acorn Archimedes & RPC
@@ -115,7 +116,7 @@
 
 #define MAXBUFFER 255
 
-#define HUGO_INLINE static __inline
+#define HUGO_INLINE static __inhugoline
 
 #if defined (ALLEGRO)
 #define FRONT_END
@@ -202,9 +203,9 @@
 #define DEF_SLBGCOLOR	1
 
 #define MAXBUFFER 255
-
-#define HUGO_INLINE static __inline
-
+/*
+#define HUGO_INLINE static __inhugoline
+*/
 #endif /* defined (GCC_UNIX) */
 
 
@@ -235,7 +236,7 @@
 
 #define MAXBUFFER 255
 
-#define HUGO_INLINE static __inline
+#define HUGO_INLINE 
 
 #endif /* defined (GCC_OS2) */
 
@@ -291,14 +292,14 @@
 			   break up paragraphs (1024+256)*/
 
 #ifndef HUGO_INLINE
-#define HUGO_INLINE __inline
+#define HUGO_INLINE __inhugoline
 #endif
 
 #define FRONT_END
 #define MINIMAL_INTERFACE
 
-int heglk_get_linelength(void);
-#define ACTUAL_LINELENGTH() heglk_get_linelength()
+int heglk_get_hugolinelength(void);
+#define ACTUAL_LINELENGTH() heglk_get_hugolinelength()
 int heglk_get_screenheight(void);
 #define ACTUAL_SCREENHEIGHT() heglk_get_screenheight()
 
@@ -326,7 +327,7 @@
 #undef fgetc
 #define fgetc(f)	(glk_get_char_stream(f))
 #undef fgets
-#define fgets(a, n, f)	(glk_get_line_stream(f, a, n))
+#define fgets(a, n, f)	(glk_get_hugoline_stream(f, a, n))
 #undef fread
 #define fread(a,s,n,f)	(glk_get_buffer_stream(f, (char *)a, n))
 #undef fprintf
@@ -385,9 +386,9 @@
 #define DEF_SLFCOLOR	18
 #define DEF_SLBGCOLOR	19
 
-#define MAXBUFFER	256		/* max. input/output line length */
+#define MAXBUFFER	256		/* max. input/output hugoline length */
 
-#define HUGO_INLINE __inline
+#define HUGO_INLINE __inhugoline
 
 #define NO_TERMINAL_LINEFEED
 #define MINIMAL_WINDOWING
@@ -472,12 +473,12 @@
 
 #define DEF_FCOLOR      7               /* default colors, fore and back */
 #define DEF_BGCOLOR     0
-#define DEF_SLFCOLOR	15		/* statusline */
+#define DEF_SLFCOLOR	15		/* statushugoline */
 #define DEF_SLBGCOLOR	1
 
 #define OMIT_EXTRA_STRING_FUNCTIONS
 
-#define MAXBUFFER 255                   /* max. input/output line length */
+#define MAXBUFFER 255                   /* max. input/output hugoline length */
 
 #endif /* defined (QUICKC) */
 
@@ -530,7 +531,7 @@
 #define MAXBUFFER 255
 #define MAXUNDO 1024
 
-#define HUGO_INLINE __inline
+#define HUGO_INLINE __inhugoline
 
 #define NO_TERMINAL_LINEFEED
 #define BUILD_RANDOM
@@ -607,7 +608,7 @@
 #define MAXBUFFER 255
 #define MAXUNDO 1024
 
-#define HUGO_INLINE static __inline
+#define HUGO_INLINE static __inhugoline
 
 #define NO_TERMINAL_LINEFEED
 #define FRONT_END
@@ -691,7 +692,7 @@
 #define MAXGLOBALS       240
 #define MAXLOCALS         16
 #define MAXPOBJECTS      256    /* contenders for disambiguation */
-#define MAXWORDS          32    /* in an input line              */
+#define MAXWORDS          32    /* in an input hugoline              */
 #define MAXSTACKDEPTH    256	/* for nesting {...}		 */
 
 #if !defined (MAXUNDO)
@@ -850,8 +851,8 @@
 /* "display" object properties */
 extern const int screenwidth;
 extern const int screenheight;
-extern const int linelength;
-extern const int windowlines;
+extern const int hugolinelength;
+extern const int windowhugolines;
 extern const int cursor_column;
 extern const int cursor_row;
 extern const int hasgraphics;
@@ -872,7 +873,7 @@
 void hugo_font(int f);
 void hugo_getfilename(char *a, char *b);
 int hugo_getkey(void);
-void hugo_getline(char *p);
+void hugo_gethugoline(char *p);
 void hugo_init_screen(void);
 void hugo_makepath(char *path, char *drive, char *dir, char *fname, char *ext);
 int hugo_overwrite(char *f);
@@ -1025,7 +1026,7 @@
 extern long codeend;
 extern char pbuffer[];
 extern int currentpos;
-extern int currentline;
+extern int currenthugoline;
 extern int full;
 extern signed char fcolor, bgcolor, icolor, default_bgcolor;
 extern int currentfont;
@@ -1036,7 +1037,7 @@
 	physical_windowtop, physical_windowleft,
 	physical_windowbottom, physical_windowright;
 extern int inwindow;
-extern int charwidth, lineheight, FIXEDCHARWIDTH, FIXEDLINEHEIGHT;
+extern int charwidth, hugolineheight, FIXEDCHARWIDTH, FIXEDLINEHEIGHT;
 extern int current_text_x, current_text_y;
 extern int undostack[][5];
 extern int undoptr;
@@ -1087,7 +1088,7 @@
 extern char buffer[];
 extern char full_buffer;
 extern char errbuf[];
-extern char line[];
+extern char hugoline[];
 extern int words; extern char *word[];
 extern unsigned int wd[], parsed_number;
 extern char parse_called_twice;
diff -Naur hugov3.1.03/source/hemisc.c /usr/glenda/cursesif/hugo/source/hemisc.c
--- hugov3.1.03/source/hemisc.c	Fri Oct  9 18:12:02 2015
+++ /usr/glenda/cursesif/hugo/source/hemisc.c	Thu Oct  1 02:31:39 2015
@@ -97,9 +97,9 @@
 long codeend;                           /* end of loaded code      */
 
 /* Text output */
-char pbuffer[MAXBUFFER*2+1];            /* print buffer for line-wrapping  */
+char pbuffer[MAXBUFFER*2+1];            /* print buffer for hugoline-wrapping  */
 int currentpos = 0;                     /* column position (pixel or char) */
-int currentline = 0;                    /* row number (line)               */
+int currenthugoline = 0;                    /* row number (hugoline)               */
 int full = 0;                           /* page counter for PromptMore     */
 signed char fcolor = 16,		/* default fore/background colors  */
 	bgcolor = 17,			/* (16 = default foreground,	   */
@@ -115,7 +115,7 @@
 	physical_windowtop, physical_windowleft,
 	physical_windowbottom, physical_windowright;
 int inwindow = 0;
-int charwidth, lineheight, FIXEDCHARWIDTH, FIXEDLINEHEIGHT;
+int charwidth, hugolineheight, FIXEDCHARWIDTH, FIXEDLINEHEIGHT;
 int current_text_x = 0, current_text_y = 0;
 
 #ifdef USE_SMARTFORMATTING
@@ -143,15 +143,15 @@
 
 void AP (char *a)
 {
-	char sticky = false, skipspchar = false, startofline = 0;
+	char sticky = false, skipspchar = false, startofhugoline = 0;
 	int i, alen, plen, cwidth;
 	char c = 0;			/* current character */
 	char lastc = 0;			/* for smart formatting */
 
 	static int lastfcolor = 16, lastbgcolor = 17;
 	static int lastfont = NORMAL_FONT;
-	static int thisline = 0;	/* width in pixels or characters */
-	static int linebreaklen = 0, linebreak = 0;
+	static int thishugoline = 0;	/* width in pixels or characters */
+	static int hugolinebreaklen = 0, hugolinebreak = 0;
 	int tempfont;
 	char printed_something = false;
 #ifdef USE_TEXTBUFFER
@@ -180,11 +180,11 @@
 	plen = strlen(pbuffer);
 	if (plen==0)
 	{
-		thisline = 0;
-		linebreak = 0;
-		linebreaklen = 0;
+		thishugoline = 0;
+		hugolinebreak = 0;
+		hugolinebreaklen = 0;
 		lastfont = currentfont;
-		startofline = true;
+		startofhugoline = true;
 #ifdef USE_TEXTBUFFER
 		bufferbreak = 0;
 		bufferbreaklen = 0;
@@ -195,7 +195,7 @@
 	}
 
 	/* Check for color changes */
-	if ((a[0]) && (lastfcolor!=fcolor || lastbgcolor!=bgcolor || startofline))
+	if ((a[0]) && (lastfcolor!=fcolor || lastbgcolor!=bgcolor || startofhugoline))
 	{
 		if (plen >= MAXBUFFER*2-3) FatalError(OVERFLOW_E);
 		pbuffer[plen++] = COLOR_CHANGE;
@@ -208,7 +208,7 @@
 
 	/* Check for font changes--since fonts can only get changed
 	   by printing, we don't check lastfont */
-	if ((a[0]) && startofline)
+	if ((a[0]) && startofhugoline)
 	{
 		if (plen >= MAXBUFFER*2-2) FatalError(OVERFLOW_E);
 		pbuffer[plen++] = FONT_CHANGE;
@@ -234,7 +234,7 @@
 		c = a[i];
 		
 		/* Left-justification */
-		if (thisline==0 && c==' ' && !textto && currentpos==0)
+		if (thishugoline==0 && c==' ' && !textto && currentpos==0)
 			continue;
 
 		/* First check control characters */
@@ -326,12 +326,12 @@
 
 						/* Convert full if font height changes, since
 						   the amount of used screen real estate for
-						   this particular font (in terms of lines)
+						   this particular font (in terms of hugolines)
 						   will have changed:
 						*/
-						ratio = (double)lineheight;
+						ratio = (double)hugolineheight;
 						hugo_font(currentfont);
-						ratio /= (double)lineheight;
+						ratio /= (double)hugolineheight;
 						newfull = (int)(((double)full)*ratio+0.5);
 						if (newfull) full = newfull;
 					}
@@ -386,7 +386,7 @@
 
 		printed_something = true;
 
-		/* Handle in-text newlines */
+		/* Handle in-text newhugolines */
 		if (c=='\n')
 		{
 			hugo_font(currentfont = lastfont);
@@ -394,8 +394,8 @@
 			TB_AddWord(pbuffer+bufferbreak,
 				current_text_x+bufferbreaklen,
 				current_text_y,
-				current_text_x+thisline-1,
-				current_text_y+lineheight-1);
+				current_text_x+thishugoline-1,
+				current_text_y+hugolineheight-1);
 #endif
 			Printout(pbuffer);
 			lastfont = currentfont;
@@ -406,9 +406,9 @@
 #endif
 			strcpy(pbuffer, "");
 			plen = 0;
-			linebreak = 0;
-			linebreaklen = 0;
-			thisline = 0;
+			hugolinebreak = 0;
+			hugolinebreaklen = 0;
+			thishugoline = 0;
 #ifdef USE_SMARTFORMATTING
 			leftquote = true;
 #endif
@@ -470,20 +470,20 @@
 
 		cwidth = hugo_charwidth(c);
 
-	/* Check to see if we've overrun the current line */
+	/* Check to see if we've overrun the current hugoline */
 
-		if (thisline+cwidth+currentpos > physical_windowwidth)
+		if (thishugoline+cwidth+currentpos > physical_windowwidth)
 		{
 			char t;
 
-			if (!linebreak)
+			if (!hugolinebreak)
 			{
-				linebreak = plen-1;
-				linebreaklen = thisline;
+				hugolinebreak = plen-1;
+				hugolinebreaklen = thishugoline;
 			}
 
-			t = pbuffer[linebreak];
-			pbuffer[linebreak] = '\0';
+			t = pbuffer[hugolinebreak];
+			pbuffer[hugolinebreak] = '\0';
 
 			tempfont = currentfont;
 			hugo_font(currentfont = lastfont);
@@ -491,20 +491,20 @@
 			lastfont = currentfont;
 			hugo_font(currentfont = tempfont);
 
-			pbuffer[linebreak] = t;
-			strcpy(pbuffer, pbuffer+linebreak);
+			pbuffer[hugolinebreak] = t;
+			strcpy(pbuffer, pbuffer+hugolinebreak);
 			plen = strlen(pbuffer);
-			thisline = thisline - linebreaklen;
-			linebreak = 0;
-			linebreaklen = 0;
-			startofline = 0;
+			thishugoline = thishugoline - hugolinebreaklen;
+			hugolinebreak = 0;
+			hugolinebreaklen = 0;
+			startofhugoline = 0;
 #ifdef USE_TEXTBUFFER
 			bufferbreak = 0;
 			bufferbreaklen = 0;
 #endif
 		}
 
-		thisline += cwidth;
+		thishugoline += cwidth;
 
 #ifdef USE_TEXTBUFFER
 		if ((c==' ' || c==FORCED_SPACE) ||
@@ -513,17 +513,17 @@
 			TB_AddWord(pbuffer+bufferbreak,
 				current_text_x+bufferbreaklen,
 				current_text_y,
-				current_text_x+thisline-1,
-				current_text_y+lineheight-1);
+				current_text_x+thishugoline-1,
+				current_text_y+hugolineheight-1);
 
 			bufferbreak = plen;
-			bufferbreaklen = thisline;
+			bufferbreaklen = thishugoline;
 			bufferfont = currentfont;
 		}
 #endif
 		if ((c==' ') || (c=='/' && a[i+1]!='/') || (c=='-' && a[i+1]!='-'))
 		{
-			linebreak = plen, linebreaklen = thisline;
+			hugolinebreak = plen, hugolinebreaklen = thishugoline;
 		}
 	}
 
@@ -536,11 +536,11 @@
 		TB_AddWord(pbuffer+bufferbreak,
 			current_text_x+bufferbreaklen,
 			current_text_y,
-			current_text_x+thisline-1,
-			current_text_y+lineheight-1);
+			current_text_x+thishugoline-1,
+			current_text_y+hugolineheight-1);
 
 		bufferbreak = plen;
-		bufferbreaklen = thisline;
+		bufferbreaklen = thishugoline;
 		currentfont = tempfont;
 	}
 #endif
@@ -550,9 +550,9 @@
 		Printout(pbuffer);
 		lastfont = currentfont;
 		strcpy(pbuffer, "");
-		linebreak = 0;
-		linebreaklen = 0;
-		thisline = 0;
+		hugolinebreak = 0;
+		hugolinebreaklen = 0;
+		thishugoline = 0;
 		plen = 0;
 #ifdef USE_TEXTBUFFER
 		bufferbreak = 0;
@@ -620,7 +620,7 @@
 		PassLocals(arg);
 		return 0;
 	}
-	/* ...but if we're not immediately followed by and end-of-line marker,
+	/* ...but if we're not immediately followed by and end-of-hugoline marker,
 	   cancel the pending tail-recursion
 	*/
 	else
@@ -709,7 +709,7 @@
 	codeptr += 2;                           /* "(" */
 
 	if (MEM(codeptr)==PARSE_T || MEM(codeptr)==WORD_T)
-		strcpy(line, GetWord(GetValue()));
+		strcpy(hugoline, GetWord(GetValue()));
 	else
 	{
 		/* Get the array address to read the to-be-
@@ -730,15 +730,15 @@
 
 		defseg = arraytable;
 		for (i=0; i<len && PeekWord(arr+i*2)!=0; i++)
-			line[i] = (char)PeekWord(arr+i*2);
+			hugoline[i] = (char)PeekWord(arr+i*2);
 		defseg = gameseg;
-		line[i] = '\0';
+		hugoline[i] = '\0';
 	}
 
 	if (Peek(codeptr)==COMMA_T) codeptr++;
 	len = GetValue();
 
-	if ((loc = FindWord(line))!=UNKNOWN_WORD) return loc;
+	if ((loc = FindWord(hugoline))!=UNKNOWN_WORD) return loc;
 
 	defseg = dicttable;
 
@@ -747,24 +747,24 @@
 
 	loc = pos - 2;
 	
-	if ((long)(pos+strlen(line)) > (long)(codeend-dicttable*16L))
+	if ((long)(pos+strlen(hugoline)) > (long)(codeend-dicttable*16L))
 	{
 #ifdef DEBUGGER
-		sprintf(debug_line, "$MAXDICTEXTEND dictionary space exceeded");
-		RuntimeWarning(debug_line);
+		sprintf(debug_hugoline, "$MAXDICTEXTEND dictionary space exceeded");
+		RuntimeWarning(debug_hugoline);
 #endif
 		defseg = gameseg;
 		return 0;
 	}
 
-	Poke(pos++, (unsigned char)strlen(line));
-	for (i=0; i<(int)strlen(line) && i<len; i++)
-		Poke(pos++, (unsigned char)(line[i]+CHAR_TRANSLATION));
+	Poke(pos++, (unsigned char)strlen(hugoline));
+	for (i=0; i<(int)strlen(hugoline) && i<len; i++)
+		Poke(pos++, (unsigned char)(hugoline[i]+CHAR_TRANSLATION));
 	PokeWord(0, ++dictcount);
 
 	defseg = gameseg;
 
-	SaveUndo(DICT_T, strlen(line), 0, 0, 0);
+	SaveUndo(DICT_T, strlen(hugoline), 0, 0, 0);
 
 	return loc;
 }
@@ -774,7 +774,7 @@
 
 void FatalError(int n)
 {
-	char fatalerrorline[64];
+	char fatalerrorhugoline[64];
 
 #if defined (DEBUGGER)
 	hugo_stopmusic();
@@ -792,39 +792,39 @@
 	switch (n)
 	{
 		case MEMORY_E:
-			{sprintf(line, "Out of memory\n");
+			{sprintf(hugoline, "Out of memory\n");
 			break;}
 
 		case OPEN_E:
-			{sprintf(line, "Cannot open file\n");
+			{sprintf(hugoline, "Cannot open file\n");
 			break;}
 
 		case READ_E:
-			{sprintf(line, "Cannot read from file\n");
+			{sprintf(hugoline, "Cannot read from file\n");
 			break;}
 
 		case WRITE_E:
-			{sprintf(line, "Cannot write to save file\n");
+			{sprintf(hugoline, "Cannot write to save file\n");
 			break;}
 
 		case EXPECT_VAL_E:
-			{sprintf(line, "Expecting value at $%s\n", PrintHex(codeptr));
+			{sprintf(hugoline, "Expecting value at $%s\n", PrintHex(codeptr));
 			break;}
 
 		case UNKNOWN_OP_E:
-			{sprintf(line, "Unknown operation at $%s\n", PrintHex(codeptr));
+			{sprintf(hugoline, "Unknown operation at $%s\n", PrintHex(codeptr));
 			break;}
 
 		case ILLEGAL_OP_E:
-			{sprintf(line, "Illegal operation at $%s\n", PrintHex(codeptr));
+			{sprintf(hugoline, "Illegal operation at $%s\n", PrintHex(codeptr));
 			break;}
 
 		case OVERFLOW_E:
-			{sprintf(line, "Overflow at $%s\n", PrintHex(codeptr));
+			{sprintf(hugoline, "Overflow at $%s\n", PrintHex(codeptr));
 			break;}
 
 		case DIVIDE_E:
-			{sprintf(line, "Divide by zero at $%s\n", PrintHex(codeptr));
+			{sprintf(hugoline, "Divide by zero at $%s\n", PrintHex(codeptr));
 			break;}
 	}
 
@@ -836,7 +836,7 @@
 
 		if (n==MEMORY_E) DebuggerFatal(D_MEMORY_ERROR);
 
-		RuntimeWarning(line);
+		RuntimeWarning(hugoline);
 		debugger_interrupt = true;
 		debugger_skip = true;
 		runtime_error = true;
@@ -871,8 +871,8 @@
 	fprintf(stderr, "\n");
 }
 */
-	sprintf(fatalerrorline, "\nFatal Error:  %s", line);
-	PRINTFATALERROR(fatalerrorline);
+	sprintf(fatalerrorhugoline, "\nFatal Error:  %s", hugoline);
+	PRINTFATALERROR(fatalerrorhugoline);
 
 	hugo_closefiles();
 	hugo_blockfree(mem);
@@ -906,12 +906,12 @@
 	ioerror = 0;
 	
 	/* Make sure the filename is legal, 8 alphanumeric characters or less */
-	strcpy(line, GetWord(fnameval));
-	if (strlen(line) > 8) goto LeaveFileIO;
-	for (i=0; i<(int)strlen(line); i++)
+	strcpy(hugoline, GetWord(fnameval));
+	if (strlen(hugoline) > 8) goto LeaveFileIO;
+	for (i=0; i<(int)strlen(hugoline); i++)
 	{
-		if ((line[i]>='0' && line[i]<='9') || (line[i]>='A' && line[i]<='Z') ||
-			(line[i]>='a' && line[i]<='z'))
+		if ((hugoline[i]>='0' && hugoline[i]<='9') || (hugoline[i]>='A' && hugoline[i]<='Z') ||
+			(hugoline[i]>='a' && hugoline[i]<='z'))
 		{
 			continue;
 		}
@@ -1005,7 +1005,7 @@
 			current_text_x+bufferbreaklen,
 			current_text_y,
 			current_text_x+bufferbreaklen+FIXEDCHARWIDTH,
-			current_text_y+lineheight-1);
+			current_text_y+hugolineheight-1);
 	}
 #endif
 
@@ -1041,11 +1041,11 @@
 	y = current_text_y;
 	width = hugo_textwidth(GetWord(var[prompt]));
 	TB_AddWord(GetWord(var[prompt]), physical_windowleft, y,
-		physical_windowleft+width, y+lineheight-1);
+		physical_windowleft+width, y+hugolineheight-1);
 
-	hugo_getline(a);
+	hugo_gethugoline(a);
 	
-	/* If hugo_scrollwindowup() called by hugo_getline() shifted things */
+	/* If hugo_scrollwindowup() called by hugo_gethugoline() shifted things */
 	if (current_text_y > y)
 	{
 		y += (current_text_y - y);
@@ -1058,7 +1058,7 @@
 		if (buffer[i]==' ')
 		{
 			buffer[i] = '\0';
-			TB_AddWord(buffer+start, physical_windowleft+width, y-lineheight, 
+			TB_AddWord(buffer+start, physical_windowleft+width, y-hugolineheight, 
 				physical_windowleft+width+hugo_textwidth(buffer+start), y-1);
 			width += hugo_textwidth(buffer+start) + hugo_textwidth(" ");
 			start = i+1;
@@ -1066,10 +1066,10 @@
 		}
 	}
 	/* Add the final word */
-	TB_AddWord(buffer+start, physical_windowleft+width, y-lineheight, 
+	TB_AddWord(buffer+start, physical_windowleft+width, y-hugolineheight, 
 		physical_windowleft+width+hugo_textwidth(buffer+start), y-1);
 #else
-	hugo_getline(a);
+	hugo_gethugoline(a);
 #endif
 	during_player_input = false;
 	strcpy(buffer, Rtrim(buffer));
@@ -1206,11 +1206,11 @@
 	call[window[VIEW_CALLS].count-1].addr = currentroutine;
 	call[window[VIEW_CALLS].count-1].param = true;
 
-	sprintf(debug_line, "Calling:  %s", RoutineName(currentroutine));
-	/* Don't duplicate blank separator line in code window */
-	if (codeline[window[CODE_WINDOW].count-1][0] != 0)
+	sprintf(debug_hugoline, "Calling:  %s", RoutineName(currentroutine));
+	/* Don't duplicate blank separator hugoline in code window */
+	if (codehugoline[window[CODE_WINDOW].count-1][0] != 0)
 		AddStringtoCodeWindow("");
-	AddStringtoCodeWindow(debug_line);
+	AddStringtoCodeWindow(debug_hugoline);
 
 	/* Adjust for very long runs */
 	dbnest--;
@@ -1333,14 +1333,14 @@
 		hugo_cleanup_screen();
 		hugo_clearfullscreen();
 #endif
-		sprintf(line, "Hugo Compiler v%d.%d or later required.\n", HEVERSION, HEREVISION);
+		sprintf(hugoline, "Hugo Compiler v%d.%d or later required.\n", HEVERSION, HEREVISION);
 		if (game_version>0)
-			sprintf(line+strlen(line), "File \"%s\" is v%d.%d.\n", gamefile, game_version/10, game_version%10);
+			sprintf(hugoline+strlen(hugoline), "File \"%s\" is v%d.%d.\n", gamefile, game_version/10, game_version%10);
 
 #if defined (DEBUGGER_PRINTFATALERROR)
-		DEBUGGER_PRINTFATALERROR(line);
+		DEBUGGER_PRINTFATALERROR(hugoline);
 #else
-		printf(line);
+		printf(hugoline);
 #endif
 		hugo_closefiles();
 		hugo_blockfree(mem);
@@ -1354,12 +1354,12 @@
 		hugo_cleanup_screen();
 		hugo_clearfullscreen();
 #endif
-		sprintf(line, "File \"%s\" is incorrect or unknown version.\n", gamefile);
+		sprintf(hugoline, "File \"%s\" is incorrect or unknown version.\n", gamefile);
 
 #if defined (DEBUGGER_PRINTFATALERROR)
-		DEBUGGER_PRINTFATALERROR(line);
+		DEBUGGER_PRINTFATALERROR(hugoline);
 #else
-		printf(line);
+		printf(hugoline);
 #endif
 		hugo_closefiles();
 		hugo_blockfree(mem);
@@ -1367,7 +1367,7 @@
 		exit(OPEN_E);           /* ditto */
 	}
 
-	hugo_settextpos(1, physical_windowheight/lineheight);
+	hugo_settextpos(1, physical_windowheight/hugolineheight);
 
 	if (game_version>=25)
 		fseek(game, H_TEXTBANK, SEEK_SET);
@@ -1493,9 +1493,9 @@
 		defseg = syntable;
 		if (Peek(synptr)==3)	/* 3 = punctuation */
 		{
-			strcpy(line, GetWord(PeekWord(synptr+1)));
-			if (strlen(line) + strlen(punc_string) > 63) break;
-			strcat(punc_string, line);
+			strcpy(hugoline, GetWord(PeekWord(synptr+1)));
+			if (strlen(hugoline) + strlen(punc_string) > 63) break;
+			strcat(punc_string, hugoline);
 		}
 		synptr+=5;
 	}
@@ -1647,16 +1647,16 @@
 	int last_printed_font = currentfont;
 
 	/* hugo_font() should do this if necessary, but just in case */
-	if (lineheight < FIXEDLINEHEIGHT)
-		lineheight = FIXEDLINEHEIGHT;
+	if (hugolineheight < FIXEDLINEHEIGHT)
+		hugolineheight = FIXEDLINEHEIGHT;
 	
 	tempfcolor = fcolor;
 
-	/* The before-check of the linecount: */
+	/* The before-check of the hugolinecount: */
 	if (full)
 	{
 		/* -1 here since it's before printing */
-		if (full >= physical_windowheight/lineheight-1)
+		if (full >= physical_windowheight/hugolineheight-1)
 			PromptMore();
 	}
 
@@ -1710,9 +1710,9 @@
 				/* A minor adjustment for font changes and RunWindow() to make
 				   sure we're not printing unnecessarily downscreen
 				*/
-				if ((just_left_window) && current_text_y > physical_windowbottom-lineheight)
+				if ((just_left_window) && current_text_y > physical_windowbottom-hugolineheight)
 				{
-					current_text_y = physical_windowbottom-lineheight;
+					current_text_y = physical_windowbottom-hugolineheight;
 				}
 				just_left_window = false;
 
@@ -1747,7 +1747,7 @@
 #endif
 	}
 
-	/* If we've got a linefeed and didn't hit the right edge of the
+	/* If we've got a hugolinefeed and didn't hit the right edge of the
 	   window
 	*/
 #ifdef NO_TERMINAL_LINEFEED
@@ -1757,11 +1757,11 @@
 #endif
 	{
 		/* The background color may have to be temporarily set if we're
-		   not in a window--the reason is that full lines of the
+		   not in a window--the reason is that full hugolines of the
 		   current background color might be printed by the OS-specific
 		   scrolling function.  (This behavior is overridden by the
 		   Hugo Engine for in-window printing, which always adds new
-		   lines in the current background color when scrolling.)
+		   hugolines in the current background color when scrolling.)
 		*/
 		hugo_setbackcolor((inwindow)?bgcolor:default_bgcolor);
 		hugo_print("\r");
@@ -1770,23 +1770,23 @@
 		hugo_font(currentfont = last_printed_font);
 
 #ifndef GLK
-		if (currentline > physical_windowheight/lineheight)
+		if (currenthugoline > physical_windowheight/hugolineheight)
 		{
-			int full_limit = physical_windowheight/lineheight;
+			int full_limit = physical_windowheight/hugolineheight;
 
 			hugo_scrollwindowup();
 
 			if ((current_text_y)
 				&& full >= full_limit-3
-				&& physical_windowbottom-current_text_y-lineheight > lineheight/2)
+				&& physical_windowbottom-current_text_y-hugolineheight > hugolineheight/2)
 			{
 				PromptMore();
 			}
-			currentline = full_limit;
+			currenthugoline = full_limit;
 		}
 
-		/* Don't scroll single-line windows before PromptMore() */
-		else if (physical_windowheight/lineheight > 1)
+		/* Don't scroll single-hugoline windows before PromptMore() */
+		else if (physical_windowheight/hugolineheight > 1)
 #endif
 		{
 			hugo_print("\n");
@@ -1805,27 +1805,27 @@
 #endif
 	just_left_window = false;
 
-	/* If no newline is to be printed after the current line: */
+	/* If no newhugoline is to be printed after the current hugoline: */
 	if (sticky)
 	{
 		currentpos += l;
 	}
 
-	/* Otherwise, take care of all the line-feeding, line-counting,
+	/* Otherwise, take care of all the hugoline-feeding, hugoline-counting,
 	   etc.
 	*/
 	else
 	{
 		currentpos = 0;
-		if (currentline++ > physical_windowheight/lineheight)
-			currentline = physical_windowheight/lineheight;
+		if (currenthugoline++ > physical_windowheight/hugolineheight)
+			currenthugoline = physical_windowheight/hugolineheight;
 
 		if (!playback) skipping_more = false;
 
 		++full;
 		
-		/* The after-check of the linecount: */
-		if ((full) && full >= physical_windowheight/lineheight)
+		/* The after-check of the hugolinecount: */
+		if ((full) && full >= physical_windowheight/hugolineheight)
 		{
 			PromptMore();
 		}
@@ -1872,14 +1872,14 @@
 	tempcurrentfont = currentfont;
 	hugo_font(currentfont = NORMAL_FONT);
 
-	hugo_settextpos(1, physical_windowheight/lineheight);
+	hugo_settextpos(1, physical_windowheight/hugolineheight);
 
 #ifdef NO_TERMINAL_LINEFEED
 	/* For ports where it's possible, do a better "MORE..." prompt
 	   without a flashing caret */
 	if (default_bgcolor!=DEF_SLBGCOLOR)
 	{
-		/* system statusline colors */
+		/* system statushugoline colors */
 		hugo_settextcolor(DEF_SLFCOLOR);
 		hugo_setbackcolor(DEF_SLBGCOLOR);
 	}
@@ -1894,7 +1894,7 @@
 	}
 
 	if (current_text_y)
-		current_text_y = physical_windowbottom - lineheight;
+		current_text_y = physical_windowbottom - hugolineheight;
 
 	/* Make sure we fit in a window */
 	if (physical_windowwidth/FIXEDCHARWIDTH >= 19)
@@ -1940,9 +1940,9 @@
 	else if (playback && k=='+')
 		skipping_more = true;
 
-	hugo_settextpos(1, physical_windowheight/lineheight);
+	hugo_settextpos(1, physical_windowheight/hugolineheight);
 #ifdef NO_TERMINAL_LINEFEED
-	current_text_y = physical_windowbottom - lineheight;
+	current_text_y = physical_windowbottom - hugolineheight;
 	/* Make sure we fit in a window */
 	if (physical_windowwidth/FIXEDCHARWIDTH >= 19)
 		hugo_print("                    ");
@@ -1953,7 +1953,7 @@
 #endif
 	hugo_font(currentfont = tempcurrentfont);
 
-	hugo_settextpos(1, physical_windowheight/lineheight);
+	hugo_settextpos(1, physical_windowheight/hugolineheight);
 	current_text_y = temp_current_text_y;
 	full = 0;
 
@@ -1982,13 +1982,13 @@
 #if !defined (GLK)
 				/* stdio implementation */
 				hugo_getfilename("for command recording", recordfile);
-				if (!strcmp(line, ""))
+				if (!strcmp(hugoline, ""))
 					return 0;
-				if (!hugo_overwrite(line))
+				if (!hugo_overwrite(hugoline))
 					return 0;
-				if (!(record = HUGO_FOPEN(line, "wt")))
+				if (!(record = HUGO_FOPEN(hugoline, "wt")))
 					return 0;
-				strcpy(recordfile, line);
+				strcpy(recordfile, hugoline);
 #else
 				/* Glk implementation */
 				frefid_t fref = NULL;
@@ -2026,11 +2026,11 @@
 #if !defined (GLK)
 				/* stdio implementation */
 				hugo_getfilename("for command playback", recordfile);
-				if (!strcmp(line, ""))
+				if (!strcmp(hugoline, ""))
 					return 0;
-				if (!(playback = HUGO_FOPEN(line, "rt")))
+				if (!(playback = HUGO_FOPEN(hugoline, "rt")))
 					return 0;
-				strcpy(recordfile, line);
+				strcpy(recordfile, hugoline);
 #else
 				/* Glk implementation */
 				frefid_t fref = NULL;
@@ -2201,16 +2201,16 @@
 #ifndef NO_LATIN1_CHARSET
 			switch (s)
 			{
-				case 'a':  s = (char)0xe0; break; /*  */
-				case 'e':  s = (char)0xe8; break; /*  */
-				case 'i':  s = (char)0xec; break; /*  */
-				case 'o':  s = (char)0xf2; break; /*  */
-				case 'u':  s = (char)0xf9; break; /*  */
-				case 'A':  s = (char)0xc0; break; /*  */
-				case 'E':  s = (char)0xc8; break; /*  */
-				case 'I':  s = (char)0xcc; break; /*  */
-				case 'O':  s = (char)0xd2; break; /*  */
-				case 'U':  s = (char)0xd9; break; /*  */
+				case 'a':  s = (char)0xe0; break; /*  */
+				case 'e':  s = (char)0xe8; break; /*  */
+				case 'i':  s = (char)0xec; break; /*  */
+				case 'o':  s = (char)0xf2; break; /*  */
+				case 'u':  s = (char)0xf9; break; /*  */
+				case 'A':  s = (char)0xc0; break; /*  */
+				case 'E':  s = (char)0xc8; break; /*  */
+				case 'I':  s = (char)0xcc; break; /*  */
+				case 'O':  s = (char)0xd2; break; /*  */
+				case 'U':  s = (char)0xd9; break; /*  */
 			}
 #endif
 			break;
@@ -2221,18 +2221,18 @@
 #ifndef NO_LATIN1_CHARSET
 			switch (s)
 			{
-				case 'a':  s = (char)0xe1; break; /*  */
-				case 'e':  s = (char)0xe9; break; /*  */
-				case 'i':  s = (char)0xed; break; /*  */
-				case 'o':  s = (char)0xf3; break; /*  */
-				case 'u':  s = (char)0xfa; break; /*  */
+				case 'a':  s = (char)0xe1; break; /*  */
+				case 'e':  s = (char)0xe9; break; /*  */
+				case 'i':  s = (char)0xed; break; /*  */
+				case 'o':  s = (char)0xf3; break; /*  */
+				case 'u':  s = (char)0xfa; break; /*  */
 				case 'y':  s = (char)0xfd; break;
-				case 'A':  s = (char)0xc1; break; /*  */
-				case 'E':  s = (char)0xc9; break; /*  */
-				case 'I':  s = (char)0xcd; break; /*  */
-				case 'O':  s = (char)0xd3; break; /*  */
-				case 'U':  s = (char)0xda; break; /*  */
-				case 'Y':  s = (char)0xdd; break; /*  */
+				case 'A':  s = (char)0xc1; break; /*  */
+				case 'E':  s = (char)0xc9; break; /*  */
+				case 'I':  s = (char)0xcd; break; /*  */
+				case 'O':  s = (char)0xd3; break; /*  */
+				case 'U':  s = (char)0xda; break; /*  */
+				case 'Y':  s = (char)0xdd; break; /*  */
 			}
 #endif
 			break;
@@ -2243,12 +2243,12 @@
 #ifndef NO_LATIN1_CHARSET
 			switch (s)
 			{
-				case 'a':  s = (char)0xe3; break; /*  */
-				case 'n':  s = (char)0xf1; break; /*  */
-				case 'o':  s = (char)0xf5; break; /*  */
-				case 'A':  s = (char)0xc3; break; /*  */
-				case 'N':  s = (char)0xd1; break; /*  */
-				case 'O':  s = (char)0xd5; break; /*  */
+				case 'a':  s = (char)0xe3; break; /*  */
+				case 'n':  s = (char)0xf1; break; /*  */
+				case 'o':  s = (char)0xf5; break; /*  */
+				case 'A':  s = (char)0xc3; break; /*  */
+				case 'N':  s = (char)0xd1; break; /*  */
+				case 'O':  s = (char)0xd5; break; /*  */
 			}
 #endif
 			break;
@@ -2259,16 +2259,16 @@
 #ifndef NO_LATIN1_CHARSET
 			switch (s)
 			{
-				case 'a':  s = (char)0xe2; break; /*  */
-				case 'e':  s = (char)0xea; break; /*  */
-				case 'i':  s = (char)0xee; break; /*  */
-				case 'o':  s = (char)0xf4; break; /*  */
-				case 'u':  s = (char)0xfb; break; /*  */
-				case 'A':  s = (char)0xc2; break; /*  */
-				case 'E':  s = (char)0xca; break; /*  */
-				case 'I':  s = (char)0xce; break; /*  */
-				case 'O':  s = (char)0xd4; break; /*  */
-				case 'U':  s = (char)0xdb; break; /*  */
+				case 'a':  s = (char)0xe2; break; /*  */
+				case 'e':  s = (char)0xea; break; /*  */
+				case 'i':  s = (char)0xee; break; /*  */
+				case 'o':  s = (char)0xf4; break; /*  */
+				case 'u':  s = (char)0xfb; break; /*  */
+				case 'A':  s = (char)0xc2; break; /*  */
+				case 'E':  s = (char)0xca; break; /*  */
+				case 'I':  s = (char)0xce; break; /*  */
+				case 'O':  s = (char)0xd4; break; /*  */
+				case 'U':  s = (char)0xdb; break; /*  */
 			}
 #endif
 			break;
@@ -2279,17 +2279,17 @@
 #ifndef NO_LATIN1_CHARSET
 			switch (s)
 			{
-				case 'a':  s = (char)0xe4; break; /*  */
-				case 'e':  s = (char)0xeb; break; /*  */
-				case 'i':  s = (char)0xef; break; /*  */
-				case 'o':  s = (char)0xf6; break; /*  */
-				case 'u':  s = (char)0xfc; break; /*  */
-				/* case 'y':  s = (char)0xff; break; */ /*  */
-				case 'A':  s = (char)0xc4; break; /*  */
-				case 'E':  s = (char)0xcb; break; /*  */
-				case 'I':  s = (char)0xcf; break; /*  */
-				case 'O':  s = (char)0xd6; break; /*  */
-				case 'U':  s = (char)0xdc; break; /*  */
+				case 'a':  s = (char)0xe4; break; /*  */
+				case 'e':  s = (char)0xeb; break; /*  */
+				case 'i':  s = (char)0xef; break; /*  */
+				case 'o':  s = (char)0xf6; break; /*  */
+				case 'u':  s = (char)0xfc; break; /*  */
+				/* case 'y':  s = (char)0xff; break; */ /*  */
+				case 'A':  s = (char)0xc4; break; /*  */
+				case 'E':  s = (char)0xcb; break; /*  */
+				case 'I':  s = (char)0xcf; break; /*  */
+				case 'O':  s = (char)0xd6; break; /*  */
+				case 'U':  s = (char)0xdc; break; /*  */
 			}
 #endif
 			break;
@@ -2300,64 +2300,64 @@
 #ifndef NO_LATIN1_CHARSET
 			switch (s)
 			{
-				case 'C':  s = (char)0xc7; break; /*  */
-				case 'c':  s = (char)0xe7; break; /*  */
+				case 'C':  s = (char)0xc7; break; /*  */
+				case 'c':  s = (char)0xe7; break; /*  */
 			}
 #endif
 			break;
 		}
 		case '<':               /* Spanish left quotation marks */
 #ifndef NO_LATIN1_CHARSET
-			s = (char)0xab; /*  */
+			s = (char)0xab; /*  */
 #endif
 			break;
 		case '>':               /* Spanish right quotation marks */
 #ifndef NO_LATIN1_CHARSET
-			s = (char)0xbb; /*  */
+			s = (char)0xbb; /*  */
 			break;
 #endif
 		case '!':               /* upside-down exclamation mark */
 #ifndef NO_LATIN1_CHARSET
-			s = (char)0xa1; /*  */
+			s = (char)0xa1; /*  */
 #endif
 			break;
 		case '?':               /* upside-down question mark */
 #ifndef NO_LATIN1_CHARSET
-			s = (char)0xbf; /*  */
+			s = (char)0xbf; /*  */
 #endif
 			break;
 		case 'a':               /* ae ligature */
 #ifndef NO_LATIN1_CHARSET
-			s = (char)0xe6; ++*i; /*  */
+			s = (char)0xe6; ++*i; /*  */
 #else
 			s = 'e'; ++*i;
 #endif
 			break;
 		case 'A':               /* AE ligature */
 #ifndef NO_LATIN1_CHARSET
-			s = (char)0xc6; ++*i; /*  */
+			s = (char)0xc6; ++*i; /*  */
 #else
 			s = 'E'; ++*i;
 #endif
 			break;
 		case 'c':               /* cents symbol */
 #ifndef NO_LATIN1_CHARSET
-			s = (char)0xa2; /*  */
+			s = (char)0xa2; /*  */
 #endif
 			break;
 		case 'L':               /* British pound */
 #ifndef NO_LATIN1_CHARSET
-			s = (char)0xa3; /*  */
+			s = (char)0xa3; /*  */
 #endif
 			break;
 		case 'Y':               /* Japanese Yen */
 #ifndef NO_LATIN1_CHARSET
-			s = (char)0xa5; /*  */
+			s = (char)0xa5; /*  */
 #endif
 			break;
 		case '-':               /* em dash */
 #ifndef NO_LATIN1_CHARSET
-			/* s = (char)0x97; */ /*  */
+			/* s = (char)0x97; */ /*  */
 #endif
 			break;
 		case '#':               /* 3-digit decimal code */
@@ -2390,6 +2390,9 @@
 
 #if !defined (GLK)	/* not used for Glk */
 
+/*
+HUGO_FILE TrytoOpen(char *f, char *p, char *d)
+*/
 HUGO_FILE TrytoOpen(char *f, char *p, char *d)
 {
 	char drive[MAXDRIVE], dir[MAXDIR], fname[MAXFILENAME], ext[MAXEXT];
@@ -2640,4 +2643,5 @@
 	}
 }
 
-#endif /* BUILD_RANDOM */
+#endif
+
diff -Naur hugov3.1.03/source/heobject.c /usr/glenda/cursesif/hugo/source/heobject.c
--- hugov3.1.03/source/heobject.c	Fri Oct  9 18:12:02 2015
+++ /usr/glenda/cursesif/hugo/source/heobject.c	Thu Oct  1 02:31:39 2015
@@ -202,7 +202,7 @@
 #else
 				g = SCREENHEIGHT/FIXEDLINEHEIGHT;
 #endif
-			else if (p==linelength)
+			else if (p==hugolinelength)
 /* ACTUAL_LINELENGTH functions similarly to ACTUAL_SCREENWIDTH,
    above.
 */
@@ -211,12 +211,12 @@
 #else
 				g = physical_windowwidth/FIXEDCHARWIDTH;
 #endif
-			else if (p==windowlines)
+			else if (p==windowhugolines)
 				g = physical_windowheight/FIXEDLINEHEIGHT;
 			else if (p==cursor_column)
 				g = (currentpos+1+hugo_textwidth(pbuffer))/FIXEDCHARWIDTH;
 			else if (p==cursor_row)
-				g = currentline;
+				g = currenthugoline;
 			else if (p==hasgraphics)
 				g = hugo_hasgraphics();
 			else if (p==title_caption)
@@ -329,7 +329,7 @@
 						tail_recursion_addr = (long)PeekWord(pa+2)*address_scale;
 						return 0;
 					}
-					/* ...but if we're not immediately followed by and end-of-line marker,
+					/* ...but if we're not immediately followed by and end-of-hugoline marker,
 					   or another property value, cancel the pending tail-recursion
 					*/
 					else if (MEM(codeptr)!=DECIMAL_T)
@@ -426,7 +426,7 @@
 							if (IsBreakpoint(orig_inprop))
 								complex_prop_breakpoint = true;
 							
-							sprintf(debug_line, "Calling:  %s.%s", objectname[obj], propertyname[p]);
+							sprintf(debug_hugoline, "Calling:  %s.%s", objectname[obj], propertyname[p]);
 							trace_complex_prop_routine = true;
 
 							tempdbnest = dbnest;
diff -Naur hugov3.1.03/source/heparse.c /usr/glenda/cursesif/hugo/source/heparse.c
--- hugov3.1.03/source/heparse.c	Fri Oct  9 18:12:02 2015
+++ /usr/glenda/cursesif/hugo/source/heparse.c	Thu Oct  1 02:31:39 2015
@@ -58,7 +58,7 @@
 
 char buffer[MAXBUFFER+MAXWORDS];        /* input buffer                    */
 char errbuf[MAXBUFFER+1];               /* last invalid input              */
-char line[1025];                        /* line buffer                     */
+char hugoline[1025];                        /* hugoline buffer                     */
 
 int words = 0;                          /* parsed word count               */
 char *word[MAXWORDS+1];                 /* breakdown into words            */
@@ -69,7 +69,7 @@
 char parseerr[MAXBUFFER+1];             /* for passing to RunPrint, etc.   */
 char parsestr[MAXBUFFER+1];             /* for passing quoted string       */
 char xverb;                             /* flag; 0 = regular verb          */
-char starts_with_verb;			/* input line; 0 = no verb word    */
+char starts_with_verb;			/* input hugoline; 0 = no verb word    */
 unsigned int grammaraddr;             	/* address in grammar              */
 char *obj_parselist = NULL;             /* objects with noun/adjective     */
 int domain, odomain;                  	/* of object(s)                    */
@@ -530,7 +530,7 @@
 
 		1.  Match the verb.
 
-		2.  If no match, check to see if the line begins with an
+		2.  If no match, check to see if the hugoline begins with an
 		    object (character) and try to match it.
 
 		3.  If found, try to match a syntax for that verb, including
@@ -618,7 +618,7 @@
 
 		/* Rebuild the corrected buffer */
 		oopscount = 1;
-		strcpy(line, word[2]);
+		strcpy(hugoline, word[2]);
 		for (i=1; i<=(int)strlen(errbuf); i++)
 		{
 			if (!strcmp(Mid(errbuf, i, strlen(oops)), oops))
@@ -627,7 +627,7 @@
 
 		strcpy(buffer, errbuf);
 		buffer[i-1] = '\0';
-		strcat(buffer, line);
+		strcat(buffer, hugoline);
 
 		strcat(buffer, Right(errbuf, strlen(errbuf) - i - strlen(oops) + 1));
 
@@ -697,7 +697,7 @@
 				if (PeekWord(verbptr)!=0xffff)
 				{
 					/* If one of the verb words matches the first
-					   word in the input line
+					   word in the input hugoline
 					*/
 					if (wd[1]==PeekWord(verbptr))
 					{
@@ -815,7 +815,7 @@
 		speaking = pobj;                        /* successful */
 		gotspeaker = true;
 
-		/* So erase the object name from the start of the line */
+		/* So erase the object name from the start of the hugoline */
 		for (i=1; i<=objfinish; i++)
 			KillWord(1);
 		if (word[1][0]=='~') KillWord(1);
@@ -1090,7 +1090,7 @@
 			}
 
 
-			/* If checking the start of an input line, i.e. for
+			/* If checking the start of an input hugoline, i.e. for
 			   a command addressed to an object (character):
 			*/
 			if (obj_match_state==5 && !flag) goto Clarify;
@@ -1511,8 +1511,8 @@
 					if (strcmp(Name(i), ""))
 					{
 						pobj = i;
-						sprintf(line, "(%s)", Name(i));
-						AP(line);
+						sprintf(hugoline, "(%s)", Name(i));
+						AP(hugoline);
 						goto RestoreTempArrays;
 					}
 				}
@@ -2411,8 +2411,8 @@
 			break;
 
 		case 1:
-			sprintf(line, "You can't use the word \"%s\".", parseerr);
-			AP(line);
+			sprintf(hugoline, "You can't use the word \"%s\".", parseerr);
+			AP(hugoline);
 			break;
 
 		case 2:
@@ -2420,8 +2420,8 @@
 			break;
 
 		case 3:
-			sprintf(line, "You can't %s multiple objects.", parseerr);
-			AP(line);
+			sprintf(hugoline, "You can't %s multiple objects.", parseerr);
+			AP(hugoline);
 			break;
 
 		case 4:
@@ -2429,8 +2429,8 @@
 			break;
 
 		case 5:
-			sprintf(line, "You haven't seen any \"%s\", nor are you likely to in the near future even if such a thing exists.", parseerr);
-			AP(line);
+			sprintf(hugoline, "You haven't seen any \"%s\", nor are you likely to in the near future even if such a thing exists.", parseerr);
+			AP(hugoline);
 			break;
 
 		case 6:
@@ -2443,7 +2443,7 @@
 
 		case 8:
 		{
-			sprintf(line, "Which %s do you mean, ", !parse_called_twice?parseerr:"exactly");
+			sprintf(hugoline, "Which %s do you mean, ", !parse_called_twice?parseerr:"exactly");
 			count = 1;
 			for (k=0; k<pobjcount; k++)
 			{
@@ -2453,13 +2453,13 @@
 				{
 					if (count==pobjcount)
 					{
-						if (count > 2) strcat(line, ",");
-						strcat(line, " or ");
+						if (count > 2) strcat(hugoline, ",");
+						strcat(hugoline, " or ");
 					}
 					else
 					{
 						if (count != 1)
-							strcat(line, ", ");
+							strcat(hugoline, ", ");
 					}
 					if (GetProp(i, article, 1, 0))
 					{
@@ -2467,25 +2467,25 @@
 						/* Don't use "a" or "an" in listing */
 						/*
 						if (!strcmp(w, "a") || !strcmp(w, "an"))
-							strcat(line, "the ");
+							strcat(hugoline, "the ");
 						else
-							sprintf(line+strlen(line), "%s ", w);
+							sprintf(hugoline+strlen(hugoline), "%s ", w);
 						*/
 						/* We'll just use "the" */
-						if (w) strcat(line, "the ");
+						if (w) strcat(hugoline, "the ");
 					}
-					strcat(line, Name(i));
+					strcat(hugoline, Name(i));
 					count++;
 				}
 			}
-			strcat(line, "?");
-			AP(line);
+			strcat(hugoline, "?");
+			AP(hugoline);
 			break;
 		}
 
 		case 9:
-			sprintf(line, "Nothing to %s.", parseerr);
-			AP(line);
+			sprintf(hugoline, "Nothing to %s.", parseerr);
+			AP(hugoline);
 			break;
 
 		case 10:
@@ -2497,8 +2497,8 @@
 			break;
 
 		case 12:
-			sprintf(line, "You can't do that with the %s.", Name(a));
-			AP(line);
+			sprintf(hugoline, "You can't do that with the %s.", Name(a));
+			AP(hugoline);
 			break;
 
 		case 13:
@@ -2585,7 +2585,7 @@
 	int i;
 
 
-	/* First filter the line of any user-specified punctuation */
+	/* First filter the hugoline of any user-specified punctuation */
 	do
 	{
 		i = strcspn(buffer, punc_string);
diff -Naur hugov3.1.03/source/heres.c /usr/glenda/cursesif/hugo/source/heres.c
--- hugov3.1.03/source/heres.c	Fri Oct  9 18:12:02 2015
+++ /usr/glenda/cursesif/hugo/source/heres.c	Thu Oct  1 02:31:39 2015
@@ -83,7 +83,7 @@
 	}
 
 	/* If filename is empty, no resource file was specified and
-	   the line[] array simply holds the path of the file to be loaded
+	   the hugoline[] array simply holds the path of the file to be loaded
 	   as a resource
 	*/
 	if (!(reslength = FindResource(filename, resname)))
@@ -440,8 +440,8 @@
 
 #if defined (DEBUGGER)
 	SwitchtoDebugger();
-	sprintf(debug_line, "Unable to find \"%s\" in \"%s\"", resname, filename);
-	DebugMessageBox("Resource Error", debug_line);
+	sprintf(debug_hugoline, "Unable to find \"%s\" in \"%s\"", resname, filename);
+	DebugMessageBox("Resource Error", debug_hugoline);
 	SwitchtoGame();
 #endif
 	fclose(resource_file);
diff -Naur hugov3.1.03/source/herun.c /usr/glenda/cursesif/hugo/source/herun.c
--- hugov3.1.03/source/herun.c	Fri Oct  9 18:12:02 2015
+++ /usr/glenda/cursesif/hugo/source/herun.c	Thu Oct  1 02:31:39 2015
@@ -38,8 +38,8 @@
 
 /* Used by RunWindow() for setting current window dimensions: */
 int last_window_top, last_window_bottom, last_window_left, last_window_right;
-int lowest_windowbottom = 0,			/* in text lines */
-	physical_lowest_windowbottom;		/* in pixels or text lines */
+int lowest_windowbottom = 0,			/* in text hugolines */
+	physical_lowest_windowbottom;		/* in pixels or text hugolines */
 char just_left_window = false;
 	
 /* from heparse.c, for RunEvents() */
@@ -175,7 +175,7 @@
 #endif
 
 	/* Set up initial screen position */
-	hugo_settextpos(1, physical_windowheight/lineheight);
+	hugo_settextpos(1, physical_windowheight/hugolineheight);
 	display_needs_repaint = false;
 	full = 0;
 
@@ -299,7 +299,7 @@
 						var[actor] = var[player];
 #if defined (DEBUGGER)
 						AddStringtoCodeWindow("[Waiting for input]");
-						buffered_code_lines = FORCE_REDRAW;
+						buffered_code_hugolines = FORCE_REDRAW;
 						debugger_has_stepped_back = false;
 						window[VIEW_LOCALS].changed = true;
 #endif
@@ -326,7 +326,7 @@
 */
 								while (buffer[strlen(buffer)-1]==0x0d || buffer[strlen(buffer)-1]==0x0a)
 									buffer[strlen(buffer)-1] = '\0';
-								sprintf(line, "\n%s%s", GetWord(var[prompt]), buffer);
+								sprintf(hugoline, "\n%s%s", GetWord(var[prompt]), buffer);
 								if (script)
 									/* fprintf() this way for Glk */
 									if (fprintf(script, "%s", "\n")<0)
@@ -334,7 +334,7 @@
 #if defined (SCROLLBACK_DEFINED)
 								hugo_sendtoscrollback("\n");
 #endif
-								AP(line);
+								AP(hugoline);
 							}
 						}
 #if defined (DEBUGGER)
@@ -354,7 +354,7 @@
 									/* fprintf() this way for Glk */
 									if (fprintf(record, "%s", "\n")<0)
 										FatalError(WRITE_E);
-									if (i==words) goto RecordedNewline;
+									if (i==words) goto RecordedNewhugoline;
 								}
 								else if (fputs(word[i], record)<0
 									|| fprintf(record, "%s", " ")<0)
@@ -363,7 +363,7 @@
 								}
 							}
 							if (fprintf(record, "%s", "\n")<0) FatalError(WRITE_E);
-RecordedNewline:;
+RecordedNewhugoline:;
 						}
 					}
 					else full_buffer = false;
@@ -580,8 +580,8 @@
 								*/
 								if (objcount > 1)
 								{
-									sprintf(line, "%s:  \\;", Name(var[object]));
-									AP(line);
+									sprintf(hugoline, "%s:  \\;", Name(var[object]));
+									AP(hugoline);
 								}
 
 								obj_match_state = 0;
@@ -754,11 +754,11 @@
 	window[VIEW_CALLS].count = 0;
 
 	for (i=0; i<(int)window[CODE_WINDOW].count; i++)
-		free(codeline[i]);
+		free(codehugoline[i]);
 	window[CODE_WINDOW].count = 0;
 
 	/* Force Code window redraw */
-	buffered_code_lines = FORCE_REDRAW;
+	buffered_code_hugolines = FORCE_REDRAW;
 
 	goto RestartDebugger;
 #endif
@@ -866,7 +866,7 @@
 
 	if (icolor==-1) icolor = fcolor;	/* check unset input color */
 
-	hugo_getline("");
+	hugo_gethugoline("");
 
 #if defined (DEBUGGER)
 	if (debugger_collapsing) return;
@@ -976,7 +976,7 @@
 
 	while (MEM(codeptr) != EOL_T)
 	{
-		strcpy(line, "");
+		strcpy(hugoline, "");
 
 		switch (MEM(codeptr))
 		{
@@ -1005,7 +1005,7 @@
 					a = (int)(ACTUAL_LINELENGTH() / ratio);
 				}
 #endif
-				strcpy(line, "");
+				strcpy(hugoline, "");
 				l = 0;
 				if (a*FIXEDCHARWIDTH >
 					hugo_textwidth(pbuffer)+currentpos-hugo_charwidth(' '))
@@ -1018,8 +1018,8 @@
 #endif
 						i+=hugo_charwidth(' '))
 					{
-						line[l++] = FORCED_SPACE;
-						line[l] = '\0';
+						hugoline[l++] = FORCED_SPACE;
+						hugoline[l] = '\0';
 					}
 
 				}
@@ -1056,8 +1056,8 @@
 				else
 					l = Peek(codeptr);
 				for (i=0; i<l; i++)
-					line[i] = (char)(MEM(++codeptr) - CHAR_TRANSLATION);
-				line[i] = '\0';
+					hugoline[i] = (char)(MEM(++codeptr) - CHAR_TRANSLATION);
+				hugoline[i] = '\0';
 				codeptr++;
 				break;
 			}
@@ -1068,20 +1068,20 @@
 				a = GetValue();
 				if (!number)
 				{
-					strcpy(line, GetWord(a));
+					strcpy(hugoline, GetWord(a));
 				}
 				else
 				{
 					if (!hexnumber)
 					{
 						if (capital)
-							itoa((unsigned int)a, line, 10);
+							itoa((unsigned int)a, hugoline, 10);
 						else
-							itoa(a, line, 10);
+							itoa(a, hugoline, 10);
 						capital = 0;
 					}
 					else
-						sprintf(line, "%X", a);
+						sprintf(hugoline, "%X", a);
 
 					number = 0;
 					hexnumber = 0;
@@ -1093,13 +1093,13 @@
 		if (MEM(codeptr)==SEMICOLON_T)
 		{
 			codeptr++;
-			strcat(line, "\\;");
+			strcat(hugoline, "\\;");
 		}
 		if (capital)
 		{
 			capital = 0;
-			if ((unsigned)line[0]<128)
-				line[0] = (char)toupper((int)line[0]);
+			if ((unsigned)hugoline[0]<128)
+				hugoline[0] = (char)toupper((int)hugoline[0]);
 			else
 			{
 				/* Special conversion for non-Latin1
@@ -1107,12 +1107,12 @@
 				*/
 				char diff;
 				diff = 'a'-'A';
-				if ((unsigned)line[0]+diff<=255 && (unsigned)line[0]-diff>127)
-					line[0] -= diff;
+				if ((unsigned)hugoline[0]+diff<=255 && (unsigned)hugoline[0]-diff>127)
+					hugoline[0] -= diff;
 			}
 		}
 
-		AP(line);
+		AP(hugoline);
 	}
 
 	codeptr++;
@@ -1328,7 +1328,7 @@
 	return false;
 }
 
-#endif	// RESTOREGAMEDATA_REPLACED
+#endif
 
 int RunRestore()
 {
@@ -1341,8 +1341,8 @@
 #if defined (DEBUGGER)
 	if (debugger_collapsing) return 1;
 #endif
-	if (!strcmp(line, "")) return 0;
-	if (!(save = HUGO_FOPEN(line, "r+b"))) return 0;
+	if (!strcmp(hugoline, "")) return 0;
+	if (!(save = HUGO_FOPEN(hugoline, "r+b"))) return 0;
 
 #else
 	/* Glk implementation */
@@ -1365,7 +1365,7 @@
 	save = NULL;
 
 #if !defined (GLK)
-	strcpy(savefile, line);
+	strcpy(savefile, hugoline);
 #endif
 
 	game_reset = true;
@@ -1382,8 +1382,8 @@
 
 /* RUNROUTINE
 
-	This is the main loop for running each line of code in sequence;
-	the main switch statement is based on the first token in each line.
+	This is the main loop for running each hugoline of code in sequence;
+	the main switch statement is based on the first token in each hugoline.
 
 	This routine is relatively complex, especially given the addition
 	of debugger control.  Basically it is structured like this:
@@ -1452,8 +1452,8 @@
 	{
 		if (codeptr != addr)
 		{
-			sprintf(line, "[ROUTINE:  $%6s]", PrintHex(addr));
-			AP(line);
+			sprintf(hugoline, "[ROUTINE:  $%6s]", PrintHex(addr));
+			AP(hugoline);
 			wascalled = 1;
 		}
 	}
@@ -1492,17 +1492,17 @@
 		}
 		else
 		{
-			/* Add a blank line if one hasn't been added
+			/* Add a blank hugoline if one hasn't been added
 			   already:
 			*/
-			if ((window[CODE_WINDOW].count) && (codeline[window[CODE_WINDOW].count-1][0]&0x0FF)!='\0')
+			if ((window[CODE_WINDOW].count) && (codehugoline[window[CODE_WINDOW].count-1][0]&0x0FF)!='\0')
 				AddStringtoCodeWindow("");
 
-			/* If this is a property routine, the debug_line array
+			/* If this is a property routine, the debug_hugoline array
 			   already holds the calling information
 			*/
 			if (!trace_complex_prop_routine)
-				sprintf(debug_line, "Calling:  %s", RoutineName(currentroutine));
+				sprintf(debug_hugoline, "Calling:  %s", RoutineName(currentroutine));
 			else
 				trace_comp_prop = true;
 			trace_complex_prop_routine = false;
@@ -1523,18 +1523,18 @@
 			}
 
 			/* If not object.property or an event */
-			if (strchr(debug_line, '.')==NULL && strstr(debug_line, "vent ")==NULL)
+			if (strchr(debug_hugoline, '.')==NULL && strstr(debug_hugoline, "vent ")==NULL)
 			{
-				strcat(debug_line, "(");
+				strcat(debug_hugoline, "(");
 				for (i=0; i<arguments_passed; i++)
 				{
-					sprintf(debug_line+strlen(debug_line), "%d", var[MAXGLOBALS+i]);
+					sprintf(debug_hugoline+strlen(debug_hugoline), "%d", var[MAXGLOBALS+i]);
 					if (i<arguments_passed-1)
-						strcat(debug_line, ", ");
+						strcat(debug_hugoline, ", ");
 				}
-				strcat(debug_line, ")");
+				strcat(debug_hugoline, ")");
 			}
-			AddStringtoCodeWindow(debug_line);
+			AddStringtoCodeWindow(debug_hugoline);
 		}
 	}
 
@@ -1585,8 +1585,8 @@
 #if defined (DEBUG_CODE)
 		if (!inwindow)
 		{
-			sprintf(line, "[%6s:  %s]", PrintHex(codeptr), token[t]);
-			AP(line);
+			sprintf(hugoline, "[%6s:  %s]", PrintHex(codeptr), token[t]);
+			AP(hugoline);
 		}
 #endif
 #endif
@@ -1595,9 +1595,9 @@
 #if defined (DEBUGGER)
 		if (++runaway_counter>=65535 && runtime_warnings)
 		{
-			sprintf(debug_line, "Possible runaway loop (65535 unchecked steps)");
-			RuntimeWarning(debug_line);
-			buffered_code_lines = FORCE_REDRAW;
+			sprintf(debug_hugoline, "Possible runaway loop (65535 unchecked steps)");
+			RuntimeWarning(debug_hugoline);
+			buffered_code_hugolines = FORCE_REDRAW;
 			runaway_counter = 0;
 		}
 
@@ -1677,10 +1677,10 @@
 
 
 		/* May be necessary to reset this if, for some
-		   reason, the line array was altered (see above)
+		   reason, the hugoline array was altered (see above)
 		*/
 		if (!trace_complex_prop_routine)
-			sprintf(debug_line, "Calling:  %s", RoutineName(currentroutine));
+			sprintf(debug_hugoline, "Calling:  %s", RoutineName(currentroutine));
 		trace_complex_prop_routine = false;
 
 
@@ -1739,19 +1739,19 @@
 					{
 						/* Read the local variable name */
 						for (i=0; i<len; i++)
-							line[i] = MEM(codeptr+i+1);
-						line[len] = '\0';
+							hugoline[i] = MEM(codeptr+i+1);
+						hugoline[len] = '\0';
 
 						/* Check to make sure it doesn't already exist,
 						   for instance, if we've looped back to it
 						*/
 						for (i=0; i<current_locals; i++)
-							if (!strcmp(line, localname[i])) break;
+							if (!strcmp(hugoline, localname[i])) break;
 						
 						/* If it doesn't exist, add it */
 						if (i==current_locals)
 						{
-							strcpy(localname[current_locals], line);
+							strcpy(localname[current_locals], hugoline);
 							if (++current_locals==MAXLOCALS)
 								current_locals--;
 							window[VIEW_LOCALS].count = current_locals;
@@ -1771,15 +1771,15 @@
 			case TEXTDATA_T:        /* printed text from file */
 			{
 				textaddr = Peek(codeptr+1)*65536L+(long)PeekWord(codeptr+2);
-				strcpy(line, GetText(textaddr));
+				strcpy(hugoline, GetText(textaddr));
 				codeptr += 4;
 				if (Peek(codeptr)==SEMICOLON_T)
-					{strcat(line, "\\;");
+					{strcat(hugoline, "\\;");
 					codeptr++;}
 				if (capital)
-					{line[0] = (char)toupper((int)line[0]);
+					{hugoline[0] = (char)toupper((int)hugoline[0]);
 					capital = 0;}
-				AP(line);
+				AP(hugoline);
 				break;
 			}
 
@@ -1828,10 +1828,10 @@
 Printcharloop:
 				codeptr++;
 				i = GetValue();
-				if (capital) sprintf(line, "%c\\;", toupper(i));
-				else sprintf(line, "%c\\;", i);
+				if (capital) sprintf(hugoline, "%c\\;", toupper(i));
+				else sprintf(hugoline, "%c\\;", i);
 				capital = 0;
-				AP(line);
+				AP(hugoline);
 				if (Peek(codeptr)==COMMA_T)
 					goto Printcharloop;
 				if (game_version>=23) codeptr++; /* eol */
@@ -1864,17 +1864,17 @@
 					ypos = GetValue();
 				}
 				else
-					ypos = currentline;
+					ypos = currenthugoline;
 
 				full = ypos - 1;
 
 
-				if (ypos >= physical_windowheight/lineheight)
+				if (ypos >= physical_windowheight/hugolineheight)
 					full = 0;
 					
-				if (ypos > physical_windowheight/lineheight)
+				if (ypos > physical_windowheight/hugolineheight)
 				{
-					ypos = physical_windowheight/lineheight;
+					ypos = physical_windowheight/hugolineheight;
 
 					if (!inwindow && current_text_y && (currentfont & PROP_FONT))
 						adhere_to_bottom = true;
@@ -1882,12 +1882,12 @@
 
 				hugo_settextpos(xpos, ypos);
 
-				/* An adjustment for non-fixed-width font lineheight */
+				/* An adjustment for non-fixed-width font hugolineheight */
 				if (adhere_to_bottom)
-					current_text_y = physical_windowbottom - lineheight;
+					current_text_y = physical_windowbottom - hugolineheight;
 
 				currentpos = (xpos-1)*FIXEDCHARWIDTH;
-				currentline = ypos;
+				currenthugoline = ypos;
 
 				codeptr++;      /* skip EOL */
 				break;
@@ -2130,7 +2130,7 @@
 				hugo_settextcolor(fcolor);
 				hugo_setbackcolor(bgcolor);
 				hugo_clearwindow();
-				hugo_settextpos(1, physical_windowheight/lineheight); /*+1);*/
+				hugo_settextpos(1, physical_windowheight/hugolineheight); /*+1);*/
 
 				if (!inwindow)
 				{
@@ -2285,22 +2285,22 @@
 		else if (!debugger_step_over)
 		{
 ReturnfromRoutine:
-			sprintf(debug_line, "(Returning %d", ret);
+			sprintf(debug_hugoline, "(Returning %d", ret);
 
 			/* Since a complex property routine will give "<Routine>" as the
 			   routine name, skip those
 			*/
 			called_from = RoutineName(currentroutine);
 			if (!trace_comp_prop && called_from[0]!='<')
-				sprintf(debug_line+strlen(debug_line), " from %s", called_from);
+				sprintf(debug_hugoline+strlen(debug_hugoline), " from %s", called_from);
 
 			if (old_currentroutine!=mainaddr && old_currentroutine!=initaddr
 				&& currentroutine!=mainaddr && currentroutine!=initaddr)
 			{
-				sprintf(debug_line+strlen(debug_line), " to %s", RoutineName(old_currentroutine));
+				sprintf(debug_hugoline+strlen(debug_hugoline), " to %s", RoutineName(old_currentroutine));
 			}
-			strcat(debug_line, ")");
-			AddStringtoCodeWindow(debug_line);
+			strcat(debug_hugoline, ")");
+			AddStringtoCodeWindow(debug_hugoline);
 			AddStringtoCodeWindow("");
 
 			if ((signed)--window[VIEW_CALLS].count < 0)
@@ -2313,8 +2313,8 @@
 
 /*#elif defined (DEBUG_CODE)
 	if (wascalled)
-		{sprintf(line, "[RETURNING %d]", ret);
-		AP(line);}
+		{sprintf(hugoline, "[RETURNING %d]", ret);
+		AP(hugoline);}
 */
 #endif
 
@@ -2409,7 +2409,7 @@
 	return false;
 }
 
-#endif	// SAVEGAMEDATA_REPLACED
+#endif
 
 int RunSave()
 {
@@ -2427,10 +2427,10 @@
 #if defined (DEBUGGER)
 	if (debugger_collapsing) return 1;
 #endif
-	if (!strcmp(line, gamefile)) return 0;
-	if (!strcmp(line, "")) return 0;
-	if (!hugo_overwrite(line)) return 0;
-	if (!(save = HUGO_FOPEN(line, "w+b"))) return 0;
+	if (!strcmp(hugoline, gamefile)) return 0;
+	if (!strcmp(hugoline, "")) return 0;
+	if (!hugo_overwrite(hugoline)) return 0;
+	if (!(save = HUGO_FOPEN(hugoline, "w+b"))) return 0;
 
 #else
 	/* Glk implementation */
@@ -2453,7 +2453,7 @@
 	save = NULL;
 
 #if !defined (GLK)
-	strcpy(savefile, line);
+	strcpy(savefile, hugoline);
 #endif
 
 	return(1);
@@ -2483,11 +2483,11 @@
 #if defined (DEBUGGER)
 				if (debugger_collapsing) return 1;
 #endif
-				if (!strcmp(line, "")) return 0;
-				if (!hugo_overwrite(line)) return 0;
-				if (!(script = HUGO_FOPEN(line, "wt")))
+				if (!strcmp(hugoline, "")) return 0;
+				if (!hugo_overwrite(hugoline)) return 0;
+				if (!(script = HUGO_FOPEN(hugoline, "wt")))
 					return (0);
-				strcpy(scriptfile, line);
+				strcpy(scriptfile, hugoline);
 
 #else
 				/* Glk implementation */
@@ -2560,19 +2560,19 @@
 		maxlen = GetValue();
 	if (Peek(codeptr)==CLOSE_BRACKET_T) codeptr++;
 
-	strcpy(line, GetWord(dword));
+	strcpy(hugoline, GetWord(dword));
 
 	defseg = arraytable;
 	pos = 0;
-	for (i=0; i<(int)strlen(line) && i<(int)maxlen; i++, pos++)
+	for (i=0; i<(int)strlen(hugoline) && i<(int)maxlen; i++, pos++)
 	{
 		char a;
 
 		SaveUndo(ARRAYDATA_T, aaddr, i, PeekWord(aaddr+i*2), 0);
 
-		a = line[i];
+		a = hugoline[i];
 		if (a=='\\')
-			++i, a = SpecialChar(line, &i);
+			++i, a = SpecialChar(hugoline, &i);
 		PokeWord(aaddr+pos*2, a);
 	}
 	PokeWord(aaddr+pos*2, 0);
@@ -2694,8 +2694,8 @@
 struct SAVED_WINDOW_DATA
 {
 	int left, top, right, bottom;
-	int width, height, charwidth, lineheight;
-	int currentpos, currentline;
+	int width, height, charwidth, hugolineheight;
+	int currentpos, currenthugoline;
 	int currentfont;
 } SAVED_WINDOW_DATA;
 
@@ -2709,9 +2709,9 @@
 	spw->height = physical_windowheight;
 	spw->currentfont = currentfont;
 	spw->charwidth = charwidth;
-	spw->lineheight = lineheight;
+	spw->hugolineheight = hugolineheight;
 	spw->currentpos = currentpos;
-	spw->currentline = currentline;
+	spw->currenthugoline = currenthugoline;
 }
 
 void RestoreWindowData(struct SAVED_WINDOW_DATA *spw)
@@ -2724,9 +2724,9 @@
 	physical_windowheight = spw->height;
 
 	charwidth = spw->charwidth;
-	lineheight = spw->lineheight;
+	hugolineheight = spw->hugolineheight;
 	currentpos = spw->currentpos;
-	currentline = spw->currentline;
+	currenthugoline = spw->currenthugoline;
 
 /*	if (currentfont!=spw->currentfont) hugo_font((currentfont = spw->currentfont)); */
 }
@@ -2911,7 +2911,7 @@
 	}
 
 	/* v2.3 and earlier supported a very simple version of
-	   windowing:  mainly just moving the top/scroll-off line
+	   windowing:  mainly just moving the top/scroll-off hugoline
 	   of the printable area to the bottom of the text printed
 	   in the "window" block
 	*/
@@ -2935,7 +2935,7 @@
 		        SCREENWIDTH/FIXEDCHARWIDTH,
 			SCREENHEIGHT/FIXEDLINEHEIGHT);
 
-		physical_lowest_windowbottom = full*lineheight;
+		physical_lowest_windowbottom = full*hugolineheight;
 	}
 
 LeaveWindow:
@@ -2944,7 +2944,7 @@
 
 #ifndef PALMOS
 	if (!current_text_y)
-		hugo_settextpos(1, physical_windowheight/lineheight);
+		hugo_settextpos(1, physical_windowheight/hugolineheight);
 #endif
 	current_text_x = 0;
 	currentpos = 0;
diff -Naur hugov3.1.03/source/htokens.h /usr/glenda/cursesif/hugo/source/htokens.h
--- hugov3.1.03/source/htokens.h	Fri Oct  9 18:12:02 2015
+++ /usr/glenda/cursesif/hugo/source/htokens.h	Thu Oct  1 02:31:39 2015
@@ -90,7 +90,7 @@
 	"not", "true", "false", "local", "verb", "xverb", "held", "multi",
 	
 	/* 0x30 - 0x3f */
-	"multiheld", "newline", "anything", "print",
+	"multiheld", "newhugoline", "anything", "print",
 	"number", "capital", "text", "graphics",
 	"color", "remove", "move", "to",
 	"parent", "sibling", "child", "youngest",
diff -Naur hugov3.1.03/source/iotest.c /usr/glenda/cursesif/hugo/source/iotest.c
--- hugov3.1.03/source/iotest.c	Fri Oct  9 18:12:02 2015
+++ /usr/glenda/cursesif/hugo/source/iotest.c	Thu Oct  1 02:31:39 2015
@@ -37,12 +37,12 @@
 char fcolor = DEF_FCOLOR, bgcolor = DEF_BGCOLOR;
 char default_bgcolor = DEF_BGCOLOR;
 int SCREENWIDTH, SCREENHEIGHT;
-int charwidth, lineheight;
+int charwidth, hugolineheight;
 int FIXEDCHARWIDTH, FIXEDLINEHEIGHT;
-int currentpos, currentline, currentfont;
+int currentpos, currenthugoline, currentfont;
 int physical_windowtop = 0, physical_windowbottom = 0,
 	physical_windowleft = 0, physical_windowright = 0;
-char line[MAXBUFFER];
+char hugoline[MAXBUFFER];
 char pbuffer[MAXBUFFER*2+1];
 unsigned int textto = 0;
 unsigned int arraytable = 0;
@@ -108,11 +108,11 @@
 	hugo_settextpos(1, 1);
 	full = -1;
 
-	AP("This should display \\Bbold\\b, \\Iitalic\\i, and \\Uunderlined\\u \
-type, wrapping properly onto the next line when it hits the right edge of the \
+	AP("This should display \\Bbold\\b, \\Iitalic\\i, and \\Uunderhugolined\\u \
+type, wrapping properly onto the next hugoline when it hits the right edge of the \
 screen.");
 	AP("\\n\\PThis should (after a double space) print the same thing (i.e. \
-\\Bbold\\b, \\Iitalic\\i, and \\Uunderline\\u), except in proportional type (if \
+\\Bbold\\b, \\Iitalic\\i, and \\Uunderhugoline\\u), except in proportional type (if \
 the system provides it).\\p");
 
 	hugo_waitforkey();
@@ -185,13 +185,13 @@
 
 	fcolor = HUGO_BRIGHT_WHITE;
 	bgcolor = HUGO_GREEN;
-	strcpy(line, "");
+	strcpy(hugoline, "");
 	for (i=1; i<=SCREENWIDTH/hugo_charwidth(' '); i++)
-		strcat(line, "\\_");
-	AP(line);
-	strcpy(line, "SPECIAL CHARACTERS AND SCROLLING");
-	hugo_settextpos(physical_windowwidth/FIXEDCHARWIDTH/2-strlen(line)/2, 1);
-	AP(line);
+		strcat(hugoline, "\\_");
+	AP(hugoline);
+	strcpy(hugoline, "SPECIAL CHARACTERS AND SCROLLING");
+	hugo_settextpos(physical_windowwidth/FIXEDCHARWIDTH/2-strlen(hugoline)/2, 1);
+	AP(hugoline);
 	hugo_settextwindow(1, 2,
 		SCREENWIDTH/FIXEDCHARWIDTH, SCREENHEIGHT/FIXEDLINEHEIGHT);
 	SETWINDOWBOTTOM(2);
@@ -231,8 +231,8 @@
 	AP("As may or may not have happened by now, every time a page is filled, \
 a \"[MORE...]\" prompt should appear at the bottom of the screen.");
 	AP("\\nThe page should only scroll when \\Iexactly\\i one screen of text \
-has been printed.  That is, the last line of the previous page should disappear \
-before the \"[MORE...]\" prompt appears, and a line of text should never disappear \
+has been printed.  That is, the last hugoline of the previous page should disappear \
+before the \"[MORE...]\" prompt appears, and a hugoline of text should never disappear \
 off the top of the screen without the \"[MORE...]\" prompt.");
 	AP("\\nScrolling should take into account the current window, which in the \
 current case is everything below the title band.  The title \\\\;");
@@ -242,13 +242,13 @@
 	fcolor = DEF_FCOLOR;
 	bgcolor = DEF_BGCOLOR;
 	AP(" should remain at the top of the screen.  (That last bit--the printing \
-of the title--should have appeared in white and green in the middle of the line.)");
+of the title--should have appeared in white and green in the middle of the hugoline.)");
 
 	AP("");
 	for (i=1; i<=50; i++)
 	{
-		sprintf(line, "Line %d", i);
-		AP(line);
+		sprintf(hugoline, "Line %d", i);
+		AP(hugoline);
 	}
 
 	hugo_waitforkey();
@@ -266,10 +266,10 @@
 
 void AP (char *a)
 {
-	char c, sticky = false, skipspchar = false, startofline = 0;
+	char c, sticky = false, skipspchar = false, startofhugoline = 0;
 	int b, i, j, slen;
-	int newline = 0;
-	int thisline, thisword;           /* widths in pixels or characters */
+	int newhugoline = 0;
+	int thishugoline, thisword;           /* widths in pixels or characters */
 	int tempfont;
 
 	char q[MAXBUFFER*2+1],            /* current word      */
@@ -293,13 +293,13 @@
 		sticky = true;
 	}
 
-	thisline = hugo_textwidth(pbuffer);
+	thishugoline = hugo_textwidth(pbuffer);
 
 	slen = strlen(pbuffer);
-	if (slen==0) startofline = true;
+	if (slen==0) startofhugoline = true;
 
 	/* Check for color changes */
-	if (lastfcolor!=fcolor || lastbgcolor!=bgcolor || startofline)
+	if (lastfcolor!=fcolor || lastbgcolor!=bgcolor || startofhugoline)
 	{
 		pbuffer[slen++] = COLOR_CHANGE;
 		pbuffer[slen++] = (char)(fcolor+1);
@@ -310,7 +310,7 @@
 	}
 
 	/* Check for font changes */
-	if (lastfont!=currentfont || startofline)
+	if (lastfont!=currentfont || startofhugoline)
 	{
 		pbuffer[slen++] = FONT_CHANGE;
 		pbuffer[slen++] = (char)(currentfont+1);
@@ -348,7 +348,7 @@
 						if (!textto)
 						{
 							r = '\0';
-							newline = true;
+							newhugoline = true;
 						}
 						else
 							r = '\n';
@@ -418,13 +418,13 @@
 				else if (r=='^')
 				{
 					r = '\0';
-					newline++;
+					newhugoline++;
 				}
 			}
 			else if (r=='\n')
 			{
 				r = '\0';
-				newline++;
+				newhugoline++;
 			}
 
 			/* Add the new character */
@@ -468,7 +468,7 @@
 	   etc., i.e., something that signals the end of the current word.
 	*/
 		strcat(pbuffer, q);
-		thisline += thisword;
+		thishugoline += thisword;
 
 		if (strlen(pbuffer) >= MAXBUFFER*2) FatalError(OVERFLOW_E);
 
@@ -476,12 +476,12 @@
 		/* Check if the current screen position plus the width of the
 		   to-be-printed text exceeds the width of the screen */
 
-		if (thisline+currentpos > physical_windowwidth)
+		if (thishugoline+currentpos > physical_windowwidth)
 		{
 			/* If so, skim backward for a place to break the
-			   line, i.e., a space or a hyphen */
+			   hugoline, i.e., a space or a hyphen */
 
-			thisword = thisline;    /* smaller line length */
+			thisword = thishugoline;    /* smaller hugoline length */
 
 			/* A complicated little loop, mainly that way to enable
 			   breaks on appropriate punctuation, but also to make
@@ -523,7 +523,7 @@
 
 			if (q[j]=='-' && q[j+1]=='-') j--;
 
-			/* Print the first part of the line (with the rest
+			/* Print the first part of the hugoline (with the rest
 			   stored in pbuffer
 			*/
 			c = q[j+1];
@@ -538,7 +538,7 @@
 			Printout(q);
 			q[j+1] = c;
 
-			/* Make sure that the to-be-printed line starts out
+			/* Make sure that the to-be-printed hugoline starts out
 			   with the right font (i.e., if a font change was
 			   processed by Printout() and is now stored in
 			   currentfont)
@@ -553,16 +553,16 @@
 				q+j+1);
 			currentfont = tempfont;
 
-			thisline = hugo_textwidth(pbuffer);
+			thishugoline = hugo_textwidth(pbuffer);
 		}
 
-		if (newline)
+		if (newhugoline)
 		{
 			Printout(pbuffer);
 			strcpy(pbuffer, "");
-			thisline = 0;
+			thishugoline = 0;
 
-			while (--newline) Printout("");
+			while (--newhugoline) Printout("");
 		}
 	}
 
@@ -650,17 +650,17 @@
 #endif
 	}
 
-	/* If we've got a linefeed and didn't hit the right edge of the
+	/* If we've got a hugolinefeed and didn't hit the right edge of the
 	   window
 	*/
 	if (!sticky && currentpos+l < physical_windowwidth)
 	{
 		/* The background color may have to be temporarily set if we're
-		   not in a window--the reason is that full lines of the
+		   not in a window--the reason is that full hugolines of the
 		   current background color might be printed by the OS-specific
 		   scrolling function.  (This behavior is overridden by the
 		   Hugo engine for in-window printing, which always adds new
-		   lines in the current background color when scrolling.)
+		   hugolines in the current background color when scrolling.)
 		*/
 		hugo_print("\r");
 		hugo_setbackcolor((inwindow)?bgcolor:default_bgcolor);
@@ -668,7 +668,7 @@
 		i = currentfont;
 		hugo_font(currentfont = last_printed_font);
 
-		if (currentline > physical_windowheight/lineheight)
+		if (currenthugoline > physical_windowheight/hugolineheight)
 		{
 			hugo_scrollwindowup();
 		}
@@ -689,22 +689,22 @@
 	}
 #endif
 
-	/* If no newline is to be printed after the current line: */
+	/* If no newhugoline is to be printed after the current hugoline: */
 	if (sticky)
 	{
 		currentpos += l;
 	}
 
-	/* Otherwise, take care of all the line-feeding, line-counting,
+	/* Otherwise, take care of all the hugoline-feeding, hugoline-counting,
 	   etc.
 	*/
 	else
 	{
 		currentpos = 0;
-		if (currentline++ > physical_windowheight/lineheight)
-			currentline = physical_windowheight/lineheight;
+		if (currenthugoline++ > physical_windowheight/hugolineheight)
+			currenthugoline = physical_windowheight/hugolineheight;
 
-		if (++full >= physical_windowheight/lineheight-1)
+		if (++full >= physical_windowheight/hugolineheight-1)
 			PromptMore();
 
 		if (script)
@@ -738,7 +738,7 @@
 	hugo_setbackcolor(17); /* DEF_BGCOLOR); */
 
 	/* +1 to force positioning to the very, very bottom of the window */
-	hugo_settextpos(1, physical_windowheight/lineheight+1);
+	hugo_settextpos(1, physical_windowheight/hugolineheight+1);
 	hugo_print("[MORE...]");
 
 	k = hugo_waitforkey();
@@ -753,11 +753,11 @@
 	hugo_settextcolor(fcolor);      /* program colors */
 	hugo_setbackcolor(bgcolor);
 
-	hugo_settextpos(1, physical_windowheight/lineheight+1);
+	hugo_settextpos(1, physical_windowheight/hugolineheight+1);
 	hugo_print("         ");
 
 	hugo_font(currentfont = tempcurrentfont);
-	hugo_settextpos(1, physical_windowheight/lineheight);
+	hugo_settextpos(1, physical_windowheight/hugolineheight);
 	current_text_y = temp_current_text_y;
 	full = 0;
 }
@@ -841,16 +841,16 @@
 #ifndef NO_LATIN1_CHARSET
 			switch (s)
 			{
-				case 'a':  s = ''; break;
-				case 'e':  s = ''; break;
-				case 'i':  s = ''; break;
-				case 'o':  s = ''; break;
-				case 'u':  s = ''; break;
-				case 'A':  s = ''; break;
-				case 'E':  s = ''; break;
-				case 'I':  s = ''; break;
-				case 'O':  s = ''; break;
-				case 'U':  s = ''; break;
+				case 'a':  s = ''; break;
+				case 'e':  s = ''; break;
+				case 'i':  s = ''; break;
+				case 'o':  s = ''; break;
+				case 'u':  s = ''; break;
+				case 'A':  s = ''; break;
+				case 'E':  s = ''; break;
+				case 'I':  s = ''; break;
+				case 'O':  s = ''; break;
+				case 'U':  s = ''; break;
 			}
 #endif
 			break;
@@ -861,18 +861,18 @@
 #ifndef NO_LATIN1_CHARSET
 			switch (s)
 			{
-				case 'a':  s = ''; break;
-				case 'e':  s = ''; break;
-				case 'i':  s = ''; break;
-				case 'o':  s = ''; break;
-				case 'u':  s = ''; break;
+				case 'a':  s = ''; break;
+				case 'e':  s = ''; break;
+				case 'i':  s = ''; break;
+				case 'o':  s = ''; break;
+				case 'u':  s = ''; break;
 				case 'y':  s = (char)0xfd; break;
-				case 'A':  s = ''; break;
-				case 'E':  s = ''; break;
-				case 'I':  s = ''; break;
-				case 'O':  s = ''; break;
-				case 'U':  s = ''; break;
-				case 'Y':  s = ''; break;
+				case 'A':  s = ''; break;
+				case 'E':  s = ''; break;
+				case 'I':  s = ''; break;
+				case 'O':  s = ''; break;
+				case 'U':  s = ''; break;
+				case 'Y':  s = ''; break;
 			}
 #endif
 			break;
@@ -883,12 +883,12 @@
 #ifndef NO_LATIN1_CHARSET
 			switch (s)
 			{
-				case 'a':  s = ''; break;
-				case 'n':  s = ''; break;
-				case 'o':  s = ''; break;
-				case 'A':  s = ''; break;
-				case 'N':  s = ''; break;
-				case 'O':  s = ''; break;
+				case 'a':  s = ''; break;
+				case 'n':  s = ''; break;
+				case 'o':  s = ''; break;
+				case 'A':  s = ''; break;
+				case 'N':  s = ''; break;
+				case 'O':  s = ''; break;
 			}
 #endif
 			break;
@@ -899,16 +899,16 @@
 #ifndef NO_LATIN1_CHARSET
 			switch (s)
 			{
-				case 'a':  s = ''; break;
-				case 'e':  s = ''; break;
-				case 'i':  s = ''; break;
-				case 'o':  s = ''; break;
-				case 'u':  s = ''; break;
-				case 'A':  s = ''; break;
-				case 'E':  s = ''; break;
-				case 'I':  s = ''; break;
-				case 'O':  s = ''; break;
-				case 'U':  s = ''; break;
+				case 'a':  s = ''; break;
+				case 'e':  s = ''; break;
+				case 'i':  s = ''; break;
+				case 'o':  s = ''; break;
+				case 'u':  s = ''; break;
+				case 'A':  s = ''; break;
+				case 'E':  s = ''; break;
+				case 'I':  s = ''; break;
+				case 'O':  s = ''; break;
+				case 'U':  s = ''; break;
 			}
 #endif
 			break;
@@ -919,17 +919,17 @@
 #ifndef NO_LATIN1_CHARSET
 			switch (s)
 			{
-				case 'a':  s = ''; break;
-				case 'e':  s = ''; break;
-				case 'i':  s = ''; break;
-				case 'o':  s = ''; break;
-				case 'u':  s = ''; break;
-				case 'y':  s = ''; break;
-				case 'A':  s = ''; break;
-				case 'E':  s = ''; break;
-				case 'I':  s = ''; break;
-				case 'O':  s = ''; break;
-				case 'U':  s = ''; break;
+				case 'a':  s = ''; break;
+				case 'e':  s = ''; break;
+				case 'i':  s = ''; break;
+				case 'o':  s = ''; break;
+				case 'u':  s = ''; break;
+				case 'y':  s = ''; break;
+				case 'A':  s = ''; break;
+				case 'E':  s = ''; break;
+				case 'I':  s = ''; break;
+				case 'O':  s = ''; break;
+				case 'U':  s = ''; break;
 			}
 #endif
 			break;
@@ -940,64 +940,64 @@
 #ifndef NO_LATIN1_CHARSET
 			switch (s)
 			{
-				case 'C':  s = ''; break;
-				case 'c':  s = ''; break;
+				case 'C':  s = ''; break;
+				case 'c':  s = ''; break;
 			}
 #endif
 			break;
 		}
 		case '<':               /* Spanish left quotation marks */
 #ifndef NO_LATIN1_CHARSET
-			s = '';
+			s = '';
 #endif
 			break;
 		case '>':               /* Spanish right quotation marks */
 #ifndef NO_LATIN1_CHARSET
-			s = '';
+			s = '';
 			break;
 #endif
 		case '!':               /* upside-down exclamation mark */
 #ifndef NO_LATIN1_CHARSET
-			s = '';
+			s = '';
 #endif
 			break;
 		case '?':               /* upside-down question mark */
 #ifndef NO_LATIN1_CHARSET
-			s = '';
+			s = '';
 #endif
 			break;
 		case 'a':               /* ae ligature */
 #ifndef NO_LATIN1_CHARSET
-			s = ''; ++*i;
+			s = ''; ++*i;
 #else
 			s = 'e'; ++*i;
 #endif
 			break;
 		case 'A':               /* AE ligature */
 #ifndef NO_LATIN1_CHARSET
-			s = ''; ++*i; 
+			s = ''; ++*i; 
 #else
 			s = 'E'; ++*i;
 #endif
 			break;
 		case 'c':               /* cents symbol */
 #ifndef NO_LATIN1_CHARSET
-			s = '';
+			s = '';
 #endif
 			break;
 		case 'L':               /* British pound */
 #ifndef NO_LATIN1_CHARSET
-			s = '';
+			s = '';
 #endif
 			break;
 		case 'Y':               /* Japanese Yen */
 #ifndef NO_LATIN1_CHARSET
-			s = '';
+			s = '';
 #endif
 			break;
 		case '-':               /* em dash */
 #ifndef NO_LATIN1_CHARSET
-			s = '';
+			s = '';
 #endif
 			break;
 		case '#':               /* 3-digit decimal ASCII code */
diff -Naur hugov3.1.03/source/mkfile /usr/glenda/cursesif/hugo/source/mkfile
--- hugov3.1.03/source/mkfile	Thu Jan  1 00:00:00 1970
+++ /usr/glenda/cursesif/hugo/source/mkfile	Thu Oct  1 03:11:21 2015
@@ -0,0 +1,15 @@
+</sys/src/ape/config
+all:
+	pcc -D_POSIX_SOURCE -D_BSD_EXTENSION -D_PLAN9_SOURCE -c he*.c
+	pcc -D_POSIX_SOURCE -D_BSD_EXTENSION -D_PLAN9_SOURCE -c stringfn.c
+	pcc -D_POSIX_SOURCE -D_BSD_EXTENSION -D_PLAN9_SOURCE -o hugo he.$O heexpr.$O hemisc.$O heobject.$O heparse.$O herun.$O heres.$O heset.$O stringfn.$O hegcc.$O
+	pcc -D_POSIX_SOURCE -D_BSD_EXTENSION -D_PLAN9_SOURCE -c hc*.c
+	pcc -D_POSIX_SOURCE -D_BSD_EXTENSION -D_PLAN9_SOURCE -o hugocompiler hc.$O hcbuild.$O hccode.$O hcdef.$O hcfile.$O hclink.$O hcmisc.$O hccomp.$O hcpass.$O hcres.$O stringfn.$O hcgcc.$O
+install:
+	mk
+	cp hugo /$objtype/bin/chugo
+	cp hugocompiler /$objtype/bin
+clean:
+	rm *.$O
+	rm hugo
+	rm hugocompiler
diff -Naur hugov3.1.03/source/textfont.h /usr/glenda/cursesif/hugo/source/textfont.h
--- hugov3.1.03/source/textfont.h	Fri Oct  9 18:12:02 2015
+++ /usr/glenda/cursesif/hugo/source/textfont.h	Thu Oct  1 02:31:39 2015
@@ -109,132 +109,132 @@
 	{ 0xE0, 0x30, 0x30, 0x1C, 0x30, 0x30, 0xE0, 0x00 },   /* '}' */
 	{ 0x76, 0xDC, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },   /* '~' */
 	{ 0x00, 0x10, 0x38, 0x6C, 0xC6, 0xC6, 0xFE, 0x00 },   /* '' */
-	{ 0x78, 0xCC, 0xC0, 0xCC, 0x78, 0x18, 0x0C, 0x78 },   /* '' */
-	{ 0x00, 0xCC, 0x00, 0xCC, 0xCC, 0xCC, 0x7E, 0x00 },   /* '' */
-	{ 0x1C, 0x00, 0x78, 0xCC, 0xFC, 0xC0, 0x78, 0x00 },   /* '' */
-	{ 0x7E, 0xC3, 0x3C, 0x06, 0x3E, 0x66, 0x3F, 0x00 },   /* '' */
-	{ 0xCC, 0x00, 0x78, 0x0C, 0x7C, 0xCC, 0x7E, 0x00 },   /* '' */
-	{ 0xE0, 0x00, 0x78, 0x0C, 0x7C, 0xCC, 0x7E, 0x00 },   /* '' */
-	{ 0x30, 0x30, 0x78, 0x0C, 0x7C, 0xCC, 0x7E, 0x00 },   /* '' */
-	{ 0x00, 0x00, 0x78, 0xC0, 0xC0, 0x78, 0x0C, 0x38 },   /* '' */
-	{ 0x7E, 0xC3, 0x3C, 0x66, 0x7E, 0x60, 0x3C, 0x00 },   /* '' */
-	{ 0xCC, 0x00, 0x78, 0xCC, 0xFC, 0xC0, 0x78, 0x00 },   /* '' */
-	{ 0xE0, 0x00, 0x78, 0xCC, 0xFC, 0xC0, 0x78, 0x00 },   /* '' */
-	{ 0xCC, 0x00, 0x70, 0x30, 0x30, 0x30, 0x78, 0x00 },   /* '' */
-	{ 0x7C, 0xC6, 0x38, 0x18, 0x18, 0x18, 0x3C, 0x00 },   /* '' */
-	{ 0xE0, 0x00, 0x70, 0x30, 0x30, 0x30, 0x78, 0x00 },   /* '' */
-	{ 0xC6, 0x38, 0x6C, 0xC6, 0xFE, 0xC6, 0xC6, 0x00 },   /* '' */
-	{ 0x30, 0x30, 0x00, 0x78, 0xCC, 0xFC, 0xCC, 0x00 },   /* '' */
-	{ 0x1C, 0x00, 0xFC, 0x60, 0x78, 0x60, 0xFC, 0x00 },   /* '' */
-	{ 0x00, 0x00, 0x7F, 0x0C, 0x7F, 0xCC, 0x7F, 0x00 },   /* '' */
-	{ 0x3E, 0x6C, 0xCC, 0xFE, 0xCC, 0xCC, 0xCE, 0x00 },   /* '' */
-	{ 0x78, 0xCC, 0x00, 0x78, 0xCC, 0xCC, 0x78, 0x00 },   /* '' */
-	{ 0x00, 0xCC, 0x00, 0x78, 0xCC, 0xCC, 0x78, 0x00 },   /* '' */
-	{ 0x00, 0xE0, 0x00, 0x78, 0xCC, 0xCC, 0x78, 0x00 },   /* '' */
-	{ 0x78, 0xCC, 0x00, 0xCC, 0xCC, 0xCC, 0x7E, 0x00 },   /* '' */
-	{ 0x00, 0xE0, 0x00, 0xCC, 0xCC, 0xCC, 0x7E, 0x00 },   /* '' */
-	{ 0x00, 0xCC, 0x00, 0xCC, 0xCC, 0x7C, 0x0C, 0xF8 },   /* '' */
-	{ 0xC3, 0x18, 0x3C, 0x66, 0x66, 0x3C, 0x18, 0x00 },   /* '' */
-	{ 0xCC, 0x00, 0xCC, 0xCC, 0xCC, 0xCC, 0x78, 0x00 },   /* '' */
-	{ 0x18, 0x18, 0x7E, 0xC0, 0xC0, 0x7E, 0x18, 0x18 },   /* '' */
-	{ 0x38, 0x6C, 0x64, 0xF0, 0x60, 0xE6, 0xFC, 0x00 },   /* '' */
-	{ 0xCC, 0xCC, 0x78, 0xFC, 0x30, 0xFC, 0x30, 0x30 },   /* '' */
-	{ 0xF8, 0xCC, 0xCC, 0xFA, 0xC6, 0xCF, 0xC6, 0xC7 },   /* '' */
-	{ 0x0E, 0x1B, 0x18, 0x3C, 0x18, 0x18, 0xD8, 0x70 },   /* '' */
-	{ 0x1C, 0x00, 0x78, 0x0C, 0x7C, 0xCC, 0x7E, 0x00 },   /* '' */
-	{ 0x38, 0x00, 0x70, 0x30, 0x30, 0x30, 0x78, 0x00 },   /* '' */
-	{ 0x00, 0x1C, 0x00, 0x78, 0xCC, 0xCC, 0x78, 0x00 },   /* '' */
-	{ 0x00, 0x1C, 0x00, 0xCC, 0xCC, 0xCC, 0x7E, 0x00 },   /* '' */
-	{ 0x00, 0xF8, 0x00, 0xF8, 0xCC, 0xCC, 0xCC, 0x00 },   /* '' */
-	{ 0xFC, 0x00, 0xCC, 0xEC, 0xFC, 0xDC, 0xCC, 0x00 },   /* '' */
-	{ 0x3C, 0x6C, 0x6C, 0x3E, 0x00, 0x7E, 0x00, 0x00 },   /* '' */
-	{ 0x38, 0x6C, 0x6C, 0x38, 0x00, 0x7C, 0x00, 0x00 },   /* '' */
-	{ 0x30, 0x00, 0x30, 0x60, 0xC0, 0xCC, 0x78, 0x00 },   /* '' */
-	{ 0x00, 0x00, 0x00, 0xFC, 0xC0, 0xC0, 0x00, 0x00 },   /* '' */
-	{ 0x00, 0x00, 0x00, 0xFC, 0x0C, 0x0C, 0x00, 0x00 },   /* '' */
-	{ 0xC3, 0xC6, 0xCC, 0xDE, 0x33, 0x66, 0xCC, 0x0F },   /* '' */
-	{ 0xC3, 0xC6, 0xCC, 0xDB, 0x37, 0x6F, 0xCF, 0x03 },   /* '' */
-	{ 0x18, 0x18, 0x00, 0x18, 0x18, 0x18, 0x18, 0x00 },   /* '' */
-	{ 0x00, 0x33, 0x66, 0xCC, 0x66, 0x33, 0x00, 0x00 },   /* '' */
-	{ 0x00, 0xCC, 0x66, 0x33, 0x66, 0xCC, 0x00, 0x00 },   /* '' */
-	{ 0x22, 0x88, 0x22, 0x88, 0x22, 0x88, 0x22, 0x88 },   /* '' */
-	{ 0x55, 0xAA, 0x55, 0xAA, 0x55, 0xAA, 0x55, 0xAA },   /* '' */
-	{ 0xDB, 0x77, 0xDB, 0xEE, 0xDB, 0x77, 0xDB, 0xEE },   /* '' */
-	{ 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18 },   /* '' */
-	{ 0x18, 0x18, 0x18, 0x18, 0xF8, 0x18, 0x18, 0x18 },   /* '' */
-	{ 0x18, 0x18, 0xF8, 0x18, 0xF8, 0x18, 0x18, 0x18 },   /* '' */
-	{ 0x36, 0x36, 0x36, 0x36, 0xF6, 0x36, 0x36, 0x36 },   /* '' */
-	{ 0x00, 0x00, 0x00, 0x00, 0xFE, 0x36, 0x36, 0x36 },   /* '' */
-	{ 0x00, 0x00, 0xF8, 0x18, 0xF8, 0x18, 0x18, 0x18 },   /* '' */
-	{ 0x36, 0x36, 0xF6, 0x06, 0xF6, 0x36, 0x36, 0x36 },   /* '' */
-	{ 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36 },   /* '' */
-	{ 0x00, 0x00, 0xFE, 0x06, 0xF6, 0x36, 0x36, 0x36 },   /* '' */
-	{ 0x36, 0x36, 0xF6, 0x06, 0xFE, 0x00, 0x00, 0x00 },   /* '' */
-	{ 0x36, 0x36, 0x36, 0x36, 0xFE, 0x00, 0x00, 0x00 },   /* '' */
-	{ 0x18, 0x18, 0xF8, 0x18, 0xF8, 0x00, 0x00, 0x00 },   /* '' */
-	{ 0x00, 0x00, 0x00, 0x00, 0xF8, 0x18, 0x18, 0x18 },   /* '' */
-	{ 0x18, 0x18, 0x18, 0x18, 0x1F, 0x00, 0x00, 0x00 },   /* '' */
-	{ 0x18, 0x18, 0x18, 0x18, 0xFF, 0x00, 0x00, 0x00 },   /* '' */
-	{ 0x00, 0x00, 0x00, 0x00, 0xFF, 0x18, 0x18, 0x18 },   /* '' */
-	{ 0x18, 0x18, 0x18, 0x18, 0x1F, 0x18, 0x18, 0x18 },   /* '' */
-	{ 0x00, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00 },   /* '' */
-	{ 0x18, 0x18, 0x18, 0x18, 0xFF, 0x18, 0x18, 0x18 },   /* '' */
-	{ 0x18, 0x18, 0x1F, 0x18, 0x1F, 0x18, 0x18, 0x18 },   /* '' */
-	{ 0x36, 0x36, 0x36, 0x36, 0x37, 0x36, 0x36, 0x36 },   /* '' */
-	{ 0x36, 0x36, 0x37, 0x30, 0x3F, 0x00, 0x00, 0x00 },   /* '' */
-	{ 0x00, 0x00, 0x3F, 0x30, 0x37, 0x36, 0x36, 0x36 },   /* '' */
-	{ 0x36, 0x36, 0xF7, 0x00, 0xFF, 0x00, 0x00, 0x00 },   /* '' */
-	{ 0x00, 0x00, 0xFF, 0x00, 0xF7, 0x36, 0x36, 0x36 },   /* '' */
-	{ 0x36, 0x36, 0x37, 0x30, 0x37, 0x36, 0x36, 0x36 },   /* '' */
-	{ 0x00, 0x00, 0xFF, 0x00, 0xFF, 0x00, 0x00, 0x00 },   /* '' */
-	{ 0x36, 0x36, 0xF7, 0x00, 0xF7, 0x36, 0x36, 0x36 },   /* '' */
-	{ 0x18, 0x18, 0xFF, 0x00, 0xFF, 0x00, 0x00, 0x00 },   /* '' */
-	{ 0x36, 0x36, 0x36, 0x36, 0xFF, 0x00, 0x00, 0x00 },   /* '' */
-	{ 0x00, 0x00, 0xFF, 0x00, 0xFF, 0x18, 0x18, 0x18 },   /* '' */
-	{ 0x00, 0x00, 0x00, 0x00, 0xFF, 0x36, 0x36, 0x36 },   /* '' */
-	{ 0x36, 0x36, 0x36, 0x36, 0x3F, 0x00, 0x00, 0x00 },   /* '' */
-	{ 0x18, 0x18, 0x1F, 0x18, 0x1F, 0x00, 0x00, 0x00 },   /* '' */
-	{ 0x00, 0x00, 0x1F, 0x18, 0x1F, 0x18, 0x18, 0x18 },   /* '' */
-	{ 0x00, 0x00, 0x00, 0x00, 0x3F, 0x36, 0x36, 0x36 },   /* '' */
-	{ 0x36, 0x36, 0x36, 0x36, 0xFF, 0x36, 0x36, 0x36 },   /* '' */
-	{ 0x18, 0x18, 0xFF, 0x18, 0xFF, 0x18, 0x18, 0x18 },   /* '' */
-	{ 0x18, 0x18, 0x18, 0x18, 0xF8, 0x00, 0x00, 0x00 },   /* '' */
-	{ 0x00, 0x00, 0x00, 0x00, 0x1F, 0x18, 0x18, 0x18 },   /* '' */
-	{ 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF },   /* '' */
-	{ 0x00, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0xFF },   /* '' */
-	{ 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0 },   /* '' */
-	{ 0x0F, 0x0F, 0x0F, 0x0F, 0x0F, 0x0F, 0x0F, 0x0F },   /* '' */
-	{ 0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00 },   /* '' */
-	{ 0x00, 0x00, 0x76, 0xDC, 0xC8, 0xDC, 0x76, 0x00 },   /* '' */
-	{ 0x00, 0x78, 0xCC, 0xF8, 0xCC, 0xF8, 0xC0, 0xC0 },   /* '' */
-	{ 0x00, 0xFC, 0xCC, 0xC0, 0xC0, 0xC0, 0xC0, 0x00 },   /* '' */
-	{ 0x00, 0xFE, 0x6C, 0x6C, 0x6C, 0x6C, 0x6C, 0x00 },   /* '' */
-	{ 0xFC, 0xCC, 0x60, 0x30, 0x60, 0xCC, 0xFC, 0x00 },   /* '' */
-	{ 0x00, 0x00, 0x7E, 0xD8, 0xD8, 0xD8, 0x70, 0x00 },   /* '' */
-	{ 0x00, 0x66, 0x66, 0x66, 0x66, 0x7C, 0x60, 0xC0 },   /* '' */
-	{ 0x00, 0x76, 0xDC, 0x18, 0x18, 0x18, 0x18, 0x00 },   /* '' */
-	{ 0xFC, 0x30, 0x78, 0xCC, 0xCC, 0x78, 0x30, 0xFC },   /* '' */
-	{ 0x38, 0x6C, 0xC6, 0xFE, 0xC6, 0x6C, 0x38, 0x00 },   /* '' */
-	{ 0x38, 0x6C, 0xC6, 0xC6, 0x6C, 0x6C, 0xEE, 0x00 },   /* '' */
-	{ 0x1C, 0x30, 0x18, 0x7C, 0xCC, 0xCC, 0x78, 0x00 },   /* '' */
-	{ 0x00, 0x00, 0x7E, 0xDB, 0xDB, 0x7E, 0x00, 0x00 },   /* '' */
-	{ 0x06, 0x0C, 0x7E, 0xDB, 0xDB, 0x7E, 0x60, 0xC0 },   /* '' */
-	{ 0x38, 0x60, 0xC0, 0xF8, 0xC0, 0x60, 0x38, 0x00 },   /* '' */
-	{ 0x78, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x00 },   /* '' */
-	{ 0x00, 0xFC, 0x00, 0xFC, 0x00, 0xFC, 0x00, 0x00 },   /* '' */
-	{ 0x30, 0x30, 0xFC, 0x30, 0x30, 0x00, 0xFC, 0x00 },   /* '' */
-	{ 0x60, 0x30, 0x18, 0x30, 0x60, 0x00, 0xFC, 0x00 },   /* '' */
-	{ 0x18, 0x30, 0x60, 0x30, 0x18, 0x00, 0xFC, 0x00 },   /* '' */
-	{ 0x0E, 0x1B, 0x1B, 0x18, 0x18, 0x18, 0x18, 0x18 },   /* '' */
-	{ 0x18, 0x18, 0x18, 0x18, 0x18, 0xD8, 0xD8, 0x70 },   /* '' */
-	{ 0x30, 0x30, 0x00, 0xFC, 0x00, 0x30, 0x30, 0x00 },   /* '' */
-	{ 0x00, 0x76, 0xDC, 0x00, 0x76, 0xDC, 0x00, 0x00 },   /* '' */
-	{ 0x38, 0x6C, 0x6C, 0x38, 0x00, 0x00, 0x00, 0x00 },   /* '' */
-	{ 0x00, 0x00, 0x00, 0x18, 0x18, 0x00, 0x00, 0x00 },   /* '' */
-	{ 0x00, 0x00, 0x00, 0x00, 0x18, 0x00, 0x00, 0x00 },   /* '' */
-	{ 0x0F, 0x0C, 0x0C, 0x0C, 0xEC, 0x6C, 0x3C, 0x1C },   /* '' */
-	{ 0x78, 0x6C, 0x6C, 0x6C, 0x6C, 0x00, 0x00, 0x00 },   /* '' */
-	{ 0x70, 0x18, 0x30, 0x60, 0x78, 0x00, 0x00, 0x00 },   /* '' */
-	{ 0x00, 0x00, 0x3C, 0x3C, 0x3C, 0x3C, 0x00, 0x00 },   /* '' */
-	{ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },   /* '' */
+	{ 0x78, 0xCC, 0xC0, 0xCC, 0x78, 0x18, 0x0C, 0x78 },   /* '' */
+	{ 0x00, 0xCC, 0x00, 0xCC, 0xCC, 0xCC, 0x7E, 0x00 },   /* '' */
+	{ 0x1C, 0x00, 0x78, 0xCC, 0xFC, 0xC0, 0x78, 0x00 },   /* '' */
+	{ 0x7E, 0xC3, 0x3C, 0x06, 0x3E, 0x66, 0x3F, 0x00 },   /* '' */
+	{ 0xCC, 0x00, 0x78, 0x0C, 0x7C, 0xCC, 0x7E, 0x00 },   /* '' */
+	{ 0xE0, 0x00, 0x78, 0x0C, 0x7C, 0xCC, 0x7E, 0x00 },   /* '' */
+	{ 0x30, 0x30, 0x78, 0x0C, 0x7C, 0xCC, 0x7E, 0x00 },   /* '' */
+	{ 0x00, 0x00, 0x78, 0xC0, 0xC0, 0x78, 0x0C, 0x38 },   /* '' */
+	{ 0x7E, 0xC3, 0x3C, 0x66, 0x7E, 0x60, 0x3C, 0x00 },   /* '' */
+	{ 0xCC, 0x00, 0x78, 0xCC, 0xFC, 0xC0, 0x78, 0x00 },   /* '' */
+	{ 0xE0, 0x00, 0x78, 0xCC, 0xFC, 0xC0, 0x78, 0x00 },   /* '' */
+	{ 0xCC, 0x00, 0x70, 0x30, 0x30, 0x30, 0x78, 0x00 },   /* '' */
+	{ 0x7C, 0xC6, 0x38, 0x18, 0x18, 0x18, 0x3C, 0x00 },   /* '' */
+	{ 0xE0, 0x00, 0x70, 0x30, 0x30, 0x30, 0x78, 0x00 },   /* '' */
+	{ 0xC6, 0x38, 0x6C, 0xC6, 0xFE, 0xC6, 0xC6, 0x00 },   /* '' */
+	{ 0x30, 0x30, 0x00, 0x78, 0xCC, 0xFC, 0xCC, 0x00 },   /* '' */
+	{ 0x1C, 0x00, 0xFC, 0x60, 0x78, 0x60, 0xFC, 0x00 },   /* '' */
+	{ 0x00, 0x00, 0x7F, 0x0C, 0x7F, 0xCC, 0x7F, 0x00 },   /* '' */
+	{ 0x3E, 0x6C, 0xCC, 0xFE, 0xCC, 0xCC, 0xCE, 0x00 },   /* '' */
+	{ 0x78, 0xCC, 0x00, 0x78, 0xCC, 0xCC, 0x78, 0x00 },   /* '' */
+	{ 0x00, 0xCC, 0x00, 0x78, 0xCC, 0xCC, 0x78, 0x00 },   /* '' */
+	{ 0x00, 0xE0, 0x00, 0x78, 0xCC, 0xCC, 0x78, 0x00 },   /* '' */
+	{ 0x78, 0xCC, 0x00, 0xCC, 0xCC, 0xCC, 0x7E, 0x00 },   /* '' */
+	{ 0x00, 0xE0, 0x00, 0xCC, 0xCC, 0xCC, 0x7E, 0x00 },   /* '' */
+	{ 0x00, 0xCC, 0x00, 0xCC, 0xCC, 0x7C, 0x0C, 0xF8 },   /* '' */
+	{ 0xC3, 0x18, 0x3C, 0x66, 0x66, 0x3C, 0x18, 0x00 },   /* '' */
+	{ 0xCC, 0x00, 0xCC, 0xCC, 0xCC, 0xCC, 0x78, 0x00 },   /* '' */
+	{ 0x18, 0x18, 0x7E, 0xC0, 0xC0, 0x7E, 0x18, 0x18 },   /* '' */
+	{ 0x38, 0x6C, 0x64, 0xF0, 0x60, 0xE6, 0xFC, 0x00 },   /* '' */
+	{ 0xCC, 0xCC, 0x78, 0xFC, 0x30, 0xFC, 0x30, 0x30 },   /* '' */
+	{ 0xF8, 0xCC, 0xCC, 0xFA, 0xC6, 0xCF, 0xC6, 0xC7 },   /* '' */
+	{ 0x0E, 0x1B, 0x18, 0x3C, 0x18, 0x18, 0xD8, 0x70 },   /* '' */
+	{ 0x1C, 0x00, 0x78, 0x0C, 0x7C, 0xCC, 0x7E, 0x00 },   /* '' */
+	{ 0x38, 0x00, 0x70, 0x30, 0x30, 0x30, 0x78, 0x00 },   /* '' */
+	{ 0x00, 0x1C, 0x00, 0x78, 0xCC, 0xCC, 0x78, 0x00 },   /* '' */
+	{ 0x00, 0x1C, 0x00, 0xCC, 0xCC, 0xCC, 0x7E, 0x00 },   /* '' */
+	{ 0x00, 0xF8, 0x00, 0xF8, 0xCC, 0xCC, 0xCC, 0x00 },   /* '' */
+	{ 0xFC, 0x00, 0xCC, 0xEC, 0xFC, 0xDC, 0xCC, 0x00 },   /* '' */
+	{ 0x3C, 0x6C, 0x6C, 0x3E, 0x00, 0x7E, 0x00, 0x00 },   /* '' */
+	{ 0x38, 0x6C, 0x6C, 0x38, 0x00, 0x7C, 0x00, 0x00 },   /* '' */
+	{ 0x30, 0x00, 0x30, 0x60, 0xC0, 0xCC, 0x78, 0x00 },   /* '' */
+	{ 0x00, 0x00, 0x00, 0xFC, 0xC0, 0xC0, 0x00, 0x00 },   /* '' */
+	{ 0x00, 0x00, 0x00, 0xFC, 0x0C, 0x0C, 0x00, 0x00 },   /* '' */
+	{ 0xC3, 0xC6, 0xCC, 0xDE, 0x33, 0x66, 0xCC, 0x0F },   /* '' */
+	{ 0xC3, 0xC6, 0xCC, 0xDB, 0x37, 0x6F, 0xCF, 0x03 },   /* '' */
+	{ 0x18, 0x18, 0x00, 0x18, 0x18, 0x18, 0x18, 0x00 },   /* '' */
+	{ 0x00, 0x33, 0x66, 0xCC, 0x66, 0x33, 0x00, 0x00 },   /* '' */
+	{ 0x00, 0xCC, 0x66, 0x33, 0x66, 0xCC, 0x00, 0x00 },   /* '' */
+	{ 0x22, 0x88, 0x22, 0x88, 0x22, 0x88, 0x22, 0x88 },   /* '' */
+	{ 0x55, 0xAA, 0x55, 0xAA, 0x55, 0xAA, 0x55, 0xAA },   /* '' */
+	{ 0xDB, 0x77, 0xDB, 0xEE, 0xDB, 0x77, 0xDB, 0xEE },   /* '' */
+	{ 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18 },   /* '' */
+	{ 0x18, 0x18, 0x18, 0x18, 0xF8, 0x18, 0x18, 0x18 },   /* '' */
+	{ 0x18, 0x18, 0xF8, 0x18, 0xF8, 0x18, 0x18, 0x18 },   /* '' */
+	{ 0x36, 0x36, 0x36, 0x36, 0xF6, 0x36, 0x36, 0x36 },   /* '' */
+	{ 0x00, 0x00, 0x00, 0x00, 0xFE, 0x36, 0x36, 0x36 },   /* '' */
+	{ 0x00, 0x00, 0xF8, 0x18, 0xF8, 0x18, 0x18, 0x18 },   /* '' */
+	{ 0x36, 0x36, 0xF6, 0x06, 0xF6, 0x36, 0x36, 0x36 },   /* '' */
+	{ 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36 },   /* '' */
+	{ 0x00, 0x00, 0xFE, 0x06, 0xF6, 0x36, 0x36, 0x36 },   /* '' */
+	{ 0x36, 0x36, 0xF6, 0x06, 0xFE, 0x00, 0x00, 0x00 },   /* '' */
+	{ 0x36, 0x36, 0x36, 0x36, 0xFE, 0x00, 0x00, 0x00 },   /* '' */
+	{ 0x18, 0x18, 0xF8, 0x18, 0xF8, 0x00, 0x00, 0x00 },   /* '' */
+	{ 0x00, 0x00, 0x00, 0x00, 0xF8, 0x18, 0x18, 0x18 },   /* '' */
+	{ 0x18, 0x18, 0x18, 0x18, 0x1F, 0x00, 0x00, 0x00 },   /* '' */
+	{ 0x18, 0x18, 0x18, 0x18, 0xFF, 0x00, 0x00, 0x00 },   /* '' */
+	{ 0x00, 0x00, 0x00, 0x00, 0xFF, 0x18, 0x18, 0x18 },   /* '' */
+	{ 0x18, 0x18, 0x18, 0x18, 0x1F, 0x18, 0x18, 0x18 },   /* '' */
+	{ 0x00, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00 },   /* '' */
+	{ 0x18, 0x18, 0x18, 0x18, 0xFF, 0x18, 0x18, 0x18 },   /* '' */
+	{ 0x18, 0x18, 0x1F, 0x18, 0x1F, 0x18, 0x18, 0x18 },   /* '' */
+	{ 0x36, 0x36, 0x36, 0x36, 0x37, 0x36, 0x36, 0x36 },   /* '' */
+	{ 0x36, 0x36, 0x37, 0x30, 0x3F, 0x00, 0x00, 0x00 },   /* '' */
+	{ 0x00, 0x00, 0x3F, 0x30, 0x37, 0x36, 0x36, 0x36 },   /* '' */
+	{ 0x36, 0x36, 0xF7, 0x00, 0xFF, 0x00, 0x00, 0x00 },   /* '' */
+	{ 0x00, 0x00, 0xFF, 0x00, 0xF7, 0x36, 0x36, 0x36 },   /* '' */
+	{ 0x36, 0x36, 0x37, 0x30, 0x37, 0x36, 0x36, 0x36 },   /* '' */
+	{ 0x00, 0x00, 0xFF, 0x00, 0xFF, 0x00, 0x00, 0x00 },   /* '' */
+	{ 0x36, 0x36, 0xF7, 0x00, 0xF7, 0x36, 0x36, 0x36 },   /* '' */
+	{ 0x18, 0x18, 0xFF, 0x00, 0xFF, 0x00, 0x00, 0x00 },   /* '' */
+	{ 0x36, 0x36, 0x36, 0x36, 0xFF, 0x00, 0x00, 0x00 },   /* '' */
+	{ 0x00, 0x00, 0xFF, 0x00, 0xFF, 0x18, 0x18, 0x18 },   /* '' */
+	{ 0x00, 0x00, 0x00, 0x00, 0xFF, 0x36, 0x36, 0x36 },   /* '' */
+	{ 0x36, 0x36, 0x36, 0x36, 0x3F, 0x00, 0x00, 0x00 },   /* '' */
+	{ 0x18, 0x18, 0x1F, 0x18, 0x1F, 0x00, 0x00, 0x00 },   /* '' */
+	{ 0x00, 0x00, 0x1F, 0x18, 0x1F, 0x18, 0x18, 0x18 },   /* '' */
+	{ 0x00, 0x00, 0x00, 0x00, 0x3F, 0x36, 0x36, 0x36 },   /* '' */
+	{ 0x36, 0x36, 0x36, 0x36, 0xFF, 0x36, 0x36, 0x36 },   /* '' */
+	{ 0x18, 0x18, 0xFF, 0x18, 0xFF, 0x18, 0x18, 0x18 },   /* '' */
+	{ 0x18, 0x18, 0x18, 0x18, 0xF8, 0x00, 0x00, 0x00 },   /* '' */
+	{ 0x00, 0x00, 0x00, 0x00, 0x1F, 0x18, 0x18, 0x18 },   /* '' */
+	{ 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF },   /* '' */
+	{ 0x00, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0xFF },   /* '' */
+	{ 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0 },   /* '' */
+	{ 0x0F, 0x0F, 0x0F, 0x0F, 0x0F, 0x0F, 0x0F, 0x0F },   /* '' */
+	{ 0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00 },   /* '' */
+	{ 0x00, 0x00, 0x76, 0xDC, 0xC8, 0xDC, 0x76, 0x00 },   /* '' */
+	{ 0x00, 0x78, 0xCC, 0xF8, 0xCC, 0xF8, 0xC0, 0xC0 },   /* '' */
+	{ 0x00, 0xFC, 0xCC, 0xC0, 0xC0, 0xC0, 0xC0, 0x00 },   /* '' */
+	{ 0x00, 0xFE, 0x6C, 0x6C, 0x6C, 0x6C, 0x6C, 0x00 },   /* '' */
+	{ 0xFC, 0xCC, 0x60, 0x30, 0x60, 0xCC, 0xFC, 0x00 },   /* '' */
+	{ 0x00, 0x00, 0x7E, 0xD8, 0xD8, 0xD8, 0x70, 0x00 },   /* '' */
+	{ 0x00, 0x66, 0x66, 0x66, 0x66, 0x7C, 0x60, 0xC0 },   /* '' */
+	{ 0x00, 0x76, 0xDC, 0x18, 0x18, 0x18, 0x18, 0x00 },   /* '' */
+	{ 0xFC, 0x30, 0x78, 0xCC, 0xCC, 0x78, 0x30, 0xFC },   /* '' */
+	{ 0x38, 0x6C, 0xC6, 0xFE, 0xC6, 0x6C, 0x38, 0x00 },   /* '' */
+	{ 0x38, 0x6C, 0xC6, 0xC6, 0x6C, 0x6C, 0xEE, 0x00 },   /* '' */
+	{ 0x1C, 0x30, 0x18, 0x7C, 0xCC, 0xCC, 0x78, 0x00 },   /* '' */
+	{ 0x00, 0x00, 0x7E, 0xDB, 0xDB, 0x7E, 0x00, 0x00 },   /* '' */
+	{ 0x06, 0x0C, 0x7E, 0xDB, 0xDB, 0x7E, 0x60, 0xC0 },   /* '' */
+	{ 0x38, 0x60, 0xC0, 0xF8, 0xC0, 0x60, 0x38, 0x00 },   /* '' */
+	{ 0x78, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x00 },   /* '' */
+	{ 0x00, 0xFC, 0x00, 0xFC, 0x00, 0xFC, 0x00, 0x00 },   /* '' */
+	{ 0x30, 0x30, 0xFC, 0x30, 0x30, 0x00, 0xFC, 0x00 },   /* '' */
+	{ 0x60, 0x30, 0x18, 0x30, 0x60, 0x00, 0xFC, 0x00 },   /* '' */
+	{ 0x18, 0x30, 0x60, 0x30, 0x18, 0x00, 0xFC, 0x00 },   /* '' */
+	{ 0x0E, 0x1B, 0x1B, 0x18, 0x18, 0x18, 0x18, 0x18 },   /* '' */
+	{ 0x18, 0x18, 0x18, 0x18, 0x18, 0xD8, 0xD8, 0x70 },   /* '' */
+	{ 0x30, 0x30, 0x00, 0xFC, 0x00, 0x30, 0x30, 0x00 },   /* '' */
+	{ 0x00, 0x76, 0xDC, 0x00, 0x76, 0xDC, 0x00, 0x00 },   /* '' */
+	{ 0x38, 0x6C, 0x6C, 0x38, 0x00, 0x00, 0x00, 0x00 },   /* '' */
+	{ 0x00, 0x00, 0x00, 0x18, 0x18, 0x00, 0x00, 0x00 },   /* '' */
+	{ 0x00, 0x00, 0x00, 0x00, 0x18, 0x00, 0x00, 0x00 },   /* '' */
+	{ 0x0F, 0x0C, 0x0C, 0x0C, 0xEC, 0x6C, 0x3C, 0x1C },   /* '' */
+	{ 0x78, 0x6C, 0x6C, 0x6C, 0x6C, 0x00, 0x00, 0x00 },   /* '' */
+	{ 0x70, 0x18, 0x30, 0x60, 0x78, 0x00, 0x00, 0x00 },   /* '' */
+	{ 0x00, 0x00, 0x3C, 0x3C, 0x3C, 0x3C, 0x00, 0x00 },   /* '' */
+	{ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },   /* '' */
 };
